<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>以太网介绍 |  Welcome</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
        <style>
            .outer {
                margin-left: 15%;
            }
        </style>
      <section class="outer">
  <article
  id="post-以太网介绍"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  以太网介绍
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/08/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2023-07-08T03:42:54.000Z" itemprop="datePublished">2023-07-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8D%8F%E8%AE%AE/">协议</a> / <a class="article-category-link" href="/categories/%E5%8D%8F%E8%AE%AE/%E6%8E%A5%E5%8F%A3/">接口</a> / <a class="article-category-link" href="/categories/%E5%8D%8F%E8%AE%AE/%E6%8E%A5%E5%8F%A3/%E4%BB%A5%E5%A4%AA%E7%BD%91/">以太网</a>
  </div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统、网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。计算机网络类型的划分标准各种各样，按网络所覆盖的地理范围的不同，计算机网络可分为局域网(LAN)、 城域网(MAN)、广域网(WAN)、互联网(Initernet)。局域网按传输介质所使用的访问控制方法可分为：以太网(Ethernet)、光纤分布式数据接口(FDDI)、异步传输模式(ATM)、令牌环网(Token Ring)、交换网(Switching) 等，它们在拓朴结构、传输介质、传输速率、数据格式等多方面都有许多不同，其中应用最广泛的当属以太网。</p>
<p>以太网是为了实现局域网通信而设计的一种技术，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。以太网根据最大传输速率的不同可以分为标准的以太网(10Mbit&#x2F;s)、快速以太网(100Mbit&#x2F;s)、千兆以太网 (1000Mbit&#x2F;s)和万兆以太网(10Gbit&#x2F;s)。百兆网和千兆网是目前应用最多的，顾名思义，百兆网的最大传输速率为 100Mbit&#x2F;s，需要注意的是，我们常见的网速的单位是 MByte&#x2F;s，而 1Byte 为 8bit，所以百兆网能达到的最大网速为 12.5MByte&#x2F;s。同理，千兆网的最大传输速率为 1000Mbit&#x2F;s，能达到的最大网速为 125MByte&#x2F;s。</p>
<h1 id="计算机网络体系结构模型"><a href="#计算机网络体系结构模型" class="headerlink" title="计算机网络体系结构模型"></a>计算机网络体系结构模型</h1><p>国际标准化组织(ISO)在 1978 年提出了“开放系统互联参考模型”，即著名的 OSI&#x2F;RM 模型(Open System  Interconnection&#x2F;Reference Model)。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层(Physics Layer)、数据链路层(Data Link Layer)、网络层(Network Layer)、传输层(Transport Layer)、会话层(Session Layer)、表示层(Presentation Layer)、应用层 (Application Layer)。下面 4 层主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第 4 层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；上 3 层则以提供用户与应用程序之间的信息和数据处理功能为主。</p>
<p>除了标准的 OSI 七层模型以外，常见的网络层次划分还有 TCP&#x2F;IP 四层协议，它们之间的对应关系如图所示：</p>
<img src="/MD_IMG/以太网.assets/image-20220125203948363.png" alt="image-20220125203948363" style="zoom:80%;" />

<p>不管是 OSI 七层模型还是 TCP&#x2F;IP 的四层模型，它们每一层中都有自己的专属协议，需要完成相应的工作以及与上下层级之间进行沟通。由于目前 TCP&#x2F;IP 协议已经成为 Internet 中的【通用语言】，任何和互联网有关的操作都离不开 TCP&#x2F;IP 协议，没有它我们就根本不可能上网，所以下面就以 TCP&#x2F;IP 协议为主来进行讲解。</p>
<ul>
<li><strong>应用层</strong>：为操作系统或网络应用程序提供访问网络服务的接口，主要协议有文件传输协议(FTP)，超文本传输协议(HTTP)，简单邮件传输协议(SMTP)，远程登录(Telnet)；</li>
<li><strong>传输层</strong>：为两台主机上的应用程序提供端到端的通信，在 TCP&#x2F;IP 协议簇中，有两个不同的传输协议：TCP(传输控制协议)和 UDP(用户数据报协议)，它们分别承载不同的应用。TCP 协议是一种面向连接的传输，能够提供可靠的字节流传输服务，UDP 协议是一种简单的面向数据报的传输层协议，与 TCP 协议不同的是 UDP 无法保证数据报文准确达到目的地。</li>
<li><strong>网络层</strong>：负责提供基本的数据封包传送功能，让每个据包都能够到达目的主机，主要协议有 IP 协议(网际协议)、ICMP 协议(Internet 互连网控制报文协议)、ARP&#x2F;RARP (地址解析&#x2F;反向地址解析协议)以及 IGMP 协议(Internet 组管理协议)。</li>
<li><strong>网络接口层</strong>：通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡，它们一起处理与电缆的物理接口细节，主要协议有：以太网、令牌环、帧中继等；</li>
</ul>
<img src="/MD_IMG/以太网.assets/image-20220125204150283.png" alt="image-20220125204150283"  />

<p>从该图中可以看出，当主机 A 向主机 B 发送数据时，用户数据将由应用层产生；当用户数据在经过传输层时，传输层对用户数据进行封装，在用户数据的基础上添加了一个 TCP&#x2F;UDP 首部数据，此时数据包变成了 TCP&#x2F;UDP 段；当它经过网络层时，网络层对 TCP&#x2F;UDP 段进行封装，在 TCP&#x2F;UDP 段的基础上添加了一个 IP 首部数据，此时 TCP&#x2F;UDP 段变成了 IP 数据报；当 它经过网络接口层时，网络接口层对 IP 数据报进行封装，在 IP 数据报的基础上添加了以太网首部数据和以太网尾部（一般为 4byte CRC校验值）两个数据，此时 IP 数据报变成了以太网帧。由此可以看出，数据经过层层封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部数据，最后将应用层数据交给主机 B 处理。</p>
<h1 id="MAC-x2F-PHY-基本概念"><a href="#MAC-x2F-PHY-基本概念" class="headerlink" title="MAC&#x2F;PHY 基本概念"></a>MAC&#x2F;PHY 基本概念</h1><p>MAC 即媒介访问控制层（Media Access Control）, 位于TCP&#x2F;IP协议栈的第二层-数据链路层，用于数据传输过程的数据流控制，其将上层IP数据包分割成适合于物理层传输的数据帧，并负责数据传输的冲突管理。按照 IEEE Std 802-2001 上的定义，MAC主要做如下几个事情：</p>
<ul>
<li>数据帧的封装与识别</li>
<li>根据MAC地址来与目标主机进行通讯</li>
<li>检测数据传输错误（MAC帧中有一个FCS, Frame Checksum Sequence)</li>
<li>物理媒介的访问控制，半双工情况下需要进行传输冲突控制，如CSMA&#x2F;CD</li>
</ul>
<hr>
<p>PHY（Physical layer) 即物理层， 其主要负责物理信号的传输， 其通过线束（如光纤&#x2F;铜线）与其他设备进行连接。一个PHY芯片主要包含了两个部分: PCS(Physical Coding Sublayer), PMD(Physical Medium Dependent), 对车载PHY芯片来说，通常还包含了一个PMA(Physical Media Attachment)子层, 位于PCS与PMD之间。</p>
<h1 id="MAC与PHY之间的接口"><a href="#MAC与PHY之间的接口" class="headerlink" title="MAC与PHY之间的接口"></a>MAC与PHY之间的接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Media  Independent  Interface ( MII)</strong> ，介质独立接口，起初是定义100M以太网（Fast Ethernet）的 MAC  层与 PHY 芯片之间的传输标准（802.3u）。介质独立的意思是指，MAC 与 PHY 之间的通信不受具体传输介质（双绞线或光纤等）的影响，任何 MAC 和 PHY 都可以通过 MII 接口互连。</p>
<p><strong>MDIO</strong> 是 MII 接口的一部分，用于在 MAC 和 PHY 之间传递配置信息。在系统上电瞬间，PHY 芯片通过管脚的电平状态确定原始设置，进而通过 MDIO 更改配置。</p>
<p>最初 MII 定义数据 4 bit 发送 + 4 bit 接收，每位数据速率  25MHz ，总数据速率 100Mbps。其它  MII 标准的变种，包括 RMII，GMII，RGMII，XGMII，SGMII，基本上都是定位于<strong>更高速率</strong>或者<strong>更少的信号数</strong>的目标。</p>
<p>下图表示在以太网通信层次模型中MII接口的位置：</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618172240278.png" alt="image-20230618172240278"></p>
<hr>
<p>针对不同的应用场景，目前MAC与PHY之间的主要数据传输接口有</p>
<ul>
<li><strong>MII（Media Independent Interface）</strong> ：支持 10&#x2F;100 Mbps，数据位宽为 4 bits；在 100Mbps传输速率下，时钟频率为 25 MHz</li>
<li><strong>RMII（Reduce MII）</strong> ：MII 的简化版，数据位宽为 2 bits；在 100Mbps传输速率下，时钟频率为 50 MHz</li>
<li><strong>GMII（Gigabit MII）</strong> ：GMII 接口向下兼容 MII 接口，支持 10&#x2F;100&#x2F;1000 Mbps，数据位宽为 8 bits；在 100Mbps传输速率下，时钟频率为 125 MHz</li>
<li><strong>RGMII（Reduce Gigabit MII）</strong> ：GMII 的简化版，数据位宽为 4 bits；在 100Mbps传输速率下，时钟频率为 125 MHz，但是在为时钟上下沿同时采样数据</li>
<li><strong>SGMII（Serial GIgabit MII）</strong> ：串行 GMII，收发各一对差分信号线，时钟频率为 625 MHz，在时钟上下沿同时采样；有效数据带宽1000Mbps，每 10bits 数据包含 8bits 数据位 和 2 bits 控制位</li>
<li><strong>XGMII（10-GIgabit MII）</strong> ：速率 10 Gbps，数据位宽为 32 bits，时钟为156.25 MHz，时钟上下沿采样</li>
</ul>
<h2 id="MDIO-x2F-MDC"><a href="#MDIO-x2F-MDC" class="headerlink" title="MDIO&#x2F;MDC"></a>MDIO&#x2F;MDC</h2><p>SMI（Serial Management Interface）串行管理接口，也被称作 MII 管理接口（MII Management Interface），包括 MDC 和 MDIO 两条信号线。</p>
<ul>
<li><p>MDIO 是一个 PHY 的管理接口，用来读写 PHY 的寄存器，以控制 PHY 的行为或获取 PHY 的状态</p>
</li>
<li><p>MDC 为 MDIO 提供时钟，由 MAC 端提供</p>
</li>
</ul>
<h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230617165550497.png" alt="image-20230617165550497"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Preamble</td>
<td>由 MAC 发送 32 个连续的逻辑 “1”，同步于 MDC 信号，用于 MAC 与 PHY 之间的同步</td>
</tr>
<tr>
<td>ST</td>
<td>帧开始位，固定为 “01”</td>
</tr>
<tr>
<td>OP</td>
<td>操作码，“10” 表示读，“01” 表示写</td>
</tr>
<tr>
<td>PHYAD</td>
<td>PHY 的地址，5 bits</td>
</tr>
<tr>
<td>REGAD</td>
<td>寄存器地址，5 bits</td>
</tr>
<tr>
<td>TA</td>
<td>Turn Around， MDIO方向转换<br />① 在写状态下，不需要转换方向，值为 “10”<br />② 在读状态下，MAC 输出端为高阻态，在第二个周期 PHY 将 MDIO 拉低</td>
</tr>
<tr>
<td>DATA</td>
<td>16 bits 数据</td>
</tr>
<tr>
<td>IDLE</td>
<td>空闲状态。此状态下 MDIO 为高阻态，由外部上拉电阻拉高</td>
</tr>
</tbody></table>
<h3 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h3><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230617171004193.png" alt="image-20230617171004193"></p>
<p>可以看到在 Turn Around状态下，第一个周期 MDIO 为高阻态，第二个周期由 PHY 端拉低。</p>
<h3 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h3><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230617171105923.png" alt="image-20230617171105923"></p>
<p>为了保证能够正确采集到数据，在 MDC 上升沿之前就把数据准备好。</p>
<h2 id="MII"><a href="#MII" class="headerlink" title="MII"></a>MII</h2><p>Mll 共计 18 根信号线，只有 MDIO&#x2F;MDC 信号可以在不同 PHY 间级联。假定系统中有 8 个 PHY，则 Mll 信号总数为 8*16+2&#x3D;130 根！为减少信号数，RMII 接口应运而生。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618174758423.png" alt="image-20230618174758423"></p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>方向（MAC 端）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TX_CLK</td>
<td>Input</td>
<td>发送数据参考时钟，由 PHY 提供<br />① 100 Mbps 速率下，时钟频率为 25 MHz<br />② 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>TXD[3:0]</td>
<td>Output</td>
<td>发送数据信号</td>
</tr>
<tr>
<td>TX_EN</td>
<td>Output</td>
<td>发送数据使能信号，TXD 在 TX_EN 拉高时才有效</td>
</tr>
<tr>
<td>TX_ER</td>
<td>Output</td>
<td>① 发送数据错误提示信号， TXD 在 TX_ER 拉高时无效<br />② 10Mbps 速率下，TX_ER 不起作用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RX_CLK</td>
<td>Input</td>
<td>接收数据参考时钟，由 PHY 提供<br />① 100 Mbps 速率下，时钟频率为 25 MHz<br />② 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>RX_D[3:0]</td>
<td>Input</td>
<td>接收数据信号</td>
</tr>
<tr>
<td>RX_DV</td>
<td>Input</td>
<td>接收数据使能信号，RXD 在 RX_DV 拉高时才有效</td>
</tr>
<tr>
<td>RX_ER</td>
<td>Input</td>
<td>① 接收数据错误提示信号， RXD 在 RX_ER 拉高时无效<br />② 10Mbps 速率下，RX_ER 不起作用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>COL</td>
<td>Input</td>
<td>① 载波侦测信号，不需要同步于参考时钟<br />② 只要有数据传输，CAS 就有效<br />③  CAS信号只有 PHY 在半双工模式下有效</td>
</tr>
<tr>
<td>CRS</td>
<td>Input</td>
<td>① 冲突检测信号，不需要同步于参考时钟<br />②  COL 信号只有 PHY 在半双工模式下有效</td>
</tr>
</tbody></table>
<h2 id="RMII"><a href="#RMII" class="headerlink" title="RMII"></a>RMII</h2><p>相比于 MII 接口，RMII 有以下四处变化：</p>
<ol>
<li>TXCLK 和 RXCLK 两个时钟信号，合并为一个时钟 REFCLK</li>
<li>时钟速率由 25MHz 上升到 50MHz，单向数据由 4 bits 变为 2 bits </li>
<li>CRS 和 RX_DV 合并为一个信号 CRS_DV</li>
<li>取消了COL信号</li>
</ol>
<p>RMII 信号如下图所示。RMII 只要 9 根信号线，相比于 MII 的 18 根信号少了一半，在同一个系统中的多个设备可以共享 MDIO，MDC 和 REFCLK 信号线。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618175120605.png" alt="image-20230618175120605"></p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>方向（MAC 端）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REF_CLK</td>
<td>Output</td>
<td>参考时钟，50 MHz</td>
</tr>
<tr>
<td>TXD[2:0]</td>
<td>Output</td>
<td>发送数据信号</td>
</tr>
<tr>
<td>TX_EN</td>
<td>Output</td>
<td>发送数据使能信号，TXD 在 TX_EN 拉高时才有效</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RX_D[3:0]</td>
<td>Input</td>
<td>接收数据信号</td>
</tr>
<tr>
<td>RX_ER</td>
<td>Input</td>
<td>① 接收数据错误提示信号， RXD 在 RX_ER 拉高时无效<br />② 10Mbps 速率下，RX_ER 不起作用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CRS_DV</td>
<td>Input</td>
<td>① 由 MII 接口的 RX_DV 和 CAS 合并而成<br />② 当介质不空闲时，CRS_DV 和 REFCLK 相异步给出<br />③ 当 CRS 比 RX_DV 早结束时（即载波消失而队列中海油数据要传输时），就会出现 CRS_DV 在半位元组的边界以 25&#x2F;2.5 MHz 的频率在0、1之间来回切换。因此，MAC 能够从 CRS_DV 中精确恢复出 RX_DV 和 CRS。</td>
</tr>
</tbody></table>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230617204319141.png" alt="image-20230617204319141"></p>
<p>在100Mbps速率时，TX&#x2F;RX每个时钟周期采样一个数据；在10Mbps速率时，TX&#x2F;RX每隔10个周期采样一个数据，因而TX&#x2F;RX数据需要在数据线上保留10个周期，相当于一个数据发送10次。</p>
<p>当PHY层芯片收到有效的载波信号后，CRS_DV信号变为有效，此时如果FIFO中还没有数据，则它会发送出全0的数据给MAC，然后当FIFO中填入有效的数据帧，数据帧的开头是“101010—”交叉的前导码，当数据中出现“01”的比特时，代表正式数据传输开始，MAC芯片检测到这一变化，从而开始接收数据。</p>
<p>当外部载波信号消失后，CRS_DV会变为无效，但如果FIFO中还有数据要发送时，CRS_DV在下一周期又会变为有效，然后再无效再有效，直到FIFO中数据发送完为止。在接收过程中如果出现无效的载波信号或者无效的数据编码，则RX_ER会变为有效，表示物理层芯片接收出错。</p>
<h2 id="GMII"><a href="#GMII" class="headerlink" title="GMII"></a>GMII</h2><p>与 MII 接口相比，GMII 接口的数据速率可达 1000Mbps，数据宽度由 4 位变为 8 位，在实际应用中，绝大多数 GMII 接口都是兼容 MII 接口的，所以，一般的 GMII 接口都有两个发送参考时钟：TX_CLK 和 GTX_CLK (两者的方向是不一样的)，在用作 MII 模式时，使用 TX_CLK 和 8 根数据线中的 4 根。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618175422199.png" alt="image-20230618175422199"></p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>方向（MAC 端）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GTX_CLK</td>
<td>Output</td>
<td>发送数据参考时钟，由 MAC 提供<br />① 1000 Mbps 速率下，时钟频率为 125 MHz<br />② 100 Mbps 速率下，时钟频率为 25 MHz<br />③ 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>TXD[7:0]</td>
<td>Output</td>
<td>发送数据信号</td>
</tr>
<tr>
<td>TX_EN</td>
<td>Output</td>
<td>发送数据使能信号，TXD 在 TX_EN 拉高时才有效</td>
</tr>
<tr>
<td>TX_ER</td>
<td>Output</td>
<td>发送数据错误提示信号， TXD 在 TX_ER 拉高时无效</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RX_CLK</td>
<td>Input</td>
<td>接收数据参考时钟，由 PHY 提供<br />① 1000 Mbps 速率下，时钟频率为 125 MHz<br />② 100 Mbps 速率下，时钟频率为 25 MHz<br />③ 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>RX_D[7:0]</td>
<td>Input</td>
<td>接收数据信号</td>
</tr>
<tr>
<td>RX_DV</td>
<td>Input</td>
<td>接收数据使能信号，RXD 在 RX_DV 拉高时才有效</td>
</tr>
<tr>
<td>RX_ER</td>
<td>Input</td>
<td>接收数据错误提示信号， RXD 在 RX_ER 拉高时无效</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>COL</td>
<td>Input</td>
<td>① 载波侦测信号，不需要同步于参考时钟<br />② 只要有数据传输，CAS 就有效<br />③  CAS信号只有 PHY 在半双工模式下有效</td>
</tr>
<tr>
<td>CRS</td>
<td>Input</td>
<td>① 冲突检测信号，不需要同步于参考时钟<br />②  COL 信号只有 PHY 在半双工模式下有效</td>
</tr>
</tbody></table>
<h2 id="RGMII"><a href="#RGMII" class="headerlink" title="RGMII"></a>RGMII</h2><p>RGMII 相比于 GMII 减小将近一半的管脚数（24 -&gt;12），通过以下两种方式：</p>
<ul>
<li>1000Mbps 模式下，在时钟的上&#x2F;下边沿均采样数据；10&#x2F;100Mbps 模式，数据仅在时钟上升沿采样</li>
<li>取消不重要的如 CRS，COL 等信号</li>
<li>TXC 只由 MAC提供，不像 GMII 接口（10&#x2F;100Mbps 模式下时钟是由 PHY 提供（TXCLK），而 1000Mbps 模式下时钟是由 MAC 提供）</li>
<li>RGMII 中应用到源同步时钟，即数据与时钟信号是同步的。这要求在PCB设计中，要对时钟信号额外增加 1.5-2ns 的延迟以保证接收端的建立&#x2F;保持时间满足要求。在RGMII v2.0 规范中有定义MAC&#x2F;PHY内部延迟<br>（RGMII-ID），由此避免PCB设计中再要增加这个延迟。</li>
<li>RXCTL 和 TXCTL 为复用的传输控制信号。RXCTL 在时钟的上升沿代表 RXDV，在时钟的下降沿代表 RXER；TXCTL 在时钟的上升沿代表 TXEN，在时钟的下降沿代表 TXER</li>
<li>RGMII v1.3 采用 2.5V CMOS 电平，RGMII v2 采用 1.5V HSTL 电平。</li>
</ul>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618180416966.png" alt="image-20230618180416966"></p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>方向（MAC 端）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GTX_CLK</td>
<td>Output</td>
<td>发送数据参考时钟，由 MAC 提供<br />① 1000 Mbps 速率下，时钟频率为 125 MHz<br />② 100 Mbps 速率下，时钟频率为 25 MHz<br />③ 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>TXD[3:0]</td>
<td>Output</td>
<td>① 发送数据信号<br />② 上下沿都传输数据</td>
</tr>
<tr>
<td>TX_CTL</td>
<td>Output</td>
<td>① 上升沿发送数据使能信号<br />② 下降沿发送数据错误提示信号</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RX_CLK</td>
<td>Input</td>
<td>接收数据参考时钟，由 PHY 提供<br />① 1000 Mbps 速率下，时钟频率为 125 MHz<br />② 100 Mbps 速率下，时钟频率为 25 MHz<br />③ 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>RX_D[3:0]</td>
<td>Input</td>
<td>① 接收数据信号<br />② 上下沿都传输数据</td>
</tr>
<tr>
<td>RX_CTL</td>
<td>Input</td>
<td>① 接收数据使能信号<br />② 下降沿接收数据错误提示信号</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>COL</td>
<td>Input</td>
<td>① 载波侦测信号，不需要同步于参考时钟<br />② 只要有数据传输，CAS 就有效<br />③  CAS信号只有 PHY 在半双工模式下有效</td>
</tr>
<tr>
<td>CRS</td>
<td>Input</td>
<td>① 冲突检测信号，不需要同步于参考时钟<br />②  COL 信号只有 PHY 在半双工模式下有效</td>
</tr>
</tbody></table>
<h2 id="SGMII"><a href="#SGMII" class="headerlink" title="SGMII"></a>SGMII</h2><p>SGMII 发送和接收时钟频率均为 625MHz，采用 DDR 模式，因此数据速率为1.25Gbps，SGMII 相比于 GMII，功耗更低，采用 SerDes 接口后管脚数更少。SGMII 发送和接受数据各 1 对差分信号（LVDS），另外还有 1 对差分时钟，共 6 根线。对于 MAC&#x2F;PHY 中包括时钟恢复电路（CDR，Clock and Data Recovery circuitry）的系统，TXCLK 可以省略，SGMII 接口只需要 4 根线，相比于 GMII（24 根）和 RGMII（12 根）信号线大大减少！</p>
<p>TX&#x2F;RX 在数据发送端必须同时产生时钟，而接收端的时钟是可选的，因为可以通过 CDR 恢复时钟。在 10&#x2F;100Mbps 工作模式下，数据分别重复发送 100&#x2F;10 次，因此时钟一直是 625MHz</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618180949659.png" alt="image-20230618180949659"></p>
<p>大多数 MAC 芯片的 SGMII 接口都可以配置成 SerDes 接口（在物理上完全兼容，只需配置寄存器即可）。SerDes 直接外接光模块，而不需要 PHY 层芯片，此时时钟速率仍旧是 625 MHz。</p>
<p>不过此时跟 SGMII 接口不同，SGMII 接口速率被提高到 1.25 Gbps 是因为插入了控制信息，而 SerDes 端口速率被提高是因为进行了 8B&#x2F;10B 变换，本来 8B&#x2F;10B 变换是 PHY 芯片的工作，在 SerDes 接口中，因为外面不接 PHY 芯片，此时 8B&#x2F;10B 变换在 MAC 芯片中完成了。</p>
<p>8B&#x2F;10B 变换的主要作用是扰码，让信号中不出现过长的连 “0” 和连 “1” 情况，影响时钟信息的提取。</p>
<p>所以感觉是 MAC 芯片用加 2bits 控制信息的功能模块去完成了 8B&#x2F;10B 变换，这样 SerDes 信号就可以直接出去了。</p>
<p>SerDes 通道和 SerDes 接口是两个概念，SGMII 也是需要 SerDes通道（SERDES lane）的。</p>
<p>而 SGMII 需要插入 2bits 控制信号变成 10bits 是因为 SGMII 需要控制信号来实现 10&#x2F;100&#x2F;1000 Mbps 速率协商，而 SerDes 是固定速率（1000BASE-x）。</p>
<p>PHY 收到 MAC SGMII 的 10 bits 后，将控制信号去除后，将数据发送出去前还是会加扰码完成 8B&#x2F;10B 变换。</p>
<h2 id="XGMII"><a href="#XGMII" class="headerlink" title="XGMII"></a>XGMII</h2><p>XGMII 是用于 10G 以太网的 MAC 与 PHY 设备间通信的接口标准，它包括 32 bits 的数据通道（RXD&amp;TXD），两组 4 bits的控制通道（RXC&amp;TXC）和两组时钟（收&#x2F;发），时钟频率 156.25 MHz，工作在 DDR 模式。</p>
<p>XGMII 接口的连接示意图如下所示，注意 RXD&#x2F;TXD 信号上的 36 表示 32 bits 数据 + 4 bits 控制信号，其中每 8 bits 数据称为 1 个 Lane，共用 1 路控制信号。</p>
<p>10 Gbps &#x3D; 156.25 MHz * 32 bits * 2</p>
<p>XGMII 信号数目（74 根）较多，通常用于芯片内的连接，不适合作为芯片间通信的接口，因此协议定义 XGXS（XGMII eXtender Sublayer）子层以缩减信号数目，简化硬件设计。</p>
<p>XGXS 子层主要完成 8b&#x2F;10b 编码和不同 Lane 之间的去偏斜等功能。如图所示，在信号链的两端，MAC和PHY 都包括 XGXS 子层，XAUI 是 XGXS 之间通信的接口。</p>
<p>XAUI 接口包括 4 组发送差分对和 4 组接收差分对，共 16 根信号。每组差分对（Lane）的数据速率为 3.125 Gbps，因此总的数据速率为 4 *3.125 Gbps &#x3D; 12.5 Gbps，考虑到 8b&#x2F;10b 的效率为 80%，因此实际数据速率为12.5Gbps * 80%&#x3D; 10 Gbps</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618181543641.png" alt="image-20230618181543641"></p>
<h2 id="XFI-x2F-XFP"><a href="#XFI-x2F-XFP" class="headerlink" title="XFI&#x2F;XFP"></a>XFI&#x2F;XFP</h2><p>XFI 是10G 以太网 PMA（Physical Medium Attachment）和 PMD（Physical Medium Dependent）之间的接口标准，它只有两对差分线（收&#x2F;发），共4根线，如下图所示。XFI 接口速度达到10.3125<br>Gbps，采用64B&#x2F;66B编码，在 XAUI 与 XFI 之间使用到 SerDes 以减小信号数。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618181815189.png" alt="image-20230618181815189"></p>
<p>XFP（10 Gigabit Small Form Factor Pluggable）是指应用XFI接口的光模块，应用于10G以太网的光传输。XFP 光模块的尺寸略大于 SFP 和 SFP+ 光模块，三种光模块的详细对比见<a target="_blank" rel="noopener" href="http://www.differencebetween.info/difference-between-xfp-sfp-and-sfp-plus">链接</a>。</p>
<h1 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h1><p>常见的以太网接口类型有RJ45接口（电脑网口）、RJ11接口（电话线）、SC光纤接口等。其中RJ45接口是我们常见的网络设备接口，其采用差分传输方式，具有传输速率快、抗干扰、传输距离远等优点。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620233643610.png" alt="image-20230620233643610"></p>
<p>RJ45接口定义以及各引脚功能说明如下图所示，在以太网中只使用了1、2、3、6这四根线，其中1、2这组负责传输数据（TX+、TX-），而3、6这组负责接收数据（RX+、RX-），另外四根线是备用的。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620233731232.png" alt="image-20230620233731232"></p>
 
      <!-- reward -->
      
        <div id="reword-out" style="border-top-width: 20px;padding-top: 30px;">
            <div id="reward-btn" style="
                margin-bottom: 0px;
                margin-top: 0px;
                ">Donate
            </div>
        </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E7%BD%91/" rel="tag">以太网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BB%8B%E7%BB%8D/" rel="tag">以太网介绍</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/07/08/axi_quad_spi/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            axi_quad_spi
          
        </div>
      </a>
    
    
      <a href="/2023/07/08/office%E8%BD%AF%E4%BB%B6/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Office</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
        <li style="
            padding-bottom: 0px;
            width: 30px;
            padding-right: 5px;
        ">
        <img src="/images/favicon.ico">
      </li>
      <li>
        &copy;
        2023
        <!-- <i class="ri-heart-fill heart_icon"></i> Arlen -->
        , 
        Arlen
        .
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle">
    <style>
        .navbar-toggle {
            background-color: rgba(0,0,0,.05);
        }
    </style>
</button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer.png" alt="Welcome"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      <a class="nav-item-link" target="_blank" href="https://github.com/hjh0920">
        <i class="ri-github-fill"></i>
        <!-- <i class="ri-github-line"></i> -->
      </a>
    </li>
  </ul>
  <style>
    .navbar .nav .nav-item-link {
        display: block;
        padding: 1rem;
        color: #918888;
        text-decoration: none;
        cursor: pointer;
    }
  </style>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      <style>
        .sidebar {
          background-color: rgba(0,0,0,.1);
        }
      </style>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: ".tocbot",
    // Where to grab the headings to build the table of contents.
    contentSelector: ".article-entry",
    // Which headings to grab inside of the contentSelector element.
    headingSelector: "h1, h2, h3, h4, h5, h6",
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    // Smooth scrolling enabled.
    scrollSmooth: true,
    // If there is a fixed article scroll container, set to calculate titles' offset
    scrollContainer: "main",
    // Element to add the positionFixedClass to.
    positionFixedSelector: ".tocbot",
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: "is-position-fixed",
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: "auto",
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    // collapseDepth: "is-collapsed",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>