<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FC-AE-1553</title>
    <url>/2023/07/08/FC-AE-1553/</url>
    <content><![CDATA[<h2 id="MIL-STD-1553B总线协议"><a href="#MIL-STD-1553B总线协议" class="headerlink" title="MIL-STD-1553B总线协议"></a>MIL-STD-1553B总线协议</h2><h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><p>MIL-STD-1553B总线由BC（总线控制器），RT（远程终端），BM（总线监视器）以及总线自身四部分组成。一个MIL-STD-1553B总线网络中，有且只有一个总线控制器BC在工作，远程终端RT的个数不多于31，而总线监视器BM的数量则可根据需要设置，它并不参与总线通信。总线具备冗余备份能力，能增加MIL-STD-1553B总线网络信息传输的可靠性，当一条总线断开时，网络会自动切换到其他冗余的总线上，保证了消息的传递。</p>
<ul>
<li>BC主要管理和控制MIL-STD-1553B总线上消息的传输，网络中只有总线控制器才能发送指令字，它总共包括字控制器、消息控制器和帧控制器三个类型。</li>
<li>RT的工作主要是响应来自总线控制器的命令，并实施数据的传递。一个MIL-STD-1553B总线网络可以接入多个远程终端，不同的终端通过RT地址来进行区分。</li>
<li>BM主要监视与记录MIL-STD-1553B总线上传递消息的终端，它能够接收总线控制器的指令而工作，但不参与总线消息的传输。</li>
</ul>
<h3 id="字格式"><a href="#字格式" class="headerlink" title="字格式"></a>字格式</h3><p>MIL-STD-1553B总线上消息传输的最小单位为字，它包括命令字、数据字和状态字三种类型，这三种类型的字经过曼彻斯特编码调制组成一条条消息，每条消息由1~32个字组成。每一种类型的字格式都是唯一的，但三种类型的字数据结构是相同的。</p>
<p>每个字的字长为20比特（bit），其中，有效数据位为16比特（bit）。每个字最前面3比特是同步字头，标志一个新字的开始；第20位是奇偶校验位。可以用同步字段来将命令字和状态字与数据字区分开。</p>
<img alt="20230408161955722" src="/MD_IMG/FC-AE-1553.assets/image-20230408161955722.png"  />

<hr>
<p><strong>命令字</strong></p>
<ul>
<li><p>RT地址</p>
<p>即远程终端的地址，指示网络控制器发起的该命令字的目的地址。每个RT的地址是唯一存在的。由于该字段包含5比特，所以总线上一共可以有31个RT地址，当该字段全为1时，表示广播地址。由于总线监控器不具有与RT和BC通信的功能，所以它没有总线地址。</p>
</li>
<li><p>T&#x2F;R</p>
<p>用于指示接收该命令字的远程终端执行接收数据还是发送数据，该位为0，RT发送数据，反之则接收数据。</p>
</li>
<li><p>子地址&#x2F;模式</p>
<ul>
<li>当该字段的值被设为1-30时，它表示子地址，此时数据字计数&#x2F;模式码中的内容为数据字的计数。子地址用来表示需要交互的数据在内存中的位置。</li>
<li>当该字段被设为0或31时，它表示模式，此时数据字计数&#x2F;模式码字段中的内容代表模式码，该命令字是模式命令，传输方式属于模式命令传输。</li>
</ul>
</li>
<li><p>数据字计数&#x2F;模式码<br>功能取决于子地址&#x2F;模式字段。一是作为数据字计数使用，该字段的内容表示需要交换的数据字的数量；二是作为模式码使用，该字段的内容则用于区分不同类型的模式命令。</p>
</li>
</ul>
<hr>
<p><strong>状态字</strong></p>
<p>状态字包含5bit的RT地址和其他用于指示不同状态的状态位。此处的RT地址和命令字中的RT地址类似，不再累述。状态字段标识发出该状态字的RT的状态信息，包括服务请求、忙、消息错误等。除了消息错误位是必须使用的之外，其他所有状态位都是根据具体需求可以选择的。</p>
<hr>
<p><strong>数据字</strong></p>
<p>数据字除了同步字段和校验字段之外的16bit都用于存放需传送的数据。</p>
<h3 id="消息传输方式"><a href="#消息传输方式" class="headerlink" title="消息传输方式"></a>消息传输方式</h3><p>MIL-STD-1553B总线的消息传输格式总共有10种，这10种格式又分为非广播传输格式和广播传输格式两大类。</p>
<hr>
<p>常用的为非广播传输格式中的三种，即BCtoRT（总线控制器向远程终端发送信息）、RTto BC（远程终端向总线控制器发送信息）、RTtoRT（远程终端向远程终端发送信息）。</p>
<ol>
<li>BC to RT：总线控制器BC先发送一个接收命令字给其中一个远程终端RT，告诉RT准备接收数据，然后BC继续发送数据字，RT接收数据后返回一个状态字给BC，以说明数据的接收情况。</li>
<li>RT to BC：总线控制器BC先发送一个发送命令字给一个远程终端RT，告诉RT发送数据，RT收到发送命令字后返回一个状态字，并按照要求发送数据字给BC。</li>
<li>RT to RT：总线控制器BC发送一个接收命令字给一个远程终端RT1，让其接收数据。然后，该BC发送一个发送命令字给另一个远程终端RT2，让其发送数据给RT1。接收到发送命令字的RT2向BC返回一个状态字并按要求向RT1发送数据字，RT1接收到数据字后向BC返回一个状态字。</li>
</ol>
<img alt="20230408163601520" src="/MD_IMG/FC-AE-1553.assets/image-20230408163601520.png"  />

<hr>
<ol>
<li>BC to RTs：总线控制器BC向所有远程终端RT发送一个接收命令字，其后发送一连串数据字给所有的RT。RT收到数据后，不需要向BC发送状态字，只需要把状态字中的第15位设置为1即可。</li>
<li>RT to RTs：总线控制器BC发送一个接收命令字给各远程终端RTn，让其接收数据，然后发送一个发送命令字给远程终端RT3，让其向各终端RTn发送数据。RT3接收到命令后向BC发送一个状态字，并向各RTn发送指定的数据字。各个RTn收到数据后不需要向BC发送状态字，只需要把状态字中的第15位设置为1即可。</li>
</ol>
<img alt="20230408163616912" src="/MD_IMG/FC-AE-1553.assets/image-20230408163616912.png"  />

<h2 id="FC协议"><a href="#FC协议" class="headerlink" title="FC协议"></a>FC协议</h2><h3 id="FC协议栈"><a href="#FC协议栈" class="headerlink" title="FC协议栈"></a>FC协议栈</h3><p>类似OSI七层模型，光纤通道协议也分为五层模型。</p>
<ul>
<li>FC-0层定义的是物理接口的相关规范，其中包括物理特性、光学特性、电气特性、传输速率和其他与传输介质相关的接口特性以及发射机和接收机]。</li>
<li>FC-1层是传输协议层。主要描述8B&#x2F;10B的传输码和传输协议，其中包括串行编码和解码规则、传输和接收错误检测机制、端口操作状态以及特殊字符的检测机制[]。</li>
<li>FC-2层是信令协议层。它的主要内容有FC帧结构的定义、数据层定义和划分（包括帧、序列和交换）、N端口和F端口、三种拓扑类型、包括Class 1、Class<br>2、Class3、Class4和Class6的五种服务类别、分段重组、链路管理和控制、流量监控、检错与恢复等。</li>
<li>FC-3层是公共服务层。主要处理多个N端口上的公用业务，如多播、分段管理或查寻组等。</li>
<li>FC-4层是高层协议映射层。对于FC-AE-1553协议来说，就是在FC协议的FC-4层映射MIL-STD-1553B协议。</li>
</ul>
<img src="/MD_IMG/FC-AE-1553.assets/image-20230408164724712.png" alt="image-20230408164724712" style="zoom:50%;" />

<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>根据通信性能以及有没有交换机，光纤通道协议一共定义了三种基本拓扑结构：点到点、交换式结构和仲裁环，在不同的运用环境下，根据具体需求来使用不同的拓扑结构。</p>
<p>根据端口所处的拓扑结构不同，有不同的名称：在网络节点上的端口为N_Port（N端口）；在仲裁环内各个节点的端口为L_Port（L端口）；在交换机上的端口为F_Port（F端口）；在交换机上，并且用来连接两个交换机的端口为E_Port（E端口）；在交换机上，同时隶属于仲裁环的端口为FL_Port（FL端口）；最后，有一种全能端口叫做G_Port（G端口）。</p>
<hr>
<p><strong>点到点拓扑结构</strong><br>点到点的拓扑结构是这三种拓扑结构中最简单的一种模式，无须使用交换机，直接将网络上的两个端口（N端口）相连，实现它们之间的通信。其结构图如图2-6所示。在这种简单的结构下，可以实现两网络节点的高速全双工通信，传输带宽极高，但不具备可扩张性。</p>
<img alt="20230408165631578" src="/MD_IMG/FC-AE-1553.assets/image-20230408165631578.png"  />

<hr>
<p><strong>交换式拓扑结构</strong><br>交换式拓扑结构通过将接收方N端口的ID作为目的地址植入传输数据的帧头，经过一个交换机来达到向目的N端口发送数据。图2-7展示了多个N端口通过一个交换机互联的结构。交换式拓扑使用方便，可扩展性高，而且网络容量较大，但是交换机的开发成本较为昂贵。</p>
<img alt="20230408165644418" src="/MD_IMG/FC-AE-1553.assets/image-20230408165644418.png"  />

<hr>
<p><strong>仲裁环拓扑结构</strong><br>在没有交换机参与的情况下，仲裁环拓扑结构允许三个及其以上的L端口之间进行通信。在该结构里面，同一时刻最多只支持一组点到点的传输，而其他的L端口均处在某种等待状态下。</p>
<img src="/MD_IMG/FC-AE-1553.assets/image-20230408165822918.png" alt="image-20230408165822918" style="zoom: 67%;" />

<h3 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h3><p>根据不同的应用场合和传输环境，光纤通道定义了六种服务类型回来满足各种需求。</p>
<ul>
<li>第一类服务：专线连接服务。该服务用于建立专用链路，一旦建立，在规定的时间内该链路将会一直保持并会受到交换机的保护。通过该服务，可以实现两个N端口之间建立高带宽的专线数据通信，传输的信息序列将会被交换机保持原有的顺序从源端口发送到目的端口。如果交换机不存在了，该服务将变成一种特殊的点到点的链接。</li>
<li>第二类服务：多路复用服务。该服务通过交换机无需建立专门的链路，支持多路复用的功能，使多个端口间可以相互共享带宽。如果交换机不存在，这种服务也变成了一种特殊的点到点的连接。在进行传输的时候，发送机会按照给定的序列顺序来发送数据帧，但是交换机并不能保证数据序列按照原先的顺序抵达接收方。同时，该服务为有确认的服务，即接收方在接收以后要给发送方一个确认帧反馈是否接收正确。</li>
<li>第三类服务：数据报服务。该服务也是无链路的，同第二类服务类型一样，在没有交换机的时候也可以视为一种特殊的点到点连接。同时，该服务为无需确认的服务，接收N端口在接收到有效的数据时，无需反馈确认信息。在本服务下，有很高的发送效率，而就算目的N端口无法接收数据也无须发送busy或者reject帧给源N端口。</li>
<li>第四类服务：虚拟连接服务。在该类服务下，不会把所有的带宽像第一类服务一样用于一对端口通信，而是虚拟建立起一个N端口与多个N端口之间的数据链路。</li>
<li>第五类服务：在最新协议中已被废弃。</li>
<li>第六类服务：多播服务。在本服务下，允许一个N端口跟多个N端口专用链路，一旦建立成功，在规定的时间内，该链路被交换机保持和保护。在数据传输过程中，数据只能是从源N端口向目的N端口传输，各个目的N端口在接受完成以后都会向多播服务器反馈一个链路响应帧，服务器在把接收到的响应帧整理成一个帧再反馈给源N端口。这种服务必需要有交换机的参与。</li>
</ul>
<h3 id="帧-x2F-序列-x2F-交换"><a href="#帧-x2F-序列-x2F-交换" class="headerlink" title="帧&#x2F;序列&#x2F;交换"></a>帧&#x2F;序列&#x2F;交换</h3><p>FC-FS协议中规定光纤通道中传输三个级别的数据结构：交换、序列和帧。在传输的工程中，最基本的单位是帧；一个或者多个帧可以组成一个传输序列；而一个或者多个的传输序列构成了一次交换。它们三者的结构关系如图2-9所示。</p>
<img src="/MD_IMG/FC-AE-1553.assets/image-20230408170008519.png" alt="image-20230408170008519" style="zoom:50%;" />

<h3 id="FC帧格式"><a href="#FC帧格式" class="headerlink" title="FC帧格式"></a>FC帧格式</h3><p>帧作为传输中最基本的单位，光纤通道标准帧类型有三种：命令帧、数据帧和状态帧，它们拥有相同的结构，包括帧起始标记（SOF）、帧内容和帧结束标记（EOF），其标准的帧结构如图2-10所示。其中帧内容里面包含了帧头、数据区域和CRC校验。帧内容中的最大容量为2140Bytes，其中帧头包含了24Bytes，数据区最大容量为2112Bytes，CRC校验字包含了4Bytes。数据区域又分为了有效载荷和填充字节，有效载荷中包含了纯有效数据，填充字节是为了将最后的发送数据填充为32bit字所用的。</p>
<img alt="20230408172858523" src="/MD_IMG/FC-AE-1553.assets/image-20230408172858523.png"  />

<img src="/MD_IMG/FC-AE-1553.assets/image-20230408172933432.png" alt="image-20230408172933432" style="zoom: 50%;" />

<ul>
<li>R_CTL：包含了Routing和Information两个字段，其中Routing区域用于标识当前帧的类型。</li>
<li>Destination ID：当前帧应该传输到的目的端口的ID。</li>
<li>CS_CTL：配合F_CTL使用，用于表示当前帧在交换机内是否具有优先转发的级别。</li>
<li>Source ID：当前帧来源端口的ID。</li>
<li>Type：用于表示当前顶层映射的协议类型，FC-AE-1553协议此域值为0x48。</li>
<li>F_CTL：用于对帧的控制，里面包含了与序列交换相关的控制信息。</li>
<li>SEQ_ID：序列标识符，用于区分识别交换中的各个序列，每个序列拥有唯一的数值。</li>
<li>DF_CTL：用于对可选帧头的使用进行标识，告知接收方使用了何种可选帧头。</li>
<li>SEQ_CNT：用于序列计数，随着交换的进行，该值会一直递增，直到完成整个交换。</li>
<li>OX_ID：表示交换发起端口ID。</li>
<li>RX_ID：表示交换响应端口ID。</li>
<li>Parameter Field：参数域。</li>
</ul>
<h2 id="FC-AE-1553"><a href="#FC-AE-1553" class="headerlink" title="FC-AE-1553"></a>FC-AE-1553</h2><h3 id="网络构成"><a href="#网络构成" class="headerlink" title="网络构成"></a>网络构成</h3><p>FC-AE-1553的网络主要由网络控制器（Network Controller，NC）、网络终端（Network Terminal，NT）和光纤通道网络组成。当FC-AE-1553需要兼容MIL-STD-1553B总线时，网络中会增加FC-AE-1553协议桥、MIL-STD-1553B总线本身和其终端节点RT。FC-AE-1553的网络结构如图2-5所示。</p>
<img src="/MD_IMG/FC-AE-1553.assets/image-20230409105926572.png" alt="image-20230409105926572" style="zoom:60%;" />

<hr>
<p><strong>网络控制器（NC）</strong></p>
<p>网络控制器是FC-AE-1553网络中发出命令的节点。网络控制器在整个数据交互过程中起相当重要的作用，只有当网络控制器发出命令序列，才能发起一次数据交互，网络控制器也控制着网络中的所有数据传输过程。网络控制器的功能与MIL-STD-1553B中的总线控制器类似，不同的是在MIL-STD-1553B中只能有一个总线控制器存在，但在FC-AE-1553网络中可以存在多个网络控制器。</p>
<hr>
<p><strong>网络终端（NT）</strong></p>
<p>网络终端是接收网络控制器的命令并执行命令的一种终端节点，它一般是连接到FC网络上的传感器接口或其他子系统接口。网络终端的主要功能是按照网络控制器的命令完成相应的数据传送或接收。在FC-AE-1553网络中，网络控制器不再处于活跃期时可以被当成网络终端来使用，即该节点同时具有网络终端和网络控制器的功能。</p>
<hr>
<p><strong>协议桥设备</strong></p>
<p>协议桥是实现MIL-STD-1553B网络与FC-AE-1553网络的设备之间通信的设备。协议桥使得FC-AE-1553中的网络终端能与MIL-STD-1553B总线上的远程终端RT进行数据交互。它主要完成FC-AE-1553的三种帧格式和MIL-STD-1553B的三种字格式之间的相互转换问题。</p>
<h3 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h3><p>FC-AE-1553与MIL-STD-1553B相对应，定义了三种帧格式，分别为命令帧、状态帧和数据帧。</p>
<h4 id="命令帧"><a href="#命令帧" class="headerlink" title="命令帧"></a>命令帧</h4><p>每个FC-AE-1553交换都是由网络控制器发出的命令序列发起的。在NC发出的命令序列和NT-NT传输模式中发送NT发出的状态序列中可能存在FC-AE-1553的命令头。FC-AE-1553的命令帧头是在6个字的FC帧头的基础上，再扩展了6个字的FC-AE-1553的相关帧头组成了，其中扩展帧头相当于是前面6个字的数据载荷。</p>
<p>FC-AE-1553的命令帧可以携带数据也可以不携带数据，具体情况根据帧头的相关字段的设置决定。命令帧携带数据时，其数据载荷部分最大为2048个字节，如果需要传送的数据超过2048个字节则需要在命令帧后以数据帧的形式进行传送。</p>
<img alt="20230409110651051" src="/MD_IMG/FC-AE-1553.assets/image-20230409110651051.png"  />

<ul>
<li><p><strong>R-CTL（路由控制）字段</strong><br>路由控制字段和TYPE字段一样，被用于归类帧。该字段由两部分组成：一是路由比特子字段，二是信息类比特子字段。</p>
<ul>
<li>路由比特为0时代表设备数据，为2时代表扩展链路服务，为8时代表基本链路服务。</li>
<li>信息类比特为6时代表命令帧，为7时代表状态帧，为1时代表数据帧。</li>
</ul>
</li>
<li><p><strong>D-ID（目的标识符）字段</strong><br>D-ID字段作为目的标识符，其携带的信息指示了目的端口即接收端口的网络终端地址、多播地址以及被熟知的地址，如广播地址0XFFFFFF等。</p>
</li>
<li><p><strong>CS_CTL（类型特殊控制）字段</strong></p>
<p>类型特殊控制字段指示了帧的优先级，帧的优先级是一个7bit的值。优先级的值可以在0到127之间，其中127级最高。当优先级使能被设为0时，不使用优先级，相当于帧的优先级为0级，即CS_CTL的值为0。</p>
</li>
<li><p><strong>SID（源标识符）字段</strong><br>源标识符是发出该命令帧的源端口的地址标识，此处就是指发出该命令帧的NC的地址，此地址是唯一存在的。</p>
</li>
<li><p><strong>TYPE（数据结构类型）字段</strong><br>该字段是用来区分不同数据结构类型的。对于所有传输中的FC-AE-1553序列来说，此字段的值应该为十六进制的48。</p>
</li>
<li><p><strong>参数</strong><br>此字段对于所有FC-AE-1553序列来说是被用来指定相对偏移量的。在命令序列和状态序列中，此字段被设为十六进制的0.</p>
</li>
<li><p><strong>NT突发请求</strong><br>该字段只在两种传输模式中被使用：一种是NC-NT模式，在该模式中，此字段在NC发出的命令序列中被设置；另一种是NT-NT模式，此时该字段在发送NT向接收NT发出的命令序列中被设置。NT突发请求字段和延迟NT突发请求字段结合使用，它们不能同时为1，但可以同时为0.当NT突发请求字段为1时，延迟NT突发请求字段须被置0，此时命令序列中不能携带数据，并且数据序列的传输必须等到NT或接收NT传回NT包含其可接收的数据大小信息的状态序列后才能进行。</p>
</li>
<li><p><strong>延迟NT突发请求</strong><br>与NT突发请求相对应，该字段也在NC-NT模式中NC发出的命令序列和NT-NT模式中发送NT发出的命令序列中被设置。当延迟NT突发请求字段为1时，命令序列中可以携带小于2048字节的数据，并且随后可接着发送一个数据序列，但后续的数据序列都需要等待相应的状态响应被接收后才能继续发送。</p>
</li>
<li><p><strong>接收RDMA和发送RDMA</strong></p>
<p>接收RDMA或发送RDMA字段的设置和子地址字段以及其他子地址字段的意义解读相关.</p>
<ul>
<li>在NC-NT和NT-NC传输模式中，如果接收RDMA或发送RDMA字段的值被设为1，则子地址字段分别指示NT和NC用来存放接收到或需要发送的数据帧的内存起始地址。</li>
<li>在NT-NT传输模式中，网络控制器发出的命令序列中接收RDMA或发送RDMA字段为1表示其他子地址字段指示的是接收&#x2F;发送NT的内存起始地址，在发送NT发出的命令序列中接收RDMA被置为1则表示该命令序列中的子地址字段指示的是接收NT接收数据帧的内存起始地址。</li>
<li>在所有的传输模式中，如果接收RDMA或发送为0，子地址字段无意义。</li>
</ul>
</li>
<li><p><strong>状态抑制</strong><br>该字段的设置情况与交互完成后NT是否向NC返回状态响应相关。</p>
<ul>
<li>当在NC发出的命令序列中，状态抑制位为1，则表示状态抑制有效，NT在数据交互完成后无需对NC返回状态响应。</li>
<li>当状态抑制位为0时，状态抑制无效，NT在最后需向NC发出状态序列。</li>
<li>在NT-NT模式中，网络控制器发出的命令序列和发送NT发出的命令序列对该字段的设置应该一致。</li>
</ul>
</li>
<li><p><strong>NT-NT传输标志</strong><br>此字段指示传输模式是否是NT-NT模式，当该位为1时表示传输模式为NT-NT传输模式，相反为其他传输模式。在NT-NT传输模式中的发送NT发出的命令序列和网络控制器发出的命令序列中，该字段都应该为1.</p>
</li>
<li><p><strong>T&#x2F;R</strong>*<br>此字段用来指示数据传输方向。</p>
<ul>
<li>为1时表示接受到该命令序列的NT执行发送数据命令</li>
<li>为0时表示接受到该命令序列的NT执行接受数据命令</li>
</ul>
</li>
<li><p><strong>NT-NT模式的NC监控</strong><br>该字段只在NT-NT或NT-多NT的传输模式中有效。该位置0，NC不对数据交互进行监控，置1，则发送NT在向接收NT发送数据序列的同时也需向NC发送相同的数据序列。</p>
</li>
<li><p><strong>多播</strong><br>顾名思义，多播字段指示的是数据交互是否为多播，当该字段为0时，目的标识符字段指示的是目的RT的地址，为1时，目的标识符字段指示的是多播地址。</p>
</li>
<li><p><strong>子地址&#x2F;模式</strong><br>该字段与数据大小&#x2F;模式码字段相关联。</p>
<ul>
<li>当该字段不为全0或全1时，此字段指示子地址，子地址在不同模式下的意义不同，此时数据大小&#x2F;模式码字段指示的是数据大小。</li>
<li>当该字段为全1或全0时，该字段表示模式，数据大小&#x2F;模式码字段指示的是模式码，模式码指示不同的模式码命令。</li>
</ul>
</li>
</ul>
<h4 id="状态帧"><a href="#状态帧" class="headerlink" title="状态帧"></a>状态帧</h4><p>FC-AE-1553状态帧在标准光纤通道帧头的基础上，扩展了两个字的设备头。如果被传输，状态序列始终是NT发送的第一个序列，并且其中可能携带数据信息。FC-AE-1553状态帧帧头如图2-7所示。</p>
<p>由图2-7可知，状态帧帧头的前6个字和命令帧帧头相同，其意义也相同。字6和字7是扩展的设备头。</p>
<ul>
<li>字6表示发起该状态序列的网络终端的状态信息。</li>
<li>字7有两种解读：<ul>
<li>当该状态序列是对命令序列或数据序列做出的响应，且该NT处于“闲”状态，要求进行突发大小请求响应时，字7代表的是网络终端接下来可以接收的数据序列的最大字节数；</li>
<li>当该状态序列是在NT-NT模式中的发送NT发出并传送给NC的状态序列时，字7表示接收NT的状态信息。</li>
</ul>
</li>
</ul>
<img alt="20230409111751716" src="/MD_IMG/FC-AE-1553.assets/image-20230409111751716.png"  />

<ul>
<li><p><strong>MIL-STD-1553RT无响应</strong><br>该字段只有在FC-AE-1553网络桥接有MIL-STD-1553B总线时有效。当NT向RT发送数据后，RT未在规定时间内对NT作出相应响应，则BC向网络控制器发出的状态帧中，此字段将被置1，由NC要求NT不再对该RT发送任何数据。<br>相反，若RT有反应，则该字段被置为0.当FC-AE-1553网络不兼容MIL-STD-1553B总线时，该字段始终被置0.</p>
</li>
<li><p><strong>MIL-STD-1553格式错误</strong><br>同MIL-STD-1553RT无响应字段类似，在FC-AE-1553网络不兼容MIL-STD-1553B总线时，该字段始终被置0.只有在FC-AE-1553网络桥接有MIL-STD-1553B总线时此字段才有效。若该字段为1表示虽然RT对NT传送的数据作出相应反应但反应不符合协议要求，此时NT仍不能再向该RT发送数据。</p>
</li>
<li><p><strong>Burst Size Acknowledge</strong></p>
<p>该字段是对NC发出的命令序列中的NT突发请求和延迟NT突发请求字段的响应。如果忙字段被置为0，此字段置1，则该状态帧头的字7表示下一个可接收的数据的最大字节数。</p>
</li>
<li><p><strong>端口登录要求</strong><br>由于本文中FC-AE-1553协议采用隐式登录，所有登录参数都在软件中设置，所以该位始终设置为0，表示该位不起作用。</p>
</li>
<li><p><strong>消息错误</strong><br>此字段用于表示消息是否错误。</p>
</li>
<li><p><strong>服务请求</strong><br>服务请求位指示NC是否需要服务请求，如果被置1，则NC必须执行定义好的某种特定操作。</p>
</li>
<li><p><strong>广播命令接收</strong><br>此字段用于表示接受到的由总线控制器发出的交换命令是否为广播交换。</p>
</li>
<li><p><strong>忙</strong><br>该字段用于指示NT是否在进行其他的数据交互，是否能执行NC所发出的命令。只有当NT有没空闲执行命令时该位为1，其他情况都被置为0.</p>
</li>
<li><p><strong>子系统标志</strong><br>子系统标志字段指示子系统是否能正常工作。只有当子系统出现故障时，该位被置1，其他情况都被置为0.</p>
</li>
<li><p><strong>动态网络控制</strong><br>因为一个FC-AE-1553网络节点即可做NC也可做NT，动态网络控制位就是用于NT和NC的切换中的。此字段是在NT接受到NC发出的网络控制的模式命令后返回的状态响应，如果该位被置1，表示NT接受模式命令，开始执行NC的功能。其他情况该字段为0.</p>
</li>
<li><p><strong>终端标志</strong><br>如果网络终端NT出现故障，该位被置1，其他情况为0。</p>
</li>
</ul>
<h4 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h4><p>FC-AE-1553的数据帧的帧头只有6个字，与命令帧和状态帧相比，没有扩展帧头的部分。数据帧的帧头格式与光纤通道的帧头格式相同，如图2-8所示。数据帧帧头的各个字段意义与命令帧头的前6个字的意义相同。</p>
<img alt="20230409111700661" src="/MD_IMG/FC-AE-1553.assets/image-20230409111700661.png"  />

<h3 id="Information-Units"><a href="#Information-Units" class="headerlink" title="Information Units"></a>Information Units</h3><p>信息单元指FC-AE-1553网络中一次交换NC或NT发送的一个序列。对于不同的交换模式下，FC-AE-1553网络上的不同节点设备所使用的信息单元也有差别。根据协议中的规定，可将信息单元划分为NC系列和NT系列。FC-AE-1553协议定义了NC1-NC7七种NC序列以及NT1-NT7七种NT序列。不同类型的数据单元适用与不同的应用环境，并且有着不同的作用。</p>
<p>若在命令序列或状态序列后有数据序列，则在命令或状态序列中的字节数必须为4的倍数。如果传输多个数据序列，则除去最后一个序列外，所有数据序列的字节数必须是4的倍数。</p>
<h4 id="NC1"><a href="#NC1" class="headerlink" title="NC1"></a>NC1</h4><p>NC1：使用NC1信息单元的情况如下：</p>
<ul>
<li>NC-to-NT写模式交换中的命令序列，序列中包含最多2048字节数据并将状态抑制位置为0，序列后不能跟随数据序列。</li>
<li>NC-to-NT写模式交换中的命令序列，不包含数据字节，NT突发位为1且延迟NT突发位为0。</li>
<li>NT-to-NC读模式及NT-to-NT（s）交换中的交换发起命令，由NC发送。</li>
<li>NT-to-NT第三者交换模式下由发送NT发送的命令序列，NT突发位为1且延迟NT突发位为0。</li>
</ul>
<img alt="20230409141730650" src="/MD_IMG/FC-AE-1553.assets/image-20230409141730650.png"  />

<h4 id="NC2"><a href="#NC2" class="headerlink" title="NC2"></a>NC2</h4><p>NC2：使用NC2序列的情况如下：</p>
<ul>
<li>NC-to-NT写模式交换中的命令序列，由帧头及最多2048字节数据组成，序列后由一串数据序列跟随。</li>
<li>由NC发送的不包含数据的命令序列，NT突发位为1且延迟NT突发位为0。</li>
<li>NT-to-NT第三方传输模式中发送NT发送的命令序列，用来发起与接收NT间的数据通信。</li>
<li>NT-to-NT模式中由发送NT发送的不包含数据的NC命令序列。</li>
</ul>
<img alt="20230409141852551" src="/MD_IMG/FC-AE-1553.assets/image-20230409141852551.png"  />

<h4 id="NC3-4"><a href="#NC3-4" class="headerlink" title="NC3-4"></a>NC3-4</h4><p>NC3、NC5、NC6、NC7：均为数据序列。</p>
<p>NC4：使用NC4的情况如下</p>
<ul>
<li>NC-to-NTs交换模式下的命令序列，状态抑制位须置为1，序列中包含FC-AE-1553命令帧帧头和命令帧内最多2048字节的数据，序列后不允许有数据序列跟随。</li>
<li>在NC发起NT-to-NT第三者传输模式交换或者NT-to-NTs传输模式时使用，抑制状态设为1。</li>
<li>在NT被临时授权执行NC功能时使用，如NT-to-NT交换模式及NT-to-NTs交换模式下的发送NT，抑制状态置1。</li>
<li>在除广播模式以外的方式代码中使用的NC命令序列，序列中可带数据也可不带数据，抑制状态位置1。</li>
</ul>
<img alt="20230409142009812" src="/MD_IMG/FC-AE-1553.assets/image-20230409142009812.png"  />

<h4 id="NC5-7"><a href="#NC5-7" class="headerlink" title="NC5-7"></a>NC5-7</h4><img alt="20230409142048506" src="/MD_IMG/FC-AE-1553.assets/image-20230409142048506.png"  />

<h4 id="NT1-7"><a href="#NT1-7" class="headerlink" title="NT1-7"></a>NT1-7</h4><ul>
<li><p>NT1：使用状态序列NT1的情况如下：</p>
<ul>
<li><p>NC-to-NT写模式交换中，NT用来响应收到的NC命令的状态序列，序列只包含状态帧帧头，不携带任何数据载荷。</p>
</li>
<li><p>NT-to-NC读模式交换中NT端用来响应NC的状态序列，序列内可携带最多2048字节数据传输给NC，其后不允许有NT系列数据帧跟随。</p>
</li>
<li><p>NT-to-NT第三者传输模式情况下，接收NT用来响应发送NT的状态序列，序列中只由FC-AE-1553状态帧头组成。</p>
</li>
<li><p>NT-to-NT第三者传输模式情况下，发送NT用来响应NC的状态序列，序列中只由FC-AE-1553状态帧头组成</p>
</li>
<li><p>NT-to-NTs交换模式中收到发送NT发送的命令序列的NITs用来响应的状态序列，序列中不携带任何数据字节。</p>
</li>
</ul>
</li>
<li><p>NT2：使用情况如下：<br>NT-to-NC读模式交换中，NT用来响应NC的第一个序列，可包含最多2048字节数据，其后可跟随NT系列的数据序列向NC传输数据。</p>
</li>
<li><p>NT3：使用情况如下：<br>NT数据序列的最后一个序列，其后不可再有数据序列传输，NT-to-NC写模式数据传输中最后一个数据序列使用NT3。</p>
</li>
<li><p>NT4：保留</p>
</li>
<li><p>NT5：使用NT5的情况如下：<br>一次交换中只有一个序列组成时NT端可用NT5序列。</p>
</li>
<li><p>NT6：使用情况如下：<br>不携带数据字节，用来响应NC或由NC授权的发送NT发送的命令序列。</p>
</li>
<li><p>NT7：使用情况如下：<br>作为NT-to-NC读模式交换中除最后一个数据序列外的任意位置的数据序列使用。</p>
</li>
</ul>
<img alt="20230409142239534" src="/MD_IMG/FC-AE-1553.assets/image-20230409142239534.png"  />





<h3 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h3><ul>
<li>在所有情况下，NT在接收到它确定为无效的任何命令序列、数据序列或状态序列后，不回复状态序列。</li>
<li>如果NC或者发送NT检测到交换无效或超时，可以停止发送以终止交换，并忽略从NT接收到的所有数据和状态，此外，NC也可以调用ABTS-LS基本链接服务</li>
<li>如果NT（非发送NT）检测到交换无效或超时，NT不回复任何状态序列，并终止交换。</li>
</ul>
<p>与MIL-STD-1553B相对应，FC-AE-1553总线协议也规定了数据的十种传输模式，分别是：</p>
<ol>
<li>网络控制器到网络终端（NC-NT）</li>
<li>网络终端到网络控制器（NT-NC）</li>
<li>网络终端到网络终端（NT-NT）</li>
<li>无数据字的模式命令传输</li>
<li>带数据字的模式命令传输，命令网络终端发送数据</li>
<li>带数据字的模式命令传输，命令网络终端接收数据</li>
<li>网络控制器到多个网络终端的广播或多播模式（NC-NTs）</li>
<li>网络终端到多个网络终端（NT-NTS）</li>
<li>发送到多个网络终端的没有数据字的模式命令</li>
<li>发送到多个网络终端的带有数据字的模式命令传输，命令接收数据</li>
</ol>
<img alt="20230409114202440" src="/MD_IMG/FC-AE-1553.assets/image-20230409114202440.png"  />

<p>下面选择几种常见的模式进行介绍。</p>
<h4 id="1-NC-NT"><a href="#1-NC-NT" class="headerlink" title="1. NC-NT"></a>1. NC-NT</h4><ul>
<li><p><strong>NT突发请求&#x3D;0，延迟NT突发请求&#x3D;0</strong></p>
<p>在这种传输模式中，NC首先发送一个命令序列用来发起此次数据交互。该命令序列中可能携带数据信息，最多可携带2048个字节的数据。根据其后是否跟随数据序列以及状态抑制位的设定，NC发出的命令序列可能是以下三种信息单元：NC1，不跟随数据序列，且状态抑制位置0；NC2，跟随数据序列；NC4，不跟随数据序列，且状态抑制位置1。</p>
<p>若需要发送的数据信息大于2048个字节，则NC还需向NT发送一定的数据序列，此处NC发出的信息单元可能是NC6（不是最后一个数据序列）、NC3（最后一个数据序列且状态抑制位置0）或NC5（最后一个数据序列且状态抑制位置1）。数据发送完成后，NT根据状态抑制位的设置选择是否向NC发出状态序列。</p>
<img alt="20230409154745106" src="/MD_IMG/FC-AE-1553.assets/image-20230409154745106.png"  />

<ul>
<li>NT应在NT_C&#x2F;S_TOV时间内向NC发送一个状态序列(NT1)并终止交换。</li>
<li>命令序列结束与第一个数据序列开始之间的最长时间，以及数据序列之间的最长时间，为C&#x2F;S_D_TX_TOV。</li>
</ul>
</li>
<li><p><strong>NT突发请求&#x3D;1，延迟NT突发请求&#x3D;0</strong></p>
<p>NC依然首先发出一个命令序列来开始此次数据交互，该命令序列属于NC1信息单元。NT收到命令序列后向NC回复信息单元为NT6的携带可接收数据字节数的状态序列。此后，NC开始发送数据序列，这些数据序列可能的信息单元是：NC3（不为最后一个数据序列，或最后一个数据序列但状态抑制位置0）；NC5（最后一个数据序列且状态抑制位置1）。最后NT根据状态抑制位的设置决定是否回复状态序列。</p>
<img alt="20230409155847398" src="/MD_IMG/FC-AE-1553.assets/image-20230409155847398.png"  />
</li>
<li><p>NT 突发请求&#x3D;0，延迟NT突发请求&#x3D;1</p>
<p>在这种传输模式中，NC在发出命令序列后，无需等待NT回复状态序列，在一定时间间隔后可随后向NT发送数据序列，但除第一个数据序列之外，后续需要发送的数据序列都需要根据NT回复的状态序列中指示的可接受数据字节数来设置数据大小。各中序列的信息单元与当NT突发请求为1时的情况相同。</p>
<img alt="20230409160855594" src="/MD_IMG/FC-AE-1553.assets/image-20230409160855594.png"  /></li>
</ul>
<h4 id="2-NT-NC"><a href="#2-NT-NC" class="headerlink" title="2. NT-NC"></a>2. NT-NC</h4><p>在这种传输模式中，NC发送一个命令序列要求NT向NC传输数据。NT接收到命令序列后在规定时间间隔内向NC回应一个状态序列，此状态序列可能的信息单元为：NT1（不携带数据）；NT2（携带数据信息）。如果需要传送的数据大小大于状态序列中携带的数据字节数，则NT还会向NC发送信息单元为NT3的数据序列，直到数据发送完成。</p>
<img alt="20230409160942745" src="/MD_IMG/FC-AE-1553.assets/image-20230409160942745.png"  />

<h4 id="3-NT-NT"><a href="#3-NT-NT" class="headerlink" title="3. NT-NT"></a>3. NT-NT</h4><p>和NC-NT传输模式一样，NT-NT传输模式也和NT突发请求和延迟NT突发请求字段相关。此外，由于FC-AE-1553的网络节点即可以作为NC使用又可以作为NT使用，所以在NT-NT模式中向发送NT发出命令序列的NC可以当作接收NT使用。下面只介绍NC作为接收NT使用的情况。</p>
<hr>
<ul>
<li><p>NC作为接收NT使用时，且NT突发请求置1，延迟NT突发请求置0</p>
<p>如图2-13所示，NC首先作为网络控制器向发送NT发出一个发送命令序列，此后NC就作为接收NT使用。发送NT向接收NT发出一个接收命令序列，该命令序列不携带数据，接收NT根据自己的状态和可接收的数据大小返回状态序列。发送NT开始向接收NT发送数据，接收NT再返回状态，以此类推，直到最后一个数据发送完成。数据发送完成后接收NT根据状态抑制位的设置决定是否向发送NT返回状态。最后接收NT又作为NC使用，发送NT根据状态抑制位的设置决定是否向NC返回状态。</p>
</li>
</ul>
<img alt="20230409161048503" src="/MD_IMG/FC-AE-1553.assets/image-20230409161048503.png"  />

<hr>
<ul>
<li><p>NC作为接收NT使用，且延迟NT突发请求置1，NT突发请求置0</p>
<p>如图2-14所示，这种情况和当NT突发请求置1的情况类似，只是此时的接收命令序列中可能携带数据，如果数据并没有在命令序列中全部发送，则发送NT直接在接收命令之后直接发出第一个数据序列而无需等到接收NT返回状态序列后再发送，其后的传输过程都与第二种情况一样。</p>
</li>
</ul>
<img alt="20230409161132989" src="/MD_IMG/FC-AE-1553.assets/image-20230409161132989.png"  />

<hr>
<img alt="20230409161259232" src="/MD_IMG/FC-AE-1553.assets/image-20230409161259232.png"  />

<img alt="20230409161316065" src="/MD_IMG/FC-AE-1553.assets/image-20230409161316065.png"  />

<img alt="20230409161338692" src="/MD_IMG/FC-AE-1553.assets/image-20230409161338692.png"  />

<h4 id="4-无数据字的模式命令"><a href="#4-无数据字的模式命令" class="headerlink" title="4. 无数据字的模式命令"></a>4. 无数据字的模式命令</h4><p>这种传输模式比较简单，在这种模式下，NC发出的是一个模式命令，命令序列中的模式码字段规定了具体的模式命令。NT收到该模式命令后执行该命令并根据状态抑制位的设置决定是否向NC返回状态序列。</p>
<img alt="20230409161404843" src="/MD_IMG/FC-AE-1553.assets/image-20230409161404843.png"  />

<h4 id="5-带数据字的发送模式命令"><a href="#5-带数据字的发送模式命令" class="headerlink" title="5. 带数据字的发送模式命令"></a>5. 带数据字的发送模式命令</h4><p>NC在这种传输模式下发出一个模式命令，该模式命令除了模式码字段中规定的具体命令之外还要求NT返回数据，所以无论状态抑制位如何设置，NT在收到NC发出的模式命令后都要向NC发出一个写带数据字的状态序列。</p>
<img alt="20230409161415399" src="/MD_IMG/FC-AE-1553.assets/image-20230409161415399.png"  />

<h4 id="6-带数据字的接收模式命令"><a href="#6-带数据字的接收模式命令" class="headerlink" title="6. 带数据字的接收模式命令"></a>6. 带数据字的接收模式命令</h4><p>与数据发送的模式命令相似，此时模式命令不仅要求NT执行相关的命令请求，还要求NT接收一定的数据字，这些数据字被携带与命令序列中，最后NT根据状态抑制位的设置决定是否向NC返回状态序列。</p>
<img alt="20230409161605821" src="/MD_IMG/FC-AE-1553.assets/image-20230409161605821.png"  />

<h4 id="7-NC-NTs"><a href="#7-NC-NTs" class="headerlink" title="7. NC-NTs"></a>7. NC-NTs</h4><img alt="20230409213959940" src="/MD_IMG/FC-AE-1553.assets/image-20230409213959940.png"  />

<h4 id="8-NT-NTs"><a href="#8-NT-NTs" class="headerlink" title="8. NT-NTs"></a>8. NT-NTs</h4><img alt="20230409214017097" src="/MD_IMG/FC-AE-1553.assets/image-20230409214017097.png"  />

<h4 id="9-无数据字的多NT模式命令"><a href="#9-无数据字的多NT模式命令" class="headerlink" title="9. 无数据字的多NT模式命令"></a>9. 无数据字的多NT模式命令</h4><img alt="20230409214105000" src="/MD_IMG/FC-AE-1553.assets/image-20230409214105000-16810476661691-16810476663083.png"  />

<h4 id="10-带数据字的多NT接收模式命令"><a href="#10-带数据字的多NT接收模式命令" class="headerlink" title="10. 带数据字的多NT接收模式命令"></a>10. 带数据字的多NT接收模式命令</h4><img alt="20230409214128344" src="/MD_IMG/FC-AE-1553.assets/image-20230409214128344.png"  />

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><img alt="20230409215732363" src="/MD_IMG/FC-AE-1553.assets/image-20230409215732363.png"  />



<h2 id="MIL-STD-1553B-与FC-AE-1553比较"><a href="#MIL-STD-1553B-与FC-AE-1553比较" class="headerlink" title="MIL-STD-1553B 与FC-AE-1553比较"></a>MIL-STD-1553B 与FC-AE-1553比较</h2><table>
<thead>
<tr>
<th align="center">项目</th>
<th align="center">MIL-STD-1553B</th>
<th align="center">FC-AE-1553</th>
</tr>
</thead>
<tbody><tr>
<td align="center">术语</td>
<td align="center">Bus Controller(BC)</td>
<td align="center">Network Controler(NC)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Remote Terminal (RT)</td>
<td align="center">Network Terminal(NT)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">RT Address</td>
<td align="center">Network Terminal Address</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">RT Subaddress</td>
<td align="center">NT Subaddress(NT_SA)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">MIL-STD-1553 Message</td>
<td align="center">FC-AE-1553 Exchange</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Command Word</td>
<td align="center">Command Sequence</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Status Word</td>
<td align="center">Status Sequence</td>
</tr>
<tr>
<td align="center">位宽</td>
<td align="center">RT Address (5 bits)</td>
<td align="center">NT Address(D_ID&#x2F;S_ID)(24 bits)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Subaddress (5 bits)</td>
<td align="center">NT Subaddress(NT_SA)(32 bits)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Word Count&#x2F;Mode Code (5 bits)</td>
<td align="center">Byte Count&#x2F;Mode Code(32 bits)</td>
</tr>
<tr>
<td align="center">拓扑结构</td>
<td align="center">总线型</td>
<td align="center">点对点、仲裁环路、交换</td>
</tr>
<tr>
<td align="center">允许的BC&#x2F;NC个数</td>
<td align="center">有且仅有1个</td>
<td align="center">有1个或多个</td>
</tr>
<tr>
<td align="center">允许的RT&#x2F;NT个数</td>
<td align="center">不多余2^5^ 个</td>
<td align="center">不多余2^24^ 个</td>
</tr>
<tr>
<td align="center">允许的子地址数</td>
<td align="center">小于2^5^ 个</td>
<td align="center">小于2^32^ 个</td>
</tr>
<tr>
<td align="center">消息字计数</td>
<td align="center">小于2^5^ 个</td>
<td align="center">小于2^32^ 个</td>
</tr>
<tr>
<td align="center">字宽度</td>
<td align="center">16bit</td>
<td align="center">32bit</td>
</tr>
<tr>
<td align="center">传输编码方式</td>
<td align="center">曼切斯特码</td>
<td align="center">8b&#x2F;10b编码</td>
</tr>
<tr>
<td align="center">传输介质</td>
<td align="center">双绞屏蔽电缆</td>
<td align="center">光纤</td>
</tr>
<tr>
<td align="center">传输速率</td>
<td align="center">1Mb&#x2F;s</td>
<td align="center">大于1Gb&#x2F;s</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>FC-AE-1553</tag>
      </tags>
  </entry>
  <entry>
    <title>AMBA 总线架构和协议</title>
    <url>/2023/07/08/AMBA%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="1-了解AMBA-总线架构和协议"><a href="#1-了解AMBA-总线架构和协议" class="headerlink" title="1. 了解AMBA 总线架构和协议"></a>1. 了解AMBA 总线架构和协议</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>高级微控制器总线体系结构（英语：Advanced Microcontroller Bus Architecture, AMBA）是用于连接和管理片上系统（SoC）设计中功能块的开放标准片上互连规范。从本质上说，AMBA 协议定义功能块如何互相进行通信。</p>
<img alt="20220611145550312" src="/MD_IMG/AMBA总线.assets/image-20220611145550312.png"  />

<p>现在，AMBA广泛用在各种ASIC和SoC部件中，包括在IoT子系统、智能电话和联网SoC等设备中使用的应用程序处理器，使用AMBA 有许多优势：</p>
<ul>
<li><p>AMBA可实现有效的IP重用，IP重用在降低SoC开发成本和缩短开发时间方面发挥着至关重要的作用。AMBA规范提供了可实现IP重用的接口标准。正因为如此，数以千计的SoC和IP产品都在使用AMBA接口；</p>
</li>
<li><p>AMBA还能够灵活地使用多种SoC，IP重用需要一个通用标准，同时支持具有不同能耗、性能和区域要求的多种SoC，Arm 还可提供一系列针对不同要求进行优化的接口规范；</p>
</li>
<li><p>标准接口规范（如AMBA）可使来自不同设计团队或供应商的IP组件之间互相兼容，</p>
</li>
<li><p>AMBA得到很好的支持，它在整个半导体行业中得到广泛的实施和支持，其中包括来自第三方IP产品和工具的支持，包括AMBA在内的各种总线接口标准的差别，体现在它们能够实现的性能上。</p>
<p><strong>总线接口性能</strong>有两个主要特性，第一个是<strong>带宽</strong>（带宽是指通过接口驱动数据所能达到的速率）。在同步系统中，最大带宽受时钟速度与数据总线宽度之乘积的限制；第二个重要特性是<strong>延迟</strong>，这是事务启动与完成之间的延迟，但在基于突发事务的系统中，延迟数字通常指的是完成第一次传输而不是突发事务，具体取决于系统的重要性，接口的效率将取决于它以零延迟获得最大带宽的程度。</p>
</li>
</ul>
<hr>
<h3 id="1-2-AMBA-发展历程"><a href="#1-2-AMBA-发展历程" class="headerlink" title="1.2 AMBA 发展历程"></a>1.2 AMBA 发展历程</h3><p>1996年，Arm 引入AMBA，最初的AMBA总线是高级系统总线（<strong>ASB</strong>）和高级外设总线（<strong>APB</strong>），<strong>APB 是为低带宽控制访问而设计的。</strong>例如，在系统外设上注册接口，此总线具有简单的地址和数据阶段，信号列表的复杂程度很低；</p>
<p>1999年，推出AMBA 2，Arm 添加了AMBA高性能总线（<strong>AHB</strong>），这是一个单边时钟协议，AHB中的一个简单事务，由一个地址阶段和一个后续数据阶段组成，这与APB 协议相似，对目标设备的访问通过MUX来控制，从而<strong>允许总线一次访问一个总线主接口</strong>，而且，<strong>与APB相比，AHB具有更大的总线带宽</strong>（64&#x2F;128位）；</p>
<p>2003年，推出AMBA 3，其中包括高级跟踪总线（<strong>ATB</strong>），这是Coresight片上调试和跟踪解决方案的一部分，<strong>AHB-Lite</strong>是AHB 的子集，该子集可简化具有单个主接口的总线的设计，<strong>AXI</strong>是在AMBA 3规范中定义的第三代AMBA接口，它的目标是<strong>实现高性能、高时钟频率的系统设计</strong>，并且还包括使其能够实现高速亚微米互连的功能。</p>
<p>2010年，从AMBA 4 <strong>AXI4</strong>开始引入了AMBA 4规范。</p>
<p>2011年，引入了 AMBA 4 <strong>ACE</strong>，ACE 通过附加的信号引入了系统范围的一致性，从而对AXI进行了扩展，该系统范围的一致性<strong>允许多个处理器共享内存</strong>，并可启用类似Arm 的big.LITTLE处理之类的技术，同时，<strong>ACE-Lite</strong>协议还可实现单向一致性，例如，一个网络接口可从完全一致的ACE处理器的缓存中读取数据，<strong>AXI4-Stream</strong> 协议适用于<strong>从主接口到从属接口的单向数据传输，这也被称为点对点传输，该协议可降低信号路由开销</strong>，因此是在FPGA中实现传输的理想选择。</p>
<p>2014年，引入了AMBA 5 <strong>CHI</strong>（一致性集线器接口）规范，<strong>重新设计的高速传输层和功能专门用于减少阻塞</strong>。</p>
<p>2016年，AHB协议被更新至<strong>AHB5</strong>，这是对ARMv8-M体系结构的补充，可扩展从处理器到系统的TrustZone安全基础，</p>
<img alt="20220611152053770" src="/MD_IMG/AMBA总线.assets/image-20220611152053770.png"  />

<h3 id="1-3-协议介绍"><a href="#1-3-协议介绍" class="headerlink" title="1.3 协议介绍"></a>1.3 协议介绍</h3><p>1、APB：高级外围设备总线（APB）用于连接低带宽的外围设备。它是一个简单的非流水线协议。读写操作共享同一组信号，不支持burst数据传输。是最容易学习的AMBA协议。<br>2、AHB：高级高性能总线（AHB）用于连接共享总线上需要更高带宽的组件。这些slave组件可以是内部内存或外部内存接口、DMA、DSP等。AHB可以通过burst数据传输来获得更高的带宽。<br>3，AHB-lite协议是AHB的一个简化版本。简化后<strong>只支持一个主设计</strong>，这消除了对任何仲裁、重试、分割事务等的需求。<br>4、高级可扩展接口（AXI）适合于高带宽和低延迟互连。这是一个点对点的互连，并克服了AHB、APB等共享总线协议在可连接的代理数量方面的限制性。该协议支持多个outstanding 的数据传输、burst数据传输、单独的读写通道和支持不同的总线宽度。<br>5，AXI-lite协议是AXI的简化版本，简化后不支持突发数据传输。<br>6，AXI-stream 协议是AXI协议的另一种风格，它只支持数据流从master 流到slave。与完整的AXI或AXI-lite不同，AXI-stream协议中没有单独的读&#x2F;写通道，因为其目的是只在一个方向上流。<br>7，ACE-AXI协议是AXI4协议的扩展，应用于在一个芯片上集成多个CPU核心与一致性cache的场景。ACE协议扩展了AXI读写数据通道，同时引入了单独的snoop地址、snoop数据和snoop响应通道。这些额外的通道提供了实现基于snoop的一致性协议的机制。<br>8，ACE-Lite-对于没有自己cache的agents，但仍属于可共享一致性域的一部分，如DMA或网络接口agent，使用ACE-lite协议实现这种”单向”一致性。<br>9，CHI-ACE协议作为AXI的扩展而开发，以支持一致性互连。ACE协议使用了master&#x2F;slave之间的信号电平通信，因此互连需要大量的线和增加的通道来进行snoops和响应。这对于具有2&#x2F;4核移动SOC的小一致性clusters非常有效。随着SOC上集成越来越多的一致性clusters——AMBA5修订版引入了CHI协议。CHI协议使用基于分层分组的通信协议，具有协议、链路层和物理层实现，还支持基于QoS的流控制和重试机制。</p>
<h2 id="2-APB"><a href="#2-APB" class="headerlink" title="2. APB"></a>2. APB</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><ul>
<li>APB（Advanced Peripheral Bus）是AMBA总线的一部分，从1998年第一版至今共有3个版本。</li>
</ul>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">AMBA2 APB：定义最基本的信号 interface, 读写 transfer, APB<span class="keyword"> bridge</span>, APB slave.</span><br><span class="line"></span><br><span class="line">AMBA3 APB：增加定义信号 PREADY, PSLVERR 来支持 wait state  和 Error reporting  的功能。</span><br><span class="line"></span><br><span class="line">AMBA4 APB：增加定义信号 PPROT, PSTRB  来支持 transaction protection 和<span class="built_in"> sparse </span>data transfer 的功能。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>APB 是非流水线协议，用于连接低带宽和不需要高性能总线的外围设备，信号传输发生在时钟上升沿，每次传输至少需要两个时钟周期。</p>
</li>
<li><p>APB 可以同 AHB、AHB-Lite、AXI、AXI4-Lite互连。</p>
</li>
</ul>
<h3 id="2-2-信号"><a href="#2-2-信号" class="headerlink" title="2.2 信号"></a>2.2 信号</h3><table>
<thead>
<tr>
<th>Signal</th>
<th>Source</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>PCLK</td>
<td>Clock source</td>
<td>时钟，上升沿有效</td>
</tr>
<tr>
<td>PRESETn</td>
<td>System bus equivalent</td>
<td>复位，低有效（通常直连系统总线复位信号）</td>
</tr>
<tr>
<td>PADDR</td>
<td>APB bridge</td>
<td>地址，位宽最高可达32 bits</td>
</tr>
<tr>
<td>PPROT</td>
<td>APB bridge</td>
<td>保护类型。该信号指示事务的正常、特权或安全保护级别，以及该事务是数据访问还是指令访问。（Protection type. This signal indicates the normal, privileged, or secure protection level of the transaction and whether the transaction is a data access or an instruction access.）</td>
</tr>
<tr>
<td>PSELx</td>
<td>APB bridge</td>
<td>片选信号，由APB bridge 产生对每个外围从设备的片选信号</td>
</tr>
<tr>
<td>PENABLE</td>
<td>APB bridge</td>
<td>使能信号，标记传输开始</td>
</tr>
<tr>
<td>PWRITE</td>
<td>APB bridge</td>
<td>读&#x2F;写控制信号，高为写操作，低为读操作</td>
</tr>
<tr>
<td>PWDATA</td>
<td>APB bridge</td>
<td>写数据，位宽最高可达32 bits</td>
</tr>
<tr>
<td>PSTRB</td>
<td>APB bridge</td>
<td>Write strobes. This signal indicates which byte lanes to update during a write transfer. There is one write strobe for each eight bits of the write data bus. Therefore, PSTRB[n] corresponds to PWDATA[(8n + 7):(8n)]. Write strobes must not be active during a read transfer.</td>
</tr>
<tr>
<td>PREADY</td>
<td>Slave interface</td>
<td>标记从机是否已将数据发送到总线，高有效</td>
</tr>
<tr>
<td>PRDATA</td>
<td>Slave interface</td>
<td>读数据，位宽最高可达32 bits</td>
</tr>
<tr>
<td>PSLVERR</td>
<td>Slave interface</td>
<td>传输错误指示。非必须，如果外设不包含该引脚，输入APB bridge默认为低</td>
</tr>
</tbody></table>
<p><strong>由于APB 协议 读写数据总线不包含握手信号，所以不支持同时读写</strong></p>
<h3 id="2-3-传输时序"><a href="#2-3-传输时序" class="headerlink" title="2.3 传输时序"></a>2.3 传输时序</h3><h4 id="2-3-1-Write"><a href="#2-3-1-Write" class="headerlink" title="2.3.1 Write"></a>2.3.1 Write</h4><p>分无等待和等待两种情况</p>
<p><strong>① With no wait states</strong></p>
<img alt="20220611180246529" src="/MD_IMG/AMBA总线.assets/image-20220611180246529.png"  />

<ul>
<li>T1 时刻， APB 将地址信息 PADDR 和写的数据 PWDATA 准备好，拉高 PWRITE 表示进入写，同时拉高 PSEL，从 IDLE 进入 SETUP</li>
<li>T2 时刻，拉高 PENABLE，使得状态进入 ACCESS</li>
<li>T3 时刻，检测到 PREADY 被拉高，也就是说 Slave 已经正确接收到数据，传输完成；PENABLE 拉低，PSEL 拉低</li>
</ul>
<p><strong>② With wait states</strong></p>
<img alt="20220611181656041" src="/MD_IMG/AMBA总线.assets/image-20220611181656041.png"  />

<ul>
<li>T3时刻检测到PREADY为0，也就是说Slave还没有接收完数据，所以在此刻，下面信号必须保持，以便Slave能够继续采样；直到PREADY为1 ，说明Slave已正确接收到数据，传输完成，PENABLE 拉低，PSEL 拉低</li>
</ul>
<p><strong>注意：即使传输结束，也不要立即改变 address 和 data 信号，直到下一次传输才更新地址和数据。这样可以减少功耗</strong></p>
<h4 id="2-3-2-Write-stobes"><a href="#2-3-2-Write-stobes" class="headerlink" title="2.3.2 Write stobes"></a>2.3.2 Write stobes</h4><p>PSTRB信号，用于指示写数据中哪些字节有效，PSTRB[n]  对应 PWDATA[(8n + 7):8n]，高有效</p>
<img alt="20220611182723163" src="/MD_IMG/AMBA总线.assets/image-20220611182723163.png"  />

<p><strong>注意：在读操作过程中，所有PSTRB信号要保持低电平</strong></p>
<h4 id="2-3-3-Read"><a href="#2-3-3-Read" class="headerlink" title="2.3.3 Read"></a>2.3.3 Read</h4><p>读操作与写操作时序差不多</p>
<p><strong>① With no wait states</strong></p>
<img alt="20220611183023346" src="/MD_IMG/AMBA总线.assets/image-20220611183023346.png"  />

<ul>
<li>T1时刻APB将地址信息PADDR准备好，拉低PWRITE表示进入读，同时拉高PSEL，从IDLE 进入SETUP </li>
<li>T2时刻也就是下一个时钟周期拉高PENABLE，使得状态进入ACCESS </li>
<li>T3时刻检测到PREADY 被拉高，也就是说Slave已经完成收据发送，PRDATA上就是来自Slave的数据，传输完成；PENABLE拉低，PSEL拉低</li>
</ul>
<p><strong>② With wait states</strong></p>
<img alt="20220611183111743" src="/MD_IMG/AMBA总线.assets/image-20220611183111743.png"  />

<h4 id="2-3-3-Error-response"><a href="#2-3-3-Error-response" class="headerlink" title="2.3.3 Error response"></a>2.3.3 Error response</h4><ul>
<li><p>在读和写的过程，可能出现错误，错误通过PSLVERR信号来指明；</p>
</li>
<li><p>APB外围设备不要求必须支持PSLVERR引脚，当不使用该引脚时，应被置低；</p>
</li>
<li><p><strong>PSLVERR 只有在传输的最后一个周期有效，且此时 PSEL、PENABLE、PREADY均为高。</strong></p>
</li>
</ul>
<h5 id="2-3-3-1-Write-transfer"><a href="#2-3-3-1-Write-transfer" class="headerlink" title="2.3.3.1 Write transfer"></a>2.3.3.1 Write transfer</h5><img alt="20220611184302886" src="/MD_IMG/AMBA总线.assets/image-20220611184302886.png"  /> 

<h5 id="2-3-3-2-Read-transfer"><a href="#2-3-3-2-Read-transfer" class="headerlink" title="2.3.3.2 Read transfer"></a>2.3.3.2 Read transfer</h5><img alt="20220611184319719" src="/MD_IMG/AMBA总线.assets/image-20220611184319719.png"  />

<h5 id="2-3-3-3-Mapping-of-PSLVERR"><a href="#2-3-3-3-Mapping-of-PSLVERR" class="headerlink" title="2.3.3.3 Mapping of PSLVERR"></a>2.3.3.3 Mapping of PSLVERR</h5><img alt="20220611184702117" src="/MD_IMG/AMBA总线.assets/image-20220611184702117.png"  />

<h4 id="2-3-4-Protection-unit-support"><a href="#2-3-4-Protection-unit-support" class="headerlink" title="2.3.4 Protection unit support"></a>2.3.4 Protection unit support</h4><p>为了支持复杂的系统设计，互连和系统中的其他设备通常都需要提供防止非法交易的保护。对于APB接口，这种保护是由PPROT[2:0]信号提供的。</p>
<img alt="20220611193858821" src="/MD_IMG/AMBA总线.assets/image-20220611193858821.png"  />

<img alt="20220611193916347" src="/MD_IMG/AMBA总线.assets/image-20220611193916347.png"  />

<h3 id="2-4-状态机"><a href="#2-4-状态机" class="headerlink" title="2.4 状态机"></a>2.4 状态机</h3><img alt="20220611194240094" src="/MD_IMG/AMBA总线.assets/image-20220611194240094.png"  />

<ul>
<li><strong>IDLE</strong>：这个是APB的默认状态，也就是没有传输时候的状态；</li>
<li><strong>SETUP</strong>：当需要进行一个传输的时候，APB 首先进入这个状态；PSELx信号首先拉高；总线仅仅在SETUP状态停留一个时钟周期，然后接着在下一个时钟的上升沿进入ACCESS状态；</li>
<li><strong>ACESS</strong>：<ul>
<li>在SETUP状态转换到ACCESS，PENABLE 信号被拉高；在SETUP状态转换到ACCESS状态这段时间里，address，write，select 和 write data 信号必须保持稳定；</li>
<li>处于ACESS状态下，如果PREADY为0，会让其继续处于ACCESS状态；否则，PREADY为1，如果还有传输则再次进入，SETUP-&gt; ACCESS，如果没有传输，直接回到IDLE；</li>
</ul>
</li>
</ul>
<h2 id="3-AHB"><a href="#3-AHB" class="headerlink" title="3. AHB"></a>3. AHB</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><ul>
<li>AHB（Advanced High-performance Bus）是一种适合高性能综合设计的总线接口。它定义了组件之间的接口，如 masters, interconnects, and slaves。</li>
<li>AHB 从设备一般是内部存储设备、外部存储接口和高带宽外设，低带宽外设一般是通过APB总线，使用AHB2APB 桥接到APB总线。</li>
</ul>
<h3 id="3-2-信号"><a href="#3-2-信号" class="headerlink" title="3.2 信号"></a>3.2 信号</h3><table>
<thead>
<tr>
<th>Signals</th>
<th>Name</th>
<th>Source</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Global</strong></td>
<td>HCLK</td>
<td>Clock source</td>
<td>时钟，上升沿有效</td>
</tr>
<tr>
<td></td>
<td>HRESETn</td>
<td>Reset controller</td>
<td>复位，低有效，复位整个系统和总线</td>
</tr>
<tr>
<td><strong>Master</strong></td>
<td>HADDR[31:0]</td>
<td>Slave and decoder</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HBURST[2:0]</td>
<td>Slave</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HMASTLOCK</td>
<td>Slave</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HPROT[3:0]</td>
<td>Slave</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HPROT[6:4]</td>
<td>Slave</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HSIZE[2:0]</td>
<td>Slave</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HNONSEC</td>
<td>Slave and decoder</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HEXCL</td>
<td>Exclusive Access Monitor</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HMASTER[3:0]</td>
<td>Exclusive Access Monitor and slave</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HTRANS[1:0]</td>
<td>Slave</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HWDATA[31:0]</td>
<td>Slave</td>
<td>最小位宽32bit</td>
</tr>
<tr>
<td></td>
<td>HWRITE</td>
<td>Slave</td>
<td>读&#x2F;写控制信号，高为写操作，低为读操作（时序同地址信号，在一个突发内维持不变）</td>
</tr>
<tr>
<td><strong>Slave</strong></td>
<td>HRDATA[31:0]</td>
<td>Multiplexor</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HREADYOUT</td>
<td>Multiplexor</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HRESP</td>
<td>Multiplexor</td>
<td>告知mastar传输状态，低为OKAY，高为ERROR</td>
</tr>
<tr>
<td></td>
<td>HEXOKAY</td>
<td>Multiplexor</td>
<td></td>
</tr>
<tr>
<td><strong>Decoder</strong></td>
<td>HSELx</td>
<td>Slave</td>
<td></td>
</tr>
<tr>
<td><strong>Multiplexor</strong></td>
<td>HRDATA[31:0]</td>
<td>Master</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HREADY</td>
<td>Master and slave</td>
<td>高为前一个传输完成</td>
</tr>
<tr>
<td></td>
<td>HRESP</td>
<td>Master</td>
<td>Transfer response, selected by the decoder.</td>
</tr>
<tr>
<td></td>
<td>HEXOKAY</td>
<td>Master</td>
<td>Exclusive okay, selected by the decoder</td>
</tr>
</tbody></table>
<h3 id="3-3-传输时序"><a href="#3-3-传输时序" class="headerlink" title="3.3 传输时序"></a>3.3 传输时序</h3><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="PS-与-PL"><a href="#PS-与-PL" class="headerlink" title="PS 与 PL"></a><strong>PS 与 PL</strong></h2><ul>
<li>PS：处理系统（Processing System），就是与FPGA无关的ARM是SoC的部分。</li>
<li>PL：可编程逻辑（Programmable Logic）,就是FPGA部分。</li>
</ul>
<h2 id="AXI"><a href="#AXI" class="headerlink" title="AXI"></a><strong>AXI</strong></h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li>AXI 全称 “Advanced Extensible Interface ”，主要描述主设备和从设备之间的数据传输方式。AXI 是 ARM 公司提出的 AMBA（Advanced Microcontroller Bus Architecture）的一部分，是一种高性能、高带宽、低延迟的片内总线，也用来替代以前的 AHB 和 APB 总线。</li>
<li>第一个版本的 AXI（AXI3）包含在 2003年发布的 AMBA3.0 中， AXI 的第二个版本 AXI （AXI4）包含在 2010 年发布的 AMBA 4.0 之中。</li>
</ul>
<h3 id="AXI-协议"><a href="#AXI-协议" class="headerlink" title="AXI 协议"></a><strong>AXI 协议</strong></h3><p>​		主设备和从设备之间通过握手信号建立连接。当从设备准备好接收数据时，会发出 Ready 信号。当主设备的数据准备好时，会发出和维持 Valid 信号，表示数据有效。数据只有在 Valid 和 Ready 信号都有效的时候才开始传输。当这两个信号持续保持有效，主设备会继续传输下一个数据。主设备可以撤销 Valid 信号，或者从设备撤销 Ready 信 号终止传输。 AXI 的协议如图， T2 时，从设备的 Ready 信号有效， T3 时主设备的 Valid 信号有效，数据传输开始。</p>
<img alt="20211227205856922" src="/MD_IMG/AMBA总线.assets/image-20211227205856922.png"  />

<p>​		在 ZYNQ 中，支持 AXI-Lite，AXI4 和 AXI-Stream 三种总线，下表介绍这三种 AXI 接口的特性。</p>
<table>
<thead>
<tr>
<th align="center">接口协议</th>
<th align="center">特性</th>
<th align="center">应用场合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AXI4-Lite</td>
<td align="center">地址&#x2F;单数据传输</td>
<td align="center">低速外设或控制</td>
</tr>
<tr>
<td align="center">AXI4</td>
<td align="center">地址&#x2F;突发数据传输</td>
<td align="center">地址的批量传输</td>
</tr>
<tr>
<td align="center">AXI4-Stream</td>
<td align="center">仅传输数据，突发传输</td>
<td align="center">数据流和媒体流传输</td>
</tr>
</tbody></table>
<ul>
<li><p>AXI4-Lite：</p>
<p>具有轻量级、结构简单的特点，适合小批量数据、简单控制场合。不支持批量传输，读写时一次只能读写一个字（32 bit）。主要用于访问一些低速外设和外设的控制。</p>
</li>
<li><p>AXI4：</p>
<p>相比 AXI4-Lite ，增加了批量传输功能，可以连续对一片地址进行一次性读写。也就是说具有数据读写的 burst 功能。</p>
</li>
</ul>
<p>​       上面两种均采用内存映射控制方式，即 ARM 将用户自定义 IP 编入某一地址进行访问，读写时就像在读写自己的片内 RAM ，编程也很方便，开发难度较低。代价就是资源占用过多需要额外的读地址线、写地址线、读数据线、写数据线、写应答线这些信号线。</p>
<ul>
<li><p>AXI4-Stream：</p>
<p>这是一种连续流接口，不需要地址线（很像 FIFO ，一直读或一直写就行）。对于这类 IP ，ARM 不能通过上面的内存映射方式控制（ FIFO 根本没有地址的概念），必须有一个转换装置，例如 AXI DMA 模块来实现内存映射到流式接口的转换。 AXI Stream 适用的场合有很多：视频流处理；通信协议转换；数字信号处理；无线通信等。其本质都是针对数据流构建的数据通路，从信源（例如 ARM 内存、 DMA 、无线接收前端等）到信宿（例如 HDMI 显示器、高速 AD 音频输出，等）构建起连续的数据流。<strong>这种接口适合做实时信号处理</strong>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>AMBA</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC</title>
    <url>/2023/07/08/IIC/</url>
    <content><![CDATA[<h3 id="IIC总线概述"><a href="#IIC总线概述" class="headerlink" title="IIC总线概述"></a>IIC总线概述</h3><h4 id="IIC总线简介"><a href="#IIC总线简介" class="headerlink" title="IIC总线简介"></a>IIC总线简介</h4><p>IIC总线是Philips公司在八十年代初推出的<strong>一种串行、半双工总线，主要用于近距离、低速的芯片之间的通信</strong>；IIC总线有两根双向的信号线<strong>一根数据线 SDA 用于收发数据，一根时钟线 SCL 用于通信双方时钟的同步</strong>；IIC总线硬件结构简单，成本较低，因此在各个领域得到了广泛的应用。</p>
<p>IIC总线是一种<strong>多主机总线</strong>，连接在IIC总线上的器件<strong>分为主机和从机</strong>，<strong>主机有权发起和结束一次通信，而从机只能被主机呼叫</strong>；当总线上有多个主机同时启用总线时，IIC也具备冲突检测和仲裁的功能来防止错误产生；每个连接到IIC总线上的器件都有一个唯一的<strong>地址（7bit）</strong>，且<strong>每个器件都可以作为主机也可以作为从机（同一时刻只能有一个主机）</strong>，总线上的器件增加和删除不影响其他器件正常工作；IIC总线在通信时总线上发送数据的器件为发送器，接收数据的器件为接收器；</p>
<img alt="20220312221523373" src="/MD_IMG/IIC.assets/image-20220312221523373.png"  />

<h4 id="IIC总线通信过程"><a href="#IIC总线通信过程" class="headerlink" title="IIC总线通信过程"></a>IIC总线通信过程</h4><ol>
<li><p>主机发送起始信号启用总线；</p>
</li>
<li><p>主机发送<strong>一个字节</strong>数据指明<strong>从机地址</strong>和<strong>后续字节的传送方向</strong>；</p>
</li>
<li><p>被寻址的从机发送应答信号回应主机；</p>
</li>
<li><p>发送器发送一个字节数据；</p>
</li>
<li><p>接收器发送应答信号回应发送器；</p>
<p>… …（循环步骤4、5）</p>
</li>
<li><p>通信完成后主机发送停止信号释放总线。</p>
</li>
</ol>
<h4 id="IIC总线寻址方式"><a href="#IIC总线寻址方式" class="headerlink" title="IIC总线寻址方式"></a>IIC总线寻址方式</h4><p>IIC总线上传送的数据是广义的，既包括地址，又包括真正的数据。</p>
<p>主机在发送起始信号后必须先发送一个字节的数据，该数据的高7位为从机地址，最低位表示后续字节的传送方向，’0’表示主机发送数据，’1’表示主机接收数据；总线上所有的从机接收到该字节数据后都将这7位地址与自己的地址进行比较，如果相同，则认为自己被主机寻址，然后再根据第8位将自己定为发送器或接收器。</p>
<img src="/MD_IMG/IIC.assets/image-20220312221117719.png" alt="image-20220312221117719" style="zoom:80%;" />

<h3 id="IIC总线信号实现"><a href="#IIC总线信号实现" class="headerlink" title="IIC总线信号实现"></a>IIC总线信号实现</h3><h4 id="起始信号、停止信号"><a href="#起始信号、停止信号" class="headerlink" title="起始信号、停止信号"></a>起始信号、停止信号</h4><ul>
<li><p><strong>SCL为高电平时， SDA由高变低表示起始信号</strong></p>
</li>
<li><p><strong>SCL为高电平时， SDA由低变高表示停止信号</strong></p>
</li>
<li><p>起始信号和停止信号都是由主机发出，起始信号产生后总线处于占用状态停止信号产生后总线处于空闲状态</p>
</li>
</ul>
<img alt="20220312221152405" src="/MD_IMG/IIC.assets/image-20220312221152405.png"  />

<h4 id="字节传送与应答"><a href="#字节传送与应答" class="headerlink" title="字节传送与应答"></a>字节传送与应答</h4><p>IIC总线通信时每个字节为8位长度，数据传送时，先传送最高位，后传送低位，发送器发送完一个字节数据后接收器必须发送1位应答位来回应发送器即一帧共有9位</p>
<img alt="20220312221230794" src="/MD_IMG/IIC.assets/image-20220312221230794.png"  />

<h4 id="同步信号"><a href="#同步信号" class="headerlink" title="同步信号"></a>同步信号</h4><p>IIC总线在进行数据传送时，时钟线SCL为低电平期间发送器向数据线上发送一位数据，在此期间数据线上的信号允许发生变化，时钟线SCL为高电平期间接收器从数据线上读取一位数据，在此期间数据线上的信号不允许发生变化，必须保持稳定。</p>
<img alt="20220312221355428" src="/MD_IMG/IIC.assets/image-20220312221355428.png"  />

<h3 id="IIC典型时序"><a href="#IIC典型时序" class="headerlink" title="IIC典型时序"></a>IIC典型时序</h3><ol>
<li>主机向从机发送数据</li>
</ol>
<img alt="20220312220410246" src="/MD_IMG/IIC.assets/image-20220312220410246.png"  />

<ul>
<li>停止发送有两种情况：①主机不想发了；②从机不想应答了。但是终止信号只能是主机发出</li>
</ul>
<ol start="2">
<li>从机向主机发送数据</li>
</ol>
<img alt="20220312220433000" src="/MD_IMG/IIC.assets/image-20220312220433000.png"  />

<ol start="3">
<li>主机先向从机发送数据，然后从机再向主机发送数据</li>
</ol>
<img alt="20220312220458513" src="/MD_IMG/IIC.assets/image-20220312220458513.png"  />

<ul>
<li><strong>变更操作方向的时候不用发停止信号</strong>，如果发了停止信号再变更，有可能总线使用权就被别的主机抢走了</li>
</ul>
<p>注：阴影部分表示数据由主机向从机传送，无阴影部分则表示数据由从机向主机传送；A表示应答，A非表示非应答，S表示起始信号，P表示终止信号</p>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>IIC</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab</title>
    <url>/2023/07/08/Matlab/</url>
    <content><![CDATA[<h2 id="fopen-打开文件"><a href="#fopen-打开文件" class="headerlink" title="fopen (打开文件)"></a>fopen (打开文件)</h2><p><img src="/MD_IMG/Matlab.assets/image-20230531230739648.png" alt="image-20230531230739648"></p>
<h2 id="fread-读取文件"><a href="#fread-读取文件" class="headerlink" title="fread (读取文件)"></a>fread (读取文件)</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = fread(fileID,sizeA,precision,skip,machinefmt) </span><br><span class="line"><span class="comment">% 将文件数据读取到维度为 sizeA 的数组 A 中，并将文件指针定位到最后读取的值之后。</span></span><br><span class="line"><span class="comment">% fread 按列顺序填充 A。根据 precision 描述的格式和大小解释文件中的值。</span></span><br><span class="line"><span class="comment">% skip 在读取文件中的每个值之后将跳过 skip 指定的字节或位数</span></span><br><span class="line"><span class="comment">% machinefmt 指定在文件中读取字节或位时的顺序。</span></span><br></pre></td></tr></table></figure>

<h3 id="sizeA"><a href="#sizeA" class="headerlink" title="sizeA"></a>sizeA</h3><p><img src="/MD_IMG/Matlab.assets/image-20230531231402603.png" alt="image-20230531231402603"></p>
<h3 id="precision"><a href="#precision" class="headerlink" title="precision"></a>precision</h3><p><img src="/MD_IMG/Matlab.assets/image-20230531231446071.png" alt="image-20230531231446071"></p>
<h3 id="machinefmt"><a href="#machinefmt" class="headerlink" title="machinefmt"></a>machinefmt</h3><p><img src="/MD_IMG/Matlab.assets/image-20230602150806677.png" alt="image-20230602150806677"></p>
<h2 id="fwrite-将数据写入二进制文件"><a href="#fwrite-将数据写入二进制文件" class="headerlink" title="fwrite (将数据写入二进制文件)"></a>fwrite (将数据写入二进制文件)</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">fwrite(fileID,A,precision,skip,machinefmt)</span><br><span class="line"><span class="comment">% fileID 文件标识符</span></span><br><span class="line"><span class="comment">% A 要写入的数据</span></span><br><span class="line"><span class="comment">% precision 要写入的值的类和大小，默认 &#x27;uint8&#x27;</span></span><br><span class="line"><span class="comment">% skip 要跳过的字节数，写一次，下次要写跳过的字节数</span></span><br><span class="line"><span class="comment">% machinefmt 字节写入顺序</span></span><br></pre></td></tr></table></figure>



<h2 id="fprintf-将数据写入文本文件）"><a href="#fprintf-将数据写入文本文件）" class="headerlink" title="fprintf (将数据写入文本文件）"></a>fprintf (将数据写入文本文件）</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">.1</span>:<span class="number">1</span>;</span><br><span class="line">A = [x; <span class="built_in">exp</span>(x)];</span><br><span class="line"></span><br><span class="line">fileID = fopen(<span class="string">&#x27;exp.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">fprintf(fileID,<span class="string">&#x27;%6s %12s\n&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;exp(x)&#x27;</span>);</span><br><span class="line">fprintf(fileID,<span class="string">&#x27;%6.2f %12.8f\n&#x27;</span>,A);</span><br><span class="line">fclose(fileID);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第一个对 fprintf 的调用输出标题文本 x 和 exp(x)，第二个调用输出变量 A 的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="格式操作符"><a href="#格式操作符" class="headerlink" title="格式操作符"></a>格式操作符</h3><p>格式化操作符以百分号 <code>%</code> 开头，以转换字符结尾。转换字符是必需的。您也可以在 <code>%</code> 和转换字符之间指定标识符、标志、字段宽度、精度和子类型操作符。（操作符之间的空格无效，在这里显示空格只是为了便于阅读。）</p>
<p><img src="/MD_IMG/Matlab.assets/image-20230531230024872.png" alt="image-20230531230024872"></p>
<h3 id="转换字符"><a href="#转换字符" class="headerlink" title="转换字符"></a>转换字符</h3><p><img src="/MD_IMG/Matlab.assets/image-20230531230044317.png" alt="image-20230531230044317"></p>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p><img src="/MD_IMG/Matlab.assets/image-20230531230241266.png" alt="image-20230531230241266"></p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p><img src="/MD_IMG/Matlab.assets/image-20230531230346466.png" alt="image-20230531230346466"></p>
<h2 id="zeros-创建全零数组"><a href="#zeros-创建全零数组" class="headerlink" title="zeros (创建全零数组)"></a>zeros (创建全零数组)</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 创建一个由零组成的 1(行)×3(列) 向量，其元素为 32 位无符号整数</span></span><br><span class="line">X = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&#x27;uint32&#x27;</span>)</span><br><span class="line"><span class="comment">% 要创建的数据类型可以为 &#x27;double&#x27;(默认)、&#x27;single&#x27;、&#x27;logical&#x27;、&#x27;int8&#x27;、&#x27;uint8&#x27;、&#x27;int16&#x27;、&#x27;uint16&#x27;、&#x27;int32&#x27;、&#x27;uint32&#x27;、&#x27;int64&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 递增,默认步进值为1</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 递减</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">-1</span> : <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 指定值</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = [<span class="number">1</span> <span class="number">5</span> <span class="number">8</span> <span class="number">17</span>]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="length-最大数组维度的长度"><a href="#length-最大数组维度的长度" class="headerlink" title="length (最大数组维度的长度)"></a>length (最大数组维度的长度)</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">7</span>);</span><br><span class="line">L = <span class="built_in">length</span>(X)</span><br><span class="line"><span class="comment">% L = 7</span></span><br></pre></td></tr></table></figure>

<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">n = input(<span class="string">&#x27;Enter a number: &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> n</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;negative one&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;zero&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;positive one&#x27;</span>)</span><br><span class="line">    <span class="keyword">otherwise</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;other value&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="if-elseif-else"><a href="#if-elseif-else" class="headerlink" title="if, elseif, else"></a>if, elseif, else</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> r  c</span><br><span class="line">    A(r,c) = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">abs</span>(r-c)  <span class="number">1</span></span><br><span class="line">    A(r,c) = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    A(r,c) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><p><img src="/MD_IMG/Matlab.assets/image-20230602154823255.png" alt="image-20230602154823255"></p>
<h3 id="逻辑-布尔-运算"><a href="#逻辑-布尔-运算" class="headerlink" title="逻辑 (布尔) 运算"></a>逻辑 (布尔) 运算</h3><img src="/MD_IMG/Matlab.assets/image-20230602154955351.png" alt="image-20230602154955351" style="zoom:80%;" />

<h3 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h3><p><img src="/MD_IMG/Matlab.assets/image-20230602155111455.png" alt="image-20230602155111455"></p>
<h2 id="round-四舍五入取整"><a href="#round-四舍五入取整" class="headerlink" title="round (四舍五入取整)"></a>round (四舍五入取整)</h2><p><code>Y = round(X,N)</code> 四舍五入到 <code>N</code> 位数：</p>
<ul>
<li><code>N &gt; 0</code>：舍入到小数点<em>右侧</em>的第 <code>N</code> 位数。</li>
<li><code>N = 0</code>：四舍五入到最接近的整数（默认）。</li>
<li><code>N &lt; 0</code>：舍入到小数点<em>左侧</em>的第 <code>N</code> 位数。</li>
</ul>
<h2 id="将16进制数写文件"><a href="#将16进制数写文件" class="headerlink" title="将16进制数写文件"></a>将16进制数写文件</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc; <span class="comment">% 清除命令行窗口</span></span><br><span class="line">clear all;<span class="comment">% 清除所有变量</span></span><br><span class="line">close all; <span class="comment">% 关闭所有Figure窗口</span></span><br><span class="line"></span><br><span class="line">data = randi([<span class="number">-128</span> <span class="number">127</span>],<span class="number">1</span>,<span class="number">256</span>);<span class="comment">% 产生随机的有符号数据 2^8(-128~127)</span></span><br><span class="line"><span class="comment">% 需要将负数转换为正数</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(data)</span><br><span class="line">    <span class="keyword">if</span>(data(<span class="built_in">i</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        data_hex(<span class="built_in">i</span>) = <span class="number">2</span>^<span class="number">8</span> + data(<span class="built_in">i</span>);<span class="comment">% 根据自己需要转换的位宽修改</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        data_hex(<span class="built_in">i</span>) = data(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 将有符号的十六进制数写入txt文件</span></span><br><span class="line">fid = fopen(<span class="string">&#x27;C:\Users\data_hex.txt&#x27;</span>, <span class="string">&#x27;w+&#x27;</span>);</span><br><span class="line">fprintf(fid,<span class="string">&#x27;%02x\n&#x27;</span>,data_hex(<span class="built_in">i</span>));</span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>软件使用</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>SCCB</title>
    <url>/2023/07/08/SCCB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SCCB（Serial Camera Control Bus，串行摄像头控制总线）是由OV（OmniVision的简称）公司定义和发展的三线式串行总线，该总线控制着摄像头大部分的功能，包括图像数据格式、分辨率以及图像处理参数等。结构框图如下所示:</p>
<img src="/MD_IMG/SCCB.assets/image-20230422173031274.png" alt="image-20230422173031274"  />

<img src="/MD_IMG/SCCB.assets/image-20230422233636955.png" alt="image-20230422233636955"  />

<h2 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h2><img alt="image-20230422173139183" src="/MD_IMG/SCCB.assets/image-20230422173139183.png"  />

<p>OV公司为了减少传感器引脚的封装，现在SCCB总线大多采用两线式接口总线，包括SIO_C串行时钟输入线和SIO_D串行双向数据线，分别相当于IIC协议的SCL信号线和SDA信号线。SIO_C的最小时间为10us，即最大频率为100K。一般来说，100K-400K之间都可以。</p>
<img alt="image-20230422173643883" src="/MD_IMG/SCCB.assets/image-20230422173643883.png"  />

<h2 id="传输时序"><a href="#传输时序" class="headerlink" title="传输时序"></a>传输时序</h2><img alt="image-20230422173922186" src="/MD_IMG/SCCB.assets/image-20230422173922186.png"  />

<h3 id="起始-x2F-结束信号"><a href="#起始-x2F-结束信号" class="headerlink" title="起始&#x2F;结束信号"></a>起始&#x2F;结束信号</h3><h4 id="三线模式"><a href="#三线模式" class="headerlink" title="三线模式"></a>三线模式</h4><ul>
<li><strong>起始：SCCB_E由高变低</strong></li>
<li><strong>结束：SCCB_E由低变高</strong></li>
</ul>
<h4 id="两线模式"><a href="#两线模式" class="headerlink" title="两线模式"></a>两线模式</h4><ul>
<li><strong>起始：SIO_C为高时，SIO_D由高变低</strong></li>
<li><strong>结束：SIO_C为高时，SIO_D由低变高</strong></li>
</ul>
<hr>
<p><strong>参数说明</strong></p>
<ul>
<li>t<sub>PRC</sub>：SCCB_E拉低之前，SIO_D必须保持高电平的最短时间，15ns</li>
<li>t<sub>PRA</sub>：SIO_D拉低之前，SCCB_E必须保持低电平的最短时间，1.25us</li>
<li>t<sub>PSA</sub>：SCCB_E拉高之前，SIO_D必须保持高电平的最短时间，15ns</li>
<li>t<sub>PSC</sub>：SIO_D拉低之前，SCCB_E必须保持低电平的最短时间，0ns</li>
</ul>
<img alt="image-20230422174602727" src="/MD_IMG/SCCB.assets/image-20230422174602727.png"  />

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="传输周期"><a href="#传输周期" class="headerlink" title="传输周期"></a>传输周期</h2><p>每个阶段包含9bits，高位优先传输，第9bit为 Don’t care 或 NA</p>
<img alt="image-20230422224823400" src="/MD_IMG/SCCB.assets/image-20230422224823400.png"  />

<h3 id="3阶段写传输周期"><a href="#3阶段写传输周期" class="headerlink" title="3阶段写传输周期"></a>3阶段写传输周期</h3><p>用于主设备写单byte数据至从设备</p>
<ul>
<li>第一阶段：传输从设备地址</li>
<li>第二阶段：传输写寄存器地址</li>
<li>第三阶段：传输写数据</li>
<li>三阶段的第9bit均为Don’t care</li>
</ul>
<img alt="image-20230422225303909" src="/MD_IMG/SCCB.assets/image-20230422225303909.png"  />

<h3 id="2阶段写传输周期"><a href="#2阶段写传输周期" class="headerlink" title="2阶段写传输周期"></a>2阶段写传输周期</h3><p>用于指示从设备读寄存器地址</p>
<ul>
<li><p>读数据前需要先指明从设备读寄存器地址</p>
</li>
<li><p>两阶段的第9bit均为Don’t care</p>
</li>
</ul>
<img alt="image-20230422230047563" src="/MD_IMG/SCCB.assets/image-20230422230047563.png"  />

<h3 id="2阶段读传输周期"><a href="#2阶段读传输周期" class="headerlink" title="2阶段读传输周期"></a>2阶段读传输周期</h3><img alt="image-20230422230629698" src="/MD_IMG/SCCB.assets/image-20230422230629698.png"  />

<h3 id="阶段一-ID-Address"><a href="#阶段一-ID-Address" class="headerlink" title="阶段一 ID Address"></a>阶段一 ID Address</h3><p>主设备通过阶段1来识别所选的从设备，以便读取或写入数据。每个从设备都有一个唯一的ID地址，由7位组成，从高到低依次编号为位7到位1。第8位（即位0）是读&#x2F;写选择器位，用于指定当前周期的传输方向。逻辑0表示写入周期，逻辑1表示读取周期。</p>
<ul>
<li>SIO_D_OE_M、SIO_D_OE_S低有效，分别为主设备和从设备的I&#x2F;O使能信号</li>
<li>SIO_D_OE_S 先变为低，即从设备输出SIO_D信号，主设备作为输入端</li>
<li>t<sub>CYC </sub>：单bit传输周期，最短10us，对应时钟频率100KHz</li>
</ul>
<img alt="image-20230422231023238" src="/MD_IMG/SCCB.assets/image-20230422231023238.png"  />

<h3 id="阶段二-子地址-x2F-读数据"><a href="#阶段二-子地址-x2F-读数据" class="headerlink" title="阶段二 子地址&#x2F;读数据"></a>阶段二 子地址&#x2F;读数据</h3><p>在阶段2中，主设备向所选的从设备发送子地址信息。子地址用于指定要读取或写入的特定寄存器地址。</p>
<hr>
<p>子地址</p>
<img alt="image-20230422232158352" src="/MD_IMG/SCCB.assets/image-20230422232158352.png"  />

<hr>
<p>读数据</p>
<p>第9bit 主设备回复 NA（逻辑1）</p>
<img alt="image-20230422232446496" src="/MD_IMG/SCCB.assets/image-20230422232446496.png"  />

<h3 id="阶段三-写数据"><a href="#阶段三-写数据" class="headerlink" title="阶段三 写数据"></a>阶段三 写数据</h3><p>在阶段3中，主设备向所选的从设备发送数据信息。如果是写入周期，则主设备将数据写入所选寄存器地址；如果是读取周期，则从设备将请求数据发送回主设备。</p>
<img alt="image-20230422232939692" src="/MD_IMG/SCCB.assets/image-20230422232939692.png"  />

<h2 id="SCCB与IIC区别"><a href="#SCCB与IIC区别" class="headerlink" title="SCCB与IIC区别"></a>SCCB与IIC区别</h2><ul>
<li><p>SCCB的应答位称为X，表示“Don’t care”，而IIC应答位称为ACK。</p>
</li>
<li><p>SCCB只能单次读，而IIC除了单次读还支持连续读。</p>
</li>
<li><p>SCCB读操作中间有stop，而IIC读操作中间可以有stop也可以不需要stop，具体表现如下</p>
</li>
</ul>
<p>SCCB读：start_1 + phase_1 + phase_2 + stop_1 + start_2 + phase_1+ phase_2 + stop_2<br>     IIC读：start_1 + phase_1 + phase_2 +              + start_2 + phase_1 + phase_2+ stop_2</p>
<p>　　除去上面三点，SCCB和IIC再无区别，因此如果只需要配置寄存器（只用到写），可以直接拿IIC的时序来当做SCCB用，如果需要读，读操作中间必须有一个stop。</p>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>SCCB</tag>
      </tags>
  </entry>
  <entry>
    <title>Modelsim</title>
    <url>/2023/07/08/Modelsim/</url>
    <content><![CDATA[<h1 id="Quartus-联合-Modelsim"><a href="#Quartus-联合-Modelsim" class="headerlink" title="Quartus 联合 Modelsim"></a>Quartus 联合 Modelsim</h1><p>​		这里使用的版本是：</p>
<ul>
<li><p>Quartus Prime 18.1.0.222 Pro Edition</p>
</li>
<li><p>Modelsim - INTEL FPGA STARTER EDITION 10.6d</p>
<p>由于直接使用quartus安装时自带的modelsim，所以不需要单独进行Altera库的安装，直接新建工程即可仿真</p>
</li>
</ul>
<p>注：quartus pro版本与modelsim目前所知道最简单的仿真方法就是使用quartus安装时下载的modelsim进行独立仿真，操作步骤如下：</p>
<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><ol>
<li>在电脑上新建个文件夹，用来存放modelsim工程</li>
<li>从windows开始菜单里打开modelsim软件</li>
</ol>
<img src="/MD_IMG/Modelsim仿真.assets/image-20211105235512769.png" alt="image-20211105235512769" style="zoom: 80%;" />

<ol start="2">
<li>更改modelsim目录到新建的文件夹下</li>
</ol>
<img alt="20211108000445532" src="/MD_IMG/Modelsim仿真.assets/image-20211108000445532.png"  />

<ol start="3">
<li>新建工程，点击 Add Existing File（添加所有要仿真的文件）</li>
</ol>
<img alt="20211108003308888" src="/MD_IMG/Modelsim仿真.assets/image-20211108003308888.png"  />

<ol start="4">
<li>编译所有</li>
</ol>
<img src="/MD_IMG/Modelsim仿真.assets/image-20211108001002004.png" alt="image-20211108001002004" style="zoom:80%;" />

<ol start="5">
<li>然后在命令行窗口输入下面语句，其中将 <strong>work.zerodly_data_gen_tb</strong> 改为 <strong>work.+ 你要仿真的文件名</strong></li>
</ol>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">vsim -L work   -L cyclone10gx_ver -L alter<span class="built_in">a_ver</span> -L lpm_ver -L sgate_ver -L alter<span class="built_in">a_mf</span>_ver -L alter<span class="built_in">a_lnsim</span>_ver -L twentynm_ver -L twentynm_hssi_ver -L twentynm_hip_ver -t ps -novopt work.top_scaler_tb  -t ns</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>添加要观察的信号到波形窗口，命令行输入 <strong>view wave</strong>，命令行输入<strong>run 1 ns</strong>，即可观察波形</li>
<li>每次修改代码，直接compile更改的文件 -&gt; restart -&gt; run</li>
</ol>
<img alt="20211108132118081" src="/MD_IMG/Modelsim仿真.assets/image-20211108132118081.png"  />

<ol start="8">
<li>可以保存波形窗口格式，下次仿真直接加载 <strong>.do文件</strong>，然后restart -&gt; run即可，不用再重新添加信号</li>
</ol>
<h2 id="仿真已有工程"><a href="#仿真已有工程" class="headerlink" title="仿真已有工程"></a>仿真已有工程</h2><p><strong>File -&gt; Library -&gt; a map to an existing library -&gt; compile -&gt; 命令行输入 view wave -&gt; load do文件 -&gt; run</strong></p>
<img alt="20211106000209355" src="/MD_IMG/Modelsim仿真.assets/image-20211106000209355.png"  />

<h1 id="Vivado-联合-Modelsim"><a href="#Vivado-联合-Modelsim" class="headerlink" title="Vivado 联合 Modelsim"></a>Vivado 联合 Modelsim</h1><p>这里使用的版本是：</p>
<ul>
<li>Vivado 2019.1</li>
<li>Modelsim SE-64 2020.4</li>
</ul>
<h2 id="Modelsim-安装"><a href="#Modelsim-安装" class="headerlink" title="Modelsim 安装"></a>Modelsim 安装</h2><ol>
<li>复制MentorKG.exe，mgls64.dll以及patch64_dll.bat这三个文件到Modelsim安装目录的win64文件夹下，如E:\modeltech64_2020.4\win64</li>
<li>双击win64文件夹内粘贴过去的patch64_dll.bat文件，会生成LICENSE.TXT，另存到安装目录</li>
<li>设置系统环境变量，变量值为LICENSE.TXT的路径   变量名：LM_LICENSE_FILE   变量值：E:\modeltech64_2020.4\LICENSE.TXT</li>
<li>完成</li>
</ol>
<h2 id="联合-Vivado"><a href="#联合-Vivado" class="headerlink" title="联合 Vivado"></a>联合 Vivado</h2><ol>
<li><p>生成库文件</p>
<p><img src="/MD_IMG/Modelsim%E4%BB%BF%E7%9C%9F.assets/image-20230624200514627.png" alt="image-20230624200514627"></p>
</li>
<li><p>从库文件夹里的 modelsim.ini 文件中复制如下内容</p>
<p><img src="/MD_IMG/Modelsim%E4%BB%BF%E7%9C%9F.assets/image-20230624201226528.png" alt="image-20230624201226528"></p>
</li>
<li><p>将 modelsim 根目录下 modelsim.ini 文件属性只读关闭</p>
</li>
<li><p>粘贴刚刚复制的内容到该文件的如下位置，然后保存，勾选只读</p>
<p><img src="/MD_IMG/Modelsim%E4%BB%BF%E7%9C%9F.assets/image-20230624201314875.png" alt="image-20230624201314875"></p>
</li>
<li><p>Vivado 设置</p>
<p><img src="/MD_IMG/Modelsim%E4%BB%BF%E7%9C%9F.assets/image-20230624201449182-1687608911932-1.png" alt="image-20230624201449182"></p>
<p><img src="/MD_IMG/Modelsim%E4%BB%BF%E7%9C%9F.assets/image-20230624201515411.png" alt="image-20230624201515411"></p>
</li>
<li><p>可以仿真了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>软件使用</tag>
        <tag>Modelsim</tag>
      </tags>
  </entry>
  <entry>
    <title>UART</title>
    <url>/2023/07/08/UART/</url>
    <content><![CDATA[<h2 id="1-UART-协议原理与编程"><a href="#1-UART-协议原理与编程" class="headerlink" title="1. UART 协议原理与编程"></a>1. UART 协议原理与编程</h2><h3 id="1-1-UART-简介"><a href="#1-1-UART-简介" class="headerlink" title="1.1 UART 简介"></a>1.1 UART 简介</h3><p><strong>UART</strong>，<strong>U</strong>niversal <strong>A</strong>synchronous <strong>R</strong>eceiver <strong>T</strong>ransmitter 即<strong>通用异步收发器</strong>，是一种通用的<strong>串行</strong>、<strong>异步</strong>通信总线该<strong>总线有两条数据线</strong>，可以实现<strong>全双工的发送和接收</strong>在嵌入式系统中常用于主机与辅助设备之间的通信。 </p>
<p><strong>比特率</strong>：每秒传输的比特的数量</p>
<p><strong>波特率</strong>：每秒发送的符号（baund）数量</p>
<p>当一个符号只包含两种可能，即一个事件两种可能，那么此时的波特率等于比特率。</p>
<ul>
<li>确定收到几位数据是通过波特率来数的</li>
<li>串口发送不允许一次发送多个字节， 为了防止累计误差的出现，一旦出现一位错误，后续全错</li>
</ul>
<h3 id="1-2-UART-帧格式"><a href="#1-2-UART-帧格式" class="headerlink" title="1.2 UART 帧格式"></a>1.2 UART 帧格式</h3><p><img src="/MD_IMG/UART.assets/image-20220313170242990.png" alt="image-20220313170242990"></p>
<ul>
<li><strong>起始位</strong>：发送1位逻辑0（低电平），开始传输数据。</li>
<li><strong>数据位</strong>：可以是5-8位的数据，先发低位，再发高位，一般常见的就是8位（1个字节），其他的如7位的ASCII码。</li>
<li><strong>校验位</strong>：奇偶校验，将数据位加上校验位，1的位数为偶数（偶校验） ，1的位数为奇数（奇校<br>验）。</li>
<li><strong>停止位</strong>：停止位是数据传输结束的标志，可以是1&#x2F;1.5&#x2F;2位的逻辑1（高电平）。</li>
<li><strong>空闲位</strong>：空闲时数据线为高电平状态，代表无数据传输。</li>
</ul>
<h3 id="1-3-UART-缺点"><a href="#1-3-UART-缺点" class="headerlink" title="1.3 UART 缺点"></a>1.3 UART 缺点</h3><ol>
<li><p>电气接口不统一</p>
<ul>
<li><p>UART只是对<strong>信号的时序</strong>进行了定义，而未定义接口的<strong>电气特性</strong>；</p>
</li>
<li><p>UART通信时一般直接使用<strong>处理器使用的电平，即TTL电平，</strong>但不同的处理器使用的电平存在差异，所以不同的处理器使用UART通信时一般不能直接相连；</p>
</li>
<li><p>UART没有规定不同器件连接时连接器的标准，所以不同器件之间通过UART通信时连接很不方便；</p>
</li>
</ul>
</li>
<li><p>抗干扰能力差</p>
<p>UART一般直接使用TTL信号来表示0和1，但TTL信号的抗干扰能力较差，数据在传输过程中很容易出错</p>
</li>
<li><p>通信距离极短</p>
<p>因为TTL信号的抗干扰能力较差，所以其通信距离也很短，一般只能用于一个电路板上的两个不芯片之间的通信</p>
</li>
</ol>
<h3 id="1-4-Verilog-代码"><a href="#1-4-Verilog-代码" class="headerlink" title="1.4 Verilog 代码"></a>1.4 Verilog 代码</h3><p>常用的波特率标准有：</p>
<ul>
<li>1200 bps</li>
<li>9600 bps (常用)</li>
<li>38400 bps</li>
<li>115200 bps (常用，而且通常情况下能用的最快的波特率)</li>
</ul>
<p>波特率为115200bps 时，每个bit需要 (1&#x2F;115200)&#x3D;8.7us，在不考虑奇偶校验位的情况下，发送一个字节还需要发送额外的1个起始位和1个停止位，所以发送1个字节实际所需要的最少时间是10*8.7us&#x3D;87us，这意味着1s（1000000us）中能发送的字节数为 (1000000&#x2F;87)&#x3D;11494，所以在波特率为115200bps的情况下，串口传输数据的速率约为11.5KB&#x2F;S。而有些电脑的串口有时候需要一个更长的停止位，比如1.5位或2位的停止位，那么发送一个字节所需要的时间比只有一个比特停止位的情况所耗费的时间更长，在这种情况下，串口的传输速率会低于10.5KB&#x2F;S。</p>
<p>通过上面一系列的总结以后，可以得出FPGA与PC之间的串口通信主要包括三个模块<strong>：波特率产生模块、发射模块和接收模块</strong>。</p>
<h2 id="2-RS232、RS485-协议原理"><a href="#2-RS232、RS485-协议原理" class="headerlink" title="2. RS232、RS485 协议原理"></a>2. RS232、RS485 协议原理</h2><p>RS232 和 RS485 协议是基于串口，收发时序和串口一样，只是在电气上加以规定，让传输距离更远，抗干扰能力更强。</p>
<h3 id="2-1-RS232-协议简介"><a href="#2-1-RS232-协议简介" class="headerlink" title="2.1 RS232 协议简介"></a>2.1 RS232 协议简介</h3><p><strong>RS232协议是</strong>在1970年由美国电子工业协会（EIA）联合贝尔系统、调制解调器厂家、计算机终端生产厂家共同制定的<strong>用于串行通讯的标准</strong>；该标准规定采用一个<strong>标准的连接器</strong>，标准中对连接器的<strong>每个引脚的作用加以规定</strong>，还对信号的<strong>电平加以规定</strong>；</p>
<h4 id="2-1-1-RS232-接口"><a href="#2-1-1-RS232-接口" class="headerlink" title="2.1.1 RS232 接口"></a>2.1.1 RS232 接口</h4><p>该<u>标准规定采用一个25引脚的DB-25连接器</u>，标准中对连接器的每个引脚的信号内容加以规定，还对各种信号的电平加以规定；后来<u>IBM的PC机将RS232简化成了<strong>DB-9连接器</strong></u>，后来成为事实标准；现在工业控制的<strong>RS-232接口一般只使用RXD(PIN2)、TXD(PIN3)、GND(PIN5)三条线</strong>；</p>
<p><img src="/MD_IMG/UART.assets/1426240-20180908161719368-241377247.jpg" alt="img"></p>
<h4 id="2-1-2-RS232-信号"><a href="#2-1-2-RS232-信号" class="headerlink" title="2.1.2 RS232 信号"></a>2.1.2 RS232 信号</h4><p>该标准规定<strong>逻辑 “1” 的电平为 -5v 到 -15v，逻辑 “0” 的电平为 +5v 到 +15v</strong>，选用该电气标准的目的在于提高抗干扰能力，增大通信距离，其传送距离一般可达15m；</p>
<ul>
<li>电平转换：虽然很多处理器中都会集成UART控制器，但处理器产生的信号一般都是TTL信号并不是符合RS232标准的信号，所以一般我们还需要在处理器外部去添加电路对信号的电平进行转换；</li>
</ul>
<h4 id="2-1-3-RS232-缺点"><a href="#2-1-3-RS232-缺点" class="headerlink" title="2.1.3 RS232 缺点"></a>2.1.3 RS232 缺点</h4><ul>
<li>接口的信号电平值较高，易损坏接口电路的芯片，又因为与TTL电平不兼容，所以需要使用电平转换芯片才能与TTL电路连接</li>
<li>通信速度较低</li>
<li>易产生共模干扰，抗噪声干扰性弱</li>
<li>传输距离较短（15m）</li>
</ul>
<h3 id="2-2-RS485"><a href="#2-2-RS485" class="headerlink" title="2.2 RS485"></a>2.2 RS485</h3><h4 id="2-2-1-RS485协议简介"><a href="#2-2-1-RS485协议简介" class="headerlink" title="2.2.1 RS485协议简介"></a>2.2.1 RS485协议简介</h4><p>该标准由电信行业协会和电子工业联盟定义；使用该标准的通信网络能在<strong>远距离条件下以及电子噪声大的环境下有效传输信号</strong>；该标准<strong>允许连接多个收发器</strong>，即具有多站能力，这样可以利用单一的RS485接口方便地建立起一个设备网络。 </p>
<h4 id="2-2-2-RS458-信号"><a href="#2-2-2-RS458-信号" class="headerlink" title="2.2.2 RS458 信号"></a>2.2.2 RS458 信号</h4><p><strong>RS485标准规定采用差分信号进行数据传输，两线间的电压差为 +2v 到 +6v 表示逻辑 “1”，两线间的电压差为 -2v 到 -6v 表示逻辑 “0”</strong> ；使用差分信号能有效地减少噪声信号的干扰，延长通信距离， RS485的通信距离可以达到1500m； RS485接口信号的电平比RS232降低了，所以不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便地与TTL电路连接。</p>
<h4 id="2-2-3-RS458-接口"><a href="#2-2-3-RS458-接口" class="headerlink" title="2.2.3 RS458 接口"></a>2.2.3 RS458 接口</h4><p><strong>RS485采用两线制</strong>，这种接线方式为总线式拓扑结构，在同一总线上可以同时存在多个节点；<br>因为采用两线制，数据的发送和接收都要使用这对差分信号线，发送和接收不能同时进行，所以<strong>只能采用半双工的方式工作</strong>，编程时也需要加以处理</p>
<ul>
<li>电平转换：虽然很多处理器中都会集成UART控制器，但处理器产生的信号一般都是TTL信号并不是符合RS485标准的信号，所以一般我们还需要在处理器外部去添加电路将TTL信号转换成差分信号；</li>
</ul>
<h4 id="2-2-4-RS485-优点"><a href="#2-2-4-RS485-优点" class="headerlink" title="2.2.4 RS485 优点"></a>2.2.4 RS485 优点</h4><ul>
<li>接口的信号电平值较低，不易损坏接口电路的芯片，且与TTL电平兼容，可方便地与TTL电路连接;</li>
<li>通信速度快;</li>
<li>抗噪声干扰性强;</li>
<li>传输距离较远（1500m）;</li>
<li>可实现多节点组网.</li>
</ul>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>UART</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI</title>
    <url>/2023/07/08/SPI/</url>
    <content><![CDATA[<h2 id="SPI-简介"><a href="#SPI-简介" class="headerlink" title="SPI 简介"></a>SPI 简介</h2><p>SPI（Serial Peripheral Interface）是串行外设接口的缩写，SPI是一种<strong>高速</strong>的、<strong>全双工</strong>、同步的<strong>串行</strong>通信总线；SPI采用<strong>主从方式工作</strong>，一般有一个主设备和一个或多个从设备；SPI需要至少4根线，分别是MISO（主设备输入从设备输出）、MOSI（主设备输出从设备输入）、SCLK（时钟）、CS（片选）。SPI使用引脚较少且布线方便，所以越来越多的芯片集成了这种通信协议；</p>
<p><img src="/MD_IMG/SPI.assets/image-20220312222125089.png" alt="image-20220312222125089"></p>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>当主设备要和某个从设备进行通信时，主设备需要先向对应从设备的片选线上发送使能信号（高电平或者低电平，根据从机而定）表示选中该从设备。</p>
<img src="/MD_IMG/SPI.assets/image-20220312222945829.png" alt="image-20220312222945829" style="zoom:80%;" />

<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>SPI总线在进行数据传送时，<strong>先传送高位，后传送低位</strong>；数据线为高电平表示逻辑‘1’，低电平表示逻辑‘0’；**<u>一个字节传送完成后无需应答即可开始下一个字节的传送</u>**；SPI总线采用同步方式工作，时钟线在上升沿或下降沿时发送器向数据线上发送数据，在紧接着的下降沿或上升沿时接收器从数据线上读取数据，完成一位数据传送，八个时钟周期即可完成一个字节数据的传送；</p>
<p><img src="/MD_IMG/SPI.assets/image-20220312223353824.png" alt="image-20220312223353824"></p>
<h2 id="极性和相位"><a href="#极性和相位" class="headerlink" title="极性和相位"></a>极性和相位</h2><p>SPI总线有<strong>四种</strong>不同的<strong>工作模式</strong>，取决于极性（CPOL）和相位（CPHL）这两个因素。</p>
<ul>
<li>CPOL表示SCLK空闲时的状态<ul>
<li>CPOL&#x3D;0，空闲时SCLK为低电平</li>
<li>CPOL&#x3D;1，空闲时SCLK为高电平</li>
</ul>
</li>
<li>CPHA表示采样时刻<ul>
<li>CPHA&#x3D;0，每个周期的第一个时钟沿采样</li>
<li>CPHA&#x3D;1，每个周期的第二个时钟沿采样</li>
</ul>
</li>
</ul>
<ol>
<li>CPOL &#x3D; 0, CPHA &#x3D; 0</li>
</ol>
<p><img src="/MD_IMG/SPI.assets/image-20220312224813999.png" alt="image-20220312224813999"></p>
<ol start="2">
<li>CPOL &#x3D; 0, CPHA &#x3D; 1</li>
</ol>
<p><img src="/MD_IMG/SPI.assets/image-20220312225005800.png" alt="image-20220312225005800"></p>
<ol start="3">
<li>CPOL &#x3D; 1, CPHA &#x3D; 0</li>
</ol>
<p><img src="/MD_IMG/SPI.assets/image-20220313140407142.png" alt="image-20220313140407142"></p>
<ol start="3">
<li>CPOL &#x3D; 1, CPHA &#x3D; 1</li>
</ol>
<p><img src="/MD_IMG/SPI.assets/image-20220313140009027.png" alt="image-20220313140009027"></p>
<p>需要说明的是，对于一个特定的从设备来说，一般在出厂时就会将其设计为某种特定的工作模式；我们在使用该设备时就必须保证主设备的工作模式和该从设备保持力致，否则是无法进行通信的；所以一般我们需要对主设备的CPOL和CPHA进行配置。</p>
<h2 id="IIC-和-SPI-的异同"><a href="#IIC-和-SPI-的异同" class="headerlink" title="IIC 和 SPI 的异同"></a>IIC 和 SPI 的异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol>
<li>均采用串行、同步的方式</li>
<li>均采用TTL电平，传输距离和应用场景类似</li>
<li>均采用主从方式工作</li>
</ol>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol>
<li><p>IIC为半双工， SPI为全双工</p>
</li>
<li><p>IIC有应答机制， SPI无应答机制</p>
</li>
<li><p>IIC通过向总线广播从机地址来寻址， SPI通过向对应从机发送使能信号来寻址</p>
</li>
<li><p>IIC的时钟极性和时钟相位固定， SP I的时钟极性和时钟相位可调</p>
</li>
</ol>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>VHDL</title>
    <url>/2023/07/08/VHDL/</url>
    <content><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ul>
<li>代码不区分大小写</li>
<li>两个减号为单行注释</li>
<li>电路功能分为顺序语句和并行语句两种</li>
</ul>
<h2 id="库Library"><a href="#库Library" class="headerlink" title="库Library"></a>库Library</h2><ul>
<li><p>存放<strong>已编译</strong>程序包和数据集合的地方，可以被调用</p>
</li>
<li><p>代码格式</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> 库名;</span><br><span class="line"><span class="keyword">use</span> 库名中的逻辑体名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实例</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> ieee;                  <span class="comment">--打开ieee库</span></span><br><span class="line"><span class="keyword">use</span> ieee.std_logic_1164.<span class="keyword">all</span>;   <span class="comment">--加载ieee中std_logic_1164包内的所有内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>库的种类</p>
<ul>
<li>STD库 - VHDL标准库</li>
<li>IEEE库 - VHDL标准库的扩展</li>
<li>WORK库 - 用户自己的库</li>
</ul>
</li>
<li><p><strong>3个常用的库</strong></p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> ieee;</span><br><span class="line"><span class="keyword">use</span> ieee.std_logic_1164.<span class="keyword">all</span>; <span class="comment">--包含std_logic、std_vector等类型定义及其相关逻辑类子程序定义</span></span><br><span class="line"><span class="keyword">use</span> ieee.std_logic_arith.<span class="keyword">all</span>; <span class="comment">--包括std_logic类型数据的算术运算子程序定义。（如+、-、*、移位、比较等）</span></span><br><span class="line"><span class="keyword">use</span> ieee.std_logic_unsigned.<span class="keyword">all</span>; <span class="comment">--std_logic_vector类型的无符号数算术运算子程序定义</span></span><br><span class="line"><span class="keyword">use</span> work.PCK_CRC32_D8.<span class="keyword">all</span>;<span class="comment">--用户自己的库</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义库（程序包的使用）"><a href="#自定义库（程序包的使用）" class="headerlink" title="自定义库（程序包的使用）"></a>自定义库（程序包的使用）</h3><p>VHDL中默认一个work库作为用户的project的设计库，用户可以通过定义PACKAGE（程序包）来定义work库中的内容。</p>
<p><strong>程序号（PACKAGE）的定义分为两部分内容：包首部分和包体部分</strong></p>
<ol>
<li><p>包首部分</p>
 <figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> &lt;程序包名称&gt;  <span class="keyword">is</span></span><br><span class="line"><span class="comment">--包首说明 ：定义数据类型、元件和子程序等</span></span><br><span class="line"><span class="keyword">end</span> &lt;程序包名称&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>包体部分</p>
 <figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">body</span> &lt;程序包名称&gt;  <span class="keyword">is</span></span><br><span class="line"><span class="comment">--包体说明语句 ：描述元件和子程序内容</span></span><br><span class="line"><span class="keyword">end</span> &lt;程序包名称&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> IEEE;</span><br><span class="line"><span class="keyword">use</span> IEEE.std_logic_1164.<span class="keyword">all</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> PCK_bk_serdes <span class="keyword">is</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constant</span> FRM_VID   : <span class="built_in">std_logic_vector</span>(<span class="number">8</span>-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>):= X<span class="string">&quot;00&quot;</span>;</span><br><span class="line"><span class="keyword">constant</span> FRM_VSYNC : <span class="built_in">std_logic_vector</span>(<span class="number">8</span>-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>):= X<span class="string">&quot;01&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>  PCK_bk_serdes;</span><br><span class="line"><span class="comment">----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">package</span> <span class="keyword">body</span> PCK_bk_serdes <span class="keyword">is</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> PCK_bk_serdes;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="实体Entity"><a href="#实体Entity" class="headerlink" title="实体Entity"></a>实体Entity</h2><ul>
<li><p>实体用于描述所设计系统的外部接口信号</p>
</li>
<li><p>格式</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">entity</span> entity_name <span class="keyword">is</span></span><br><span class="line"><span class="keyword">generic</span>(</span><br><span class="line">	parameter_name : 数据类型 := default_value;</span><br><span class="line">    parameter_name : 数据类型 := default_value</span><br><span class="line">);</span><br><span class="line"><span class="keyword">port</span>(</span><br><span class="line">	port_name : 方向	数据类型;</span><br><span class="line">    port_name : 方向	数据类型</span><br><span class="line">);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">entity</span> entity_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>端口方向</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span>     - 输入端口，此类型的信号不能被赋值</span><br><span class="line"><span class="keyword">out</span>    - 输出端口</span><br><span class="line"><span class="keyword">inout</span>  - 双向端口</span><br><span class="line"><span class="keyword">buffer</span> - 缓冲端口</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">entity</span> entity_name <span class="keyword">is</span></span><br><span class="line"><span class="keyword">port</span>(</span><br><span class="line">	sysclk : <span class="keyword">in</span>  <span class="built_in">std_logic</span>;</span><br><span class="line">    nRST   : <span class="keyword">in</span>  <span class="built_in">std_logic</span>;</span><br><span class="line">    </span><br><span class="line">    led    : <span class="keyword">out</span> <span class="built_in">std_logic</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">entity</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="结构体Architecture"><a href="#结构体Architecture" class="headerlink" title="结构体Architecture"></a>结构体Architecture</h2><ul>
<li><p>构造体用于描述实体所代表的系统内部结构和行为</p>
</li>
<li><p>代码格式</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">architecture</span> 结构体名 <span class="keyword">of</span> 实体名 <span class="keyword">is</span></span><br><span class="line">	[说明语句]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	[功能描述语句]</span><br><span class="line"><span class="keyword">end</span> 结构体名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明语句包括了内部信号、常数、元件、数据类型、函数定义</p>
</li>
</ul>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><h3 id="常量Constant"><a href="#常量Constant" class="headerlink" title="常量Constant"></a>常量Constant</h3><ul>
<li><p>常量声明格式</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constant</span> 常量名 : 数据类型 [:= 初始值];</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在library&#x2F;entity&#x2F;architecture&#x2F;process中定义</p>
</li>
</ul>
<h3 id="变量Variable"><a href="#变量Variable" class="headerlink" title="变量Variable"></a>变量Variable</h3><ul>
<li><p>变量声明格式</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">variable</span> 变量名 : 数据类型 [取值范围] [:= 初始值];</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量是<strong>局部量</strong>，只能在进程process和子程序中使用</p>
</li>
<li><p>变量的赋值是理想的，没有延时（即使用组合逻辑实现而不是时序逻辑）</p>
</li>
<li><p>变量赋值符号为<code>:=</code></p>
</li>
<li><p><strong>有些变量类型需要声明范围</strong>，比如integer类型就需要。而std_logic类型就不需要（std_logic取值范围比较小，而integer取值范围很大，手动声明范围可以减少元件的使用）</p>
</li>
<li><p>带取值范围的变量声明举例</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">variable</span> x, y : <span class="built_in">integer</span> <span class="keyword">range</span> <span class="number">15</span> <span class="keyword">downto</span> <span class="number">0</span> := <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="信号Signal"><a href="#信号Signal" class="headerlink" title="信号Signal"></a>信号Signal</h3><ul>
<li><p>在architecture中定义</p>
</li>
<li><p><strong>信号赋值符号为</strong><code>&lt;=</code>，<strong>但是初始化符号是</strong><code>:=</code></p>
</li>
<li><p>信号声明格式</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signal</span> 信号名 : 数据类型 [:= 初始值];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>常用数据类型</p>
<ul>
<li>标准逻辑				std_logic</li>
<li>标准逻辑序列 	   std_logic_vector</li>
<li>整数                        integer</li>
</ul>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constant</span>	CLK_NUM		: <span class="built_in">integer</span>	:= <span class="number">3</span>;</span><br><span class="line"><span class="keyword">constant</span>	CLK_NUM		: <span class="built_in">std_logic_vector</span>(<span class="number">3</span> <span class="keyword">downto</span> <span class="number">0</span>) := X<span class="string">&quot;3&quot;</span>;</span><br><span class="line"><span class="keyword">signal</span>		clk_en		: <span class="built_in">std_logic</span>;</span><br><span class="line"><span class="keyword">signal</span>		clk_cnt		: <span class="built_in">std_logic_vector</span>(<span class="number">7</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">signal</span>      num         : <span class="built_in">integer</span> <span class="keyword">range</span> <span class="number">0</span> <span class="keyword">to</span> <span class="number">15</span>;<span class="comment">--信号num的取值范围是0-15，可用4位二进制表示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ARRAY_3xVID_NUM  <span class="keyword">is</span> <span class="keyword">array</span> (<span class="number">0</span> <span class="keyword">to</span> VID_NUM-<span class="number">1</span>)  <span class="keyword">of</span> <span class="built_in">std_logic_vector</span>(<span class="number">2</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">signal</span> vsync_meta : ARRAY_3xVID_NUM;</span><br><span class="line"><span class="comment">------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="keyword">to</span> VID_NUM-<span class="number">1</span> <span class="keyword">loop</span></span><br><span class="line">    vsync_meta(i) &lt;= vsync_meta(i)(<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>)&amp;vsync_in(i);</span><br><span class="line">    <span class="keyword">if</span> vsync_meta(i)(<span class="number">2</span> <span class="keyword">downto</span> <span class="number">1</span>) = <span class="string">&quot;10&quot;</span> <span class="keyword">then</span></span><br><span class="line">        vsync_neg(i) &lt;= <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        vsync_neg(i) &lt;= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li>use IEEE.std_logic_1164.all</li>
</ul>
<table>
<thead>
<tr>
<th>转换函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>to_std_logic_vector</td>
<td>将 bit_vector 转换为 std_logic_vector</td>
</tr>
<tr>
<td>to_bit_vector</td>
<td>将 std_logic_vector 转换为 bit_vector</td>
</tr>
<tr>
<td>to_std_logic</td>
<td>将 bit 转换为 std_logic</td>
</tr>
<tr>
<td>to_bit</td>
<td>将 std_logic 转换为 bit</td>
</tr>
</tbody></table>
<ul>
<li>use IEEE.std_logic_arith.all</li>
</ul>
<table>
<thead>
<tr>
<th>转换函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>conv_std_logic_vector</td>
<td>将 integer、unsigned、signed 转换为 std_logic_vector</td>
</tr>
<tr>
<td>to_bit_vector</td>
<td>将 std_logic_vector 转换为 bit_vector</td>
</tr>
</tbody></table>
<ul>
<li>use IEEE.std_logic_unsigned.all</li>
</ul>
<table>
<thead>
<tr>
<th>转换函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>conv_integer</td>
<td>将 std_logic_vector 转换为 integer</td>
</tr>
</tbody></table>
<h2 id="信号运算"><a href="#信号运算" class="headerlink" title="信号运算"></a>信号运算</h2><ul>
<li><p>信号赋值：<code>&lt;=</code>  例： x &lt;&#x3D; ‘1’</p>
</li>
<li><p>逻辑运算符： <code>and</code>、<code>or</code>、<code>not</code>、<code>xor</code>异或、<code>xnor</code> 同或、<code>nand</code>与非、<code>nor</code>或非 </p>
<ul>
<li>例： x &lt;&#x3D; not y;  x &lt;&#x3D; y and z;  …</li>
</ul>
</li>
<li><p>算术运算符：<code>+</code> 加、<code>-</code> 减、<code>*</code> 乘、<code>/</code> 除、 <code>**</code> 乘方、 <code>mod</code> 取模、 <code>rem</code> 取余、 <code>sll</code> 逻辑左移、 <code>srl</code> 逻辑右移、 <code>sla</code> 算数左移、 <code>sra</code> 算数右移、 <code>rol</code> 逻辑循环左移、 <code>ror</code> 逻辑循环右移、<code>abs</code> 取绝对值</p>
</li>
<li><p>关系运算符：<code> =</code>、<code> /=</code>、<code>&gt;</code>、 <code>&lt;</code>、<code> &gt;=</code> 、 <code>&lt;=</code></p>
</li>
<li><p>位拼接运算：<code> &amp;</code></p>
</li>
</ul>
<h2 id="并行语句"><a href="#并行语句" class="headerlink" title="并行语句"></a>并行语句</h2><ul>
<li><p>在结构体语句中，并行语句的位置为</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">architecture</span> 结构体名 <span class="keyword">of</span> 实体名 <span class="keyword">is</span></span><br><span class="line">	[说明语句]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	[并行语句]</span><br><span class="line"><span class="keyword">end</span> 结构体名;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="进程语句-process"><a href="#进程语句-process" class="headerlink" title="进程语句-process"></a>进程语句-process</h3><ul>
<li><p>进程描述格式</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">process</span> (sensitivity list)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">--功能代码</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程由敏感信号变化启动</strong></p>
</li>
<li><p>进程内语句为顺序语句，但结构体内的不同进程是并行的，各个进程根据敏感信号独立运行</p>
</li>
</ul>
<h3 id="参数传递语句-generic"><a href="#参数传递语句-generic" class="headerlink" title="参数传递语句-generic"></a>参数传递语句-generic</h3><ul>
<li><p>参数传递语句（GENERIC）主要用来传递信息给设计实体的某个具体元件，如用来定义端口宽度、器件延迟时间等参数后，并将这些参数传递给设计实体</p>
</li>
<li><p>使用参数传递语句易于使设计具有通用性</p>
</li>
<li><p>格式</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">generic</span>(常数名 数据类型 := 设定值);</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景</p>
<ul>
<li>定义实体的端口大小</li>
<li>设计实体的物理特征；传输延迟，上升和下降延迟等</li>
<li>结构体的总线宽度</li>
<li>设计实体中底层中同种原件的例化数量</li>
</ul>
</li>
</ul>
<h3 id="元件例化语句-component"><a href="#元件例化语句-component" class="headerlink" title="元件例化语句-component"></a>元件例化语句-component</h3><h4 id="元件声明格式"><a href="#元件声明格式" class="headerlink" title="元件声明格式"></a>元件声明格式</h4><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">component</span> 元件名</span><br><span class="line"><span class="keyword">generic</span>(</span><br><span class="line">	NUM1 : <span class="built_in">integer</span>:= <span class="number">1</span>; <span class="comment">--参数说明1;</span></span><br><span class="line">    NUM2 : <span class="built_in">integer</span>:= <span class="number">2</span>  <span class="comment">--参数说明2</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">port</span>(</span><br><span class="line">    port1 :<span class="keyword">in</span>  <span class="built_in">std_logic</span>;<span class="comment">--端口说明1;</span></span><br><span class="line">    port2 :<span class="keyword">out</span> <span class="built_in">std_logic_vector</span>(NUM2-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>)<span class="comment">--端口说明2</span></span><br><span class="line">);<span class="keyword">end</span> <span class="keyword">component</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意分号的位置；端口说明中的参数为该元件参数</strong></p>
<h4 id="元件例化格式"><a href="#元件例化格式" class="headerlink" title="元件例化格式"></a>元件例化格式</h4><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">module1_inst:元件名</span><br><span class="line"><span class="keyword">generic</span> <span class="keyword">map</span>(</span><br><span class="line">    NUM1 =&gt; NUM3, <span class="comment">--参数映射</span></span><br><span class="line">    NUM2 =&gt; NUM4</span><br><span class="line">)</span><br><span class="line"><span class="keyword">port</span> <span class="keyword">map</span>(</span><br><span class="line">    port3 =&gt;port1,<span class="comment">--端口映射</span></span><br><span class="line">    port4 =&gt;port2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="生成语句-generate"><a href="#生成语句-generate" class="headerlink" title="生成语句-generate"></a>生成语句-generate</h3><ul>
<li><p>GENERATE 语句用来产生多个相同的结构和描述规则结构，如阵列、元件例化和进程</p>
</li>
<li><p><strong>for…generate</strong>语句设计<strong>规则体</strong>，<strong>不规则体</strong>可用<strong>if…generate</strong>语句</p>
</li>
</ul>
<h4 id="for…generate"><a href="#for…generate" class="headerlink" title="for…generate"></a>for…generate</h4><ul>
<li><p>该生成语句用于描述多重模式，结构中所列举的是并发处理语句。这些语句并发执行而不是顺序执行，因此结构中不能用EXIT和NEXT语句</p>
</li>
<li><p>格式：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">标号：<span class="keyword">for</span> 变量 <span class="keyword">in</span> 不连续区间 <span class="keyword">generate</span></span><br><span class="line">&lt;并发处理的生成语句&gt;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">generate</span> [标号名]；</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="if…generate"><a href="#if…generate" class="headerlink" title="if…generate"></a>if…generate</h4><ul>
<li><p>该语句用于描述结构的例外情况，如边界处发生的特殊情况</p>
</li>
<li><p>格式：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">标号：<span class="keyword">if</span> 条件 <span class="keyword">generate</span></span><br><span class="line">&lt;并发处理的生成语句&gt;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">generate</span> [标号名]；</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="块语句-block"><a href="#块语句-block" class="headerlink" title="块语句-block"></a>块语句-block</h3><ul>
<li><p>块（BLOCK）语句可以看作是结构体中的子模块，块语句把许多并行语句组合在一起形成一个子模块，而它本身也是一个并行语句</p>
</li>
<li><p>格式</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">块结构名：</span><br><span class="line"><span class="keyword">BLOCK</span> </span><br><span class="line">端口说明 类属说明</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">并行语句</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">BLOCK</span> 块结构名;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="信号赋值语句"><a href="#信号赋值语句" class="headerlink" title="信号赋值语句"></a>信号赋值语句</h3><h4 id="简单信号赋值-lt-x3D"><a href="#简单信号赋值-lt-x3D" class="headerlink" title="简单信号赋值 &lt;&#x3D;"></a>简单信号赋值 &lt;&#x3D;</h4><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">Sginal_name &lt;= expression;</span><br></pre></td></tr></table></figure>

<h4 id="条件信号赋值-when…else…"><a href="#条件信号赋值-when…else…" class="headerlink" title="条件信号赋值 when…else…"></a>条件信号赋值 when…else…</h4><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">Sginal_name &lt;= value_a <span class="keyword">when</span> condition1 <span class="keyword">else</span></span><br><span class="line">               value_b <span class="keyword">when</span> condition2 <span class="keyword">else</span></span><br><span class="line">               value_c;</span><br><span class="line"><span class="comment">--Example</span></span><br><span class="line">Rd_en &lt;= <span class="string">&#x27;1&#x27;</span> <span class="keyword">when</span> (Rd_empty = <span class="string">&#x27;0&#x27;</span>) <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="选择信号赋值-with…select…when"><a href="#选择信号赋值-with…select…when" class="headerlink" title="选择信号赋值 with…select…when"></a>选择信号赋值 with…select…when</h4><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> selection_signal <span class="keyword">select</span> </span><br><span class="line">    Select_name &lt;= value_a <span class="keyword">when</span> value_1_of_selection_signal,</span><br><span class="line">                    value_b <span class="keyword">when</span> value_2_of_selection_signal,</span><br><span class="line">                    value_c <span class="keyword">when</span> <span class="keyword">others</span>;</span><br><span class="line"><span class="comment">--Example</span></span><br><span class="line"><span class="keyword">with</span> S <span class="keyword">select</span></span><br><span class="line">    X &lt;= A <span class="keyword">when</span> <span class="string">&quot;00&quot;</span>|<span class="string">&quot;10&quot;</span>,</span><br><span class="line">         B <span class="keyword">when</span> <span class="string">&quot;01&quot;</span>,</span><br><span class="line">         C <span class="keyword">when</span> <span class="keyword">others</span>;</span><br></pre></td></tr></table></figure>

<p>选择信号赋值语句<strong>不允许条件重叠或条件涵盖不全</strong>，注意区分逗号和分号</p>
<h2 id="顺序语句"><a href="#顺序语句" class="headerlink" title="顺序语句"></a>顺序语句</h2><h3 id="顺序语句-进程语句"><a href="#顺序语句-进程语句" class="headerlink" title="顺序语句 - 进程语句"></a>顺序语句 - 进程语句</h3><p>进程描述格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[进程标签 :] process (敏感信号参数表)</span><br><span class="line">	[进程说明]</span><br><span class="line">begin</span><br><span class="line">	[顺序描述语句]</span><br><span class="line">end process</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>进程由敏感信号变化启动</strong></li>
<li>进程内语句为顺序语句，但构造体内的不同进程是并行的，各个进程根据敏感信号独立运行</li>
<li>时序电路中CLK信号常为敏感信号</li>
</ul>
<h3 id="常见顺序语句"><a href="#常见顺序语句" class="headerlink" title="常见顺序语句"></a>常见顺序语句</h3><h4 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h4><p>变量赋值与信号赋值</p>
<h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h4><ul>
<li><p>分支少、具有优先级时候使用</p>
</li>
<li><p>if 必须有一个 else 对应（除下面情况可不写 else 语句）,当没有 else 语句，将产生不希望的存储器</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">process</span>(Clk,Rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(Rst = <span class="string">&#x27;1&#x27;</span>)<span class="keyword">then</span></span><br><span class="line">        Q &lt;= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">elsif</span> rising_edge(Clk) <span class="keyword">then</span></span><br><span class="line">        Q &lt;= D;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="case-when-语句"><a href="#case-when-语句" class="headerlink" title="case - when 语句"></a>case - when 语句</h4><ul>
<li><p>在多条分支的时候使用</p>
</li>
<li><p>case-when 语句必须有 when others 支项</p>
</li>
<li><p>这里的<code>=&gt;</code>不是操作符，相当于then</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> Selection_signal <span class="keyword">is</span></span><br><span class="line">	<span class="keyword">when</span> value1_of_selction sigal =&gt; </span><br><span class="line">    	Statements1;</span><br><span class="line">	<span class="keyword">when</span> value2_of_selction sigal =&gt; </span><br><span class="line">    	Statements2;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">when</span> <span class="keyword">others</span> =&gt; <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="for…loop语句"><a href="#for…loop语句" class="headerlink" title="for…loop语句"></a>for…loop语句</h4><ul>
<li><p>在重复操作时使用</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">process</span>(signal1,signal2)</span><br><span class="line">beign</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> 开始值 <span class="keyword">to</span> 结束值 <span class="keyword">loop</span></span><br><span class="line">        <span class="comment">--功能代码</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="时序逻辑相关"><a href="#时序逻辑相关" class="headerlink" title="时序逻辑相关"></a>时序逻辑相关</h2><ul>
<li><p>上升沿的描述：<code>rising_edge(clk)</code></p>
</li>
<li><p>状态机定义</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> state <span class="keyword">is</span>(</span><br><span class="line">	INIT,</span><br><span class="line">    REC_DATA,</span><br><span class="line">    SEND_DATA,</span><br><span class="line">    TAIL</span><br><span class="line">);</span><br><span class="line"><span class="keyword">signal</span> pstate		: state := INIT;</span><br></pre></td></tr></table></figure></li>
<li><p>时钟：一定频率的方波</p>
</li>
<li><p><strong>组合逻辑</strong>：输出只由输入决定，与时钟无关</p>
<ul>
<li>无时钟边沿敏感</li>
</ul>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">process</span> (A,B)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(A = <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> B = <span class="string">&#x27;0&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">        C &lt;= X<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">elsif</span> (A = <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> B = <span class="string">&#x27;1&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">        C &lt;= X<span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        C &lt;= X<span class="string">&quot;3&quot;</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时序逻辑</strong>：输出不仅由输入决定，还与时钟相关</p>
<ul>
<li>异步复位逻辑</li>
<li>时钟单边沿敏感</li>
</ul>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">process</span> (sysclk, nRST)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (nRST = <span class="string">&#x27;0&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">        C &lt;= X<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">elsif</span> (rising_edge(sysclk)) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span>(A = <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> B = <span class="string">&#x27;0&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">            C &lt;= X<span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">elsif</span> (A = <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> B = <span class="string">&#x27;1&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">            C &lt;= X<span class="string">&quot;2&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            C &lt;= X<span class="string">&quot;3&quot;</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> state <span class="keyword">is</span>(</span><br><span class="line">    IDLE,</span><br><span class="line">    CONFIG,</span><br><span class="line">    DATA,</span><br><span class="line">    DONE</span><br><span class="line">);</span><br><span class="line"><span class="keyword">signal</span> C_S,N_S: state:= IDLE;</span><br><span class="line"></span><br><span class="line">FSM_ONE: <span class="keyword">process</span>(clk)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst = <span class="string">&#x27;1&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">        C_S &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        C_S &lt;= N_S;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>; </span><br><span class="line"></span><br><span class="line">FSM_TWO: <span class="keyword">process</span>(C_S) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">when</span> IDLE =&gt; </span><br><span class="line">        <span class="keyword">if</span> () <span class="keyword">then</span></span><br><span class="line">            N_S = ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            N_S = IDLE;</span><br><span class="line">    <span class="keyword">when</span> <span class="keyword">others</span> =&gt; </span><br><span class="line">            N_S = IDLE;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line"></span><br><span class="line">FSM_THREE: <span class="keyword">process</span>(clk)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst = <span class="string">&#x27;1&#x27;</span>) <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br></pre></td></tr></table></figure>



<h2 id="TEXTIO"><a href="#TEXTIO" class="headerlink" title="TEXTIO"></a>TEXTIO</h2><p>TEXTIO 是VHDL 标准库STD 中的一个程序包（Package）。在该包中定义了三个类型：LINE 类型、TEXT类型以及SIDE 类型。另外，还有一个子类型（subtype）WIDTH。此外，在该程序包中还定义了一些访问文件所必须的过程（Procedure）。</p>
<p>详细见链接：</p>
<p><a href="https://www.cnblogs.com/xiaokai0126/p/3800166.html">VHDL学习之TEXTIO在仿真中的应用 - 蓝旭伯 - 博客园 (cnblogs.com)</a></p>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><ol>
<li><p>rising_edge(clk)  和  (clk’event and clk&#x3D;’1’)的区别</p>
<ul>
<li><p>rising_edg 是非常严格的上升沿，必须从0到1；</p>
</li>
<li><p>(clk’event and clk&#x3D;’1’) 可以从 X 到1，只要当前状态为1，结果就为TRUE，不管前一个状态</p>
</li>
</ul>
</li>
</ol>
<h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><h4 id="标识符（Identifiers）命名习惯"><a href="#标识符（Identifiers）命名习惯" class="headerlink" title="标识符（Identifiers）命名习惯"></a>标识符（Identifiers）命名习惯</h4><h5 id="标识符定义命名"><a href="#标识符定义命名" class="headerlink" title="标识符定义命名"></a>标识符定义命名</h5><ul>
<li><p>标识符第一个字符必须是字母，最后一个字符不能是下划线，不许出现连续两个下划线；</p>
</li>
<li><p>基本标识符只能由字母、数字和下划线组成；</p>
</li>
<li><p>标识符两词之间需用下划线连接</p>
<p>如：Packet_addr    ,  Data_in</p>
</li>
<li><p>标识符不得与保留字同名</p>
</li>
</ul>
<h5 id="标识符大小写"><a href="#标识符大小写" class="headerlink" title="标识符大小写"></a>标识符大小写</h5><ul>
<li>对常量、数据类型、实体名和结构体名采用全部大写；</li>
<li>对变量采用小写；</li>
<li>对信号采用第一个词首字符大写；</li>
<li>保留字一律小写</li>
</ul>
<h5 id="信号名连贯缩写"><a href="#信号名连贯缩写" class="headerlink" title="信号名连贯缩写"></a>信号名连贯缩写</h5><p><strong>部分缩写的统一规定为</strong>：</p>
<p>Addr   address;     Clk   clock;     Clr   clear;     Cnt   counter</p>
<p>En   enable;     Inc   increase;     Lch   latch;     Mem   memory</p>
<p>Pntr   pointer;     Pst   preset;     Rst   reset</p>
<p>Reg   register;     Rd   reader;     Wr   write</p>
<p><strong>常用多个单次的缩写</strong></p>
<p>ROM     RAM     CPU     FIFO     ALU     CS     CE</p>
<p><strong>自定义的缩写必须在文件头注释</strong></p>
<h5 id="信号名缩写的大小写"><a href="#信号名缩写的大小写" class="headerlink" title="信号名缩写的大小写"></a>信号名缩写的大小写</h5><ul>
<li>单次的缩写若是信号名的第一个单次则首字母大写，如：Addr_in 中的 Addr；若该代词缩写不是第一个单词则小写，如：Addr_en 中的 en</li>
<li>多个单次的首字母缩写都大写，不管该缩写在标识符的什么位置，如：RAM_addr，Rd_CPU_en</li>
</ul>
<h5 id="信号名一致性"><a href="#信号名一致性" class="headerlink" title="信号名一致性"></a>信号名一致性</h5><p>同一信号在不同层次应保持一致性</p>
<h5 id="信号命名建议"><a href="#信号命名建议" class="headerlink" title="信号命名建议"></a>信号命名建议</h5><p><img src="/MD_IMG/VHDL%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20220701173324871.png" alt="image-20220701173324871"></p>
<h4 id="其它注意地方"><a href="#其它注意地方" class="headerlink" title="其它注意地方"></a>其它注意地方</h4><ul>
<li>只有三态电路才可以在多个process 中出现</li>
<li>使用 Latch 必须有所记录，不希望使用 Latch 时，应该将条件赋值语句写全，如在 if 语句最后加 else，case 语句后加 others</li>
<li>TAB键的间隔，采用4个字符</li>
<li>若元件的类属在定义时已经指定默认值，在调用时，若不改变该参数值可以不用定义实参的映射，即map（实参）可不写</li>
<li>建议运算操作符两边都加上空格</li>
<li>向量比较时，比较的向量的位宽要相等</li>
<li></li>
</ul>
<h4 id="代码模块划分"><a href="#代码模块划分" class="headerlink" title="代码模块划分"></a>代码模块划分</h4><p>设计模块的基本原则是：</p>
<ol>
<li><p>有利于模块的可重用性</p>
</li>
<li><p>在组合电路设计中应当没有层次</p>
</li>
<li><p>每个模块输出尽量采用寄存器输出</p>
</li>
<li><p>模块按功能进行划分，划分要合理</p>
</li>
<li><p>模块大小应适中，一般为2000门左右</p>
</li>
<li><p>模块的层次应当至少有三级，可将一个设计划分为三个层次：TOP、MID、功能CORE</p>
<ul>
<li><p>TOP</p>
<p>包括实例化的MID和输入输出定义</p>
</li>
<li><p>MID</p>
<p>由两部分组成：1）时钟产生电路；2）功能CORE的实例化</p>
</li>
<li><p>功能CORE</p>
<p>包括各种功能电路的设计。一个复杂的功能可以分成多个子功能来实现，即再划分子层</p>
</li>
</ul>
</li>
</ol>
<h2 id="VHDL保留字"><a href="#VHDL保留字" class="headerlink" title="VHDL保留字"></a>VHDL保留字</h2><p><img src="/MD_IMG/VHDL%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20220701161140457.png" alt="image-20220701161140457"></p>
<h2 id="函数书写实例"><a href="#函数书写实例" class="headerlink" title="函数书写实例"></a>函数书写实例</h2><p>注意：</p>
<ul>
<li>函数参数只能是输入类型，不能被赋值修改</li>
<li>只能有一个返回值</li>
<li>定义函数必须为顺序语句，且其中不能定义新的信号，但可在函数说明域中说明新的变量，并在定义域中对其进行赋值</li>
</ul>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Filename         : FullAdd.vhd</span></span><br><span class="line"><span class="comment">-- Author           : xioaming</span></span><br><span class="line"><span class="comment">-- Description      : A example of function</span></span><br><span class="line"><span class="comment">-- Called by        : Top module</span></span><br><span class="line"><span class="comment">-- Revision History : 2022-07-01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">library</span> IEEE;</span><br><span class="line"><span class="keyword">use</span> IEEE.std_logic_1164.<span class="keyword">all</span>;</span><br><span class="line"><span class="keyword">use</span> IEEE.std_logic_arith.<span class="keyword">all</span>;</span><br><span class="line"><span class="keyword">use</span> IEEE.std_logic_unsigned.<span class="keyword">all</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">entity</span> FULLADD <span class="keyword">is</span></span><br><span class="line"><span class="keyword">port</span>(</span><br><span class="line">    A            :<span class="keyword">in</span>  <span class="built_in">STD_LOGIC</span>;</span><br><span class="line">    B            :<span class="keyword">in</span>  <span class="built_in">STD_LOGIC</span>;</span><br><span class="line">    Carry_in     :<span class="keyword">in</span>  <span class="built_in">STD_LOGIC</span>;</span><br><span class="line">    Sum          :<span class="keyword">out</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line">    Carry_out    :<span class="keyword">out</span> <span class="built_in">STD_LOGIC</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">end</span> FULLADD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">architecture</span> BEHAVIOR <span class="keyword">of</span> FULLADD <span class="keyword">is</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> Majority(A,B,C: <span class="built_in">STD_LOGIC</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">STD_LOGIC</span> <span class="keyword">is</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        reture((A <span class="keyword">and</span> B)<span class="keyword">or</span>(A <span class="keyword">and</span> C)<span class="keyword">or</span>(B <span class="keyword">and</span> C))</span><br><span class="line">    <span class="keyword">end</span> Majority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">    Sum &lt;= A <span class="keyword">xor</span> B <span class="keyword">xor</span> Carry_in;</span><br><span class="line">    Carry_out &lt;= Majority(A,B,Carry_in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> BEHAVIOR;</span><br></pre></td></tr></table></figure>

<h2 id="程序包书写实例"><a href="#程序包书写实例" class="headerlink" title="程序包书写实例"></a>程序包书写实例</h2><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> IEEE;</span><br><span class="line"><span class="keyword">use</span> IEEE.std_logic_1164.<span class="keyword">all</span>;</span><br><span class="line"><span class="keyword">use</span> IEEE.std_logic_unsigned.<span class="keyword">all</span>;</span><br><span class="line"><span class="keyword">use</span> IEEE.std_logic_arith.<span class="keyword">all</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> time_pkg <span class="keyword">is</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constant</span> XX : <span class="built_in">std_logic_vector</span>(<span class="number">7</span> <span class="keyword">downto</span> <span class="number">0</span>):= x<span class="string">&quot;11&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> TP_DATA_12x5bit <span class="keyword">is</span> <span class="keyword">array</span>(<span class="number">0</span> <span class="keyword">downto</span> <span class="number">11</span>) <span class="keyword">of</span> <span class="built_in">std_logic_vector</span>(<span class="number">4</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> TP_UTC_YMD <span class="keyword">is</span></span><br><span class="line">        <span class="keyword">record</span></span><br><span class="line">            yy :<span class="built_in">std_logic_vector</span>(<span class="number">7</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line">            mm :<span class="built_in">std_logic_vector</span>(<span class="number">3</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line">            dd :<span class="built_in">std_logic_vector</span>(<span class="number">4</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">record</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> MULT10(</span><br><span class="line">        din : <span class="keyword">in</span> <span class="built_in">std_logic_vector</span>(<span class="number">3</span> <span class="keyword">downto</span> <span class="number">0</span>)</span><br><span class="line">    )<span class="keyword">return</span> <span class="built_in">std_logic_vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> time_pkg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> <span class="keyword">body</span> time_pkg <span class="keyword">is</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> MULT10(</span><br><span class="line">        din  : <span class="keyword">in</span> <span class="built_in">std_logic_vector</span>(<span class="number">3</span> <span class="keyword">downto</span> <span class="number">0</span>)</span><br><span class="line">    )<span class="keyword">return</span> <span class="built_in">std_logic_vector</span> <span class="keyword">is</span></span><br><span class="line">        <span class="keyword">variable</span> result : <span class="built_in">std_logic_vector</span>(<span class="number">6</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        result := (din &amp; <span class="string">&quot;000&quot;</span>) + (<span class="string">&quot;00&quot;</span> &amp; din &amp; <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">end</span> MULT10;</span><br><span class="line"><span class="keyword">end</span> time_pkg;    </span><br></pre></td></tr></table></figure>

<h3 id="调用程序包"><a href="#调用程序包" class="headerlink" title="调用程序包"></a>调用程序包</h3><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> time_lib;</span><br><span class="line"><span class="keyword">use</span> time_lib.time_pkg.<span class="keyword">all</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参数化元件实例"><a href="#参数化元件实例" class="headerlink" title="参数化元件实例"></a>参数化元件实例</h2><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">component</span> REG_GROUP <span class="keyword">is</span></span><br><span class="line">    <span class="keyword">generic</span>(</span><br><span class="line">        Size : <span class="built_in">INTEGER</span>:= <span class="number">2</span></span><br><span class="line">    );<span class="keyword">port</span>(</span><br><span class="line">        Clk    : <span class="keyword">in</span>  <span class="built_in">STD_LOGIC</span>;</span><br><span class="line">        Rst    : <span class="keyword">in</span>  <span class="built_in">STD_LOGIC</span>;</span><br><span class="line">        Load   : <span class="keyword">in</span>  <span class="built_in">STD_LOGIC</span>;</span><br><span class="line">        D      : <span class="keyword">in</span>  <span class="built_in">STD_LOGIC_VECTOR</span>(Size-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line">        Q      : <span class="keyword">out</span> <span class="built_in">STD_LOGIC_VECTOR</span>(Size-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">component</span>;</span><br><span class="line"></span><br><span class="line">    U_REG_GROUP:REG_GROUP </span><br><span class="line">    <span class="keyword">generic</span> <span class="keyword">map</span>(</span><br><span class="line">        Size =&gt; <span class="number">2</span></span><br><span class="line">    )<span class="keyword">port</span> <span class="keyword">map</span>(</span><br><span class="line">        Clk    =&gt; Clk , </span><br><span class="line">        Rst    =&gt; Rst , </span><br><span class="line">        Load   =&gt; Load,</span><br><span class="line">        D      =&gt; D   ,   </span><br><span class="line">        Q      =&gt; Q   </span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h2 id="VHDL模板"><a href="#VHDL模板" class="headerlink" title="VHDL模板"></a>VHDL模板</h2><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Filename         : Div5.vhd</span></span><br><span class="line"><span class="comment">-- Author           : xioaming</span></span><br><span class="line"><span class="comment">-- Description      : Five division</span></span><br><span class="line"><span class="comment">-- Called by        : Top module</span></span><br><span class="line"><span class="comment">-- Revision History : 2022-07-01</span></span><br><span class="line"><span class="keyword">library</span> ieee;</span><br><span class="line"><span class="keyword">use</span> ieee.std_logic_1164.<span class="keyword">all</span>;</span><br><span class="line"><span class="keyword">use</span> ieee.std_logic_arith.<span class="keyword">all</span>;</span><br><span class="line"><span class="keyword">use</span> ieee.std_logic_unsigned.<span class="keyword">all</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">entity</span> module_name <span class="keyword">is</span></span><br><span class="line"><span class="keyword">generic</span>(</span><br><span class="line">    SIM  : <span class="built_in">std_logic</span>:= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    NUM1 : <span class="built_in">integer</span>:= <span class="number">1</span>;</span><br><span class="line">    NUM2 : <span class="built_in">integer</span>:= <span class="number">2</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">port</span>(</span><br><span class="line">    port1 :<span class="keyword">in</span>  <span class="built_in">std_logic</span>;</span><br><span class="line">    port2 :<span class="keyword">out</span> <span class="built_in">std_logic_vector</span>(NUM1-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">entity</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">architecture</span> BEHAVIOR <span class="keyword">of</span> module_name <span class="keyword">is</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--------------STATE--------------</span></span><br><span class="line"><span class="keyword">type</span> state <span class="keyword">is</span>(</span><br><span class="line">    ST_A,</span><br><span class="line">    ST_B,</span><br><span class="line">    ST_C</span><br><span class="line">);</span><br><span class="line"><span class="keyword">signal</span> pstate : state := ST_A;</span><br><span class="line"><span class="comment">--------------COMPONENT--------------</span></span><br><span class="line"><span class="keyword">component</span> module1 <span class="keyword">is</span></span><br><span class="line"><span class="keyword">generic</span>(</span><br><span class="line">    NUM3 : <span class="built_in">integer</span>:= <span class="number">3</span>;</span><br><span class="line">    NUM4 : <span class="built_in">integer</span>:= <span class="number">4</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">port</span>(</span><br><span class="line">    port3 :<span class="keyword">in</span>  <span class="built_in">std_logic</span>;</span><br><span class="line">    port4 :<span class="keyword">out</span> <span class="built_in">std_logic_vector</span>(NUM3-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">component</span>;</span><br><span class="line"><span class="comment">--------------SIGNAL--------------</span></span><br><span class="line"><span class="keyword">constant</span> NUM5  : <span class="built_in">integer</span>:= <span class="number">5</span>;</span><br><span class="line"><span class="keyword">signal</span> signal1 : <span class="built_in">std_logic</span>;</span><br><span class="line"><span class="keyword">signal</span> signal2 : <span class="built_in">std_logic_vector</span>(NUM5-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"></span><br><span class="line">module1_inst:module1</span><br><span class="line"><span class="keyword">generic</span> <span class="keyword">map</span>(</span><br><span class="line">    NUM3 =&gt; NUM1,</span><br><span class="line">    NUM4 =&gt; NUM2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">port</span> <span class="keyword">map</span>(</span><br><span class="line">    port3   =&gt; port1,</span><br><span class="line">    port4   =&gt; port2(NUM2-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">vid: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="keyword">to</span> NUM1-<span class="number">1</span> <span class="keyword">generate</span></span><br><span class="line">module1_inst1: module1</span><br><span class="line"><span class="keyword">port</span> <span class="keyword">map</span>(</span><br><span class="line">);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">generate</span> vid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">process</span>(clk,nRST)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> nRST = <span class="string">&#x27;0&#x27;</span> <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elsif</span> rising_edge(clk) <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">process</span>(list1,list2)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="keyword">to</span> NUM5 <span class="keyword">loop</span></span><br><span class="line">        <span class="keyword">if</span>   <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">architecture</span> BEHAVIOR;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>VHDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog</title>
    <url>/2023/07/08/Verilog/</url>
    <content><![CDATA[<h2 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h2><ul>
<li><strong>设计方法</strong><br>  HDL设计多采用自上而下的设计方法——即先定义顶层模块；再分析要构成顶层模块的必要子模块；然后进一步对各个子模块进行分解、设计，直到无法进一步分解的底层功能块。  <img src="/MD_IMG/Verilog硬件描述语言.assets/75491a0e23734609854c5e4fb8605119.png" alt="在这里插入图片描述" style="zoom: 50%;" /></li>
<li><strong>设计流程</strong>  <img src="/MD_IMG/Verilog硬件描述语言.assets/1bcd2c13cd2942d7bf4fe653d1cdace0.png" alt="在这里插入图片描述" style="zoom:50%;" />
  HDL设计流程，一般包括以下八个步骤：
  - **需求分析**
      根据用户提出的功能需求进行分析理解，做出电路系统的整体规划，形成详细的技术指标，确定初步方案。
  - **功能划分**
      分析完用户需求后，进行逻辑功能的总体设计，设计整个电路的功能、接口以及总体结构；考虑功能模块的划分和设计思路；各自模块的接口和时序（包括接口时序和内部信号的时序）等。
  - **HDL描述**
      使用HDL ，对所需求的数字电路进行设计建模，保存为 .v 文件。
  - **功能仿真（前仿真）**
      对建模文件进行编译，对模型电路进行功能上的仿真验证。前仿真不考虑信号的延迟问题，只是验证逻辑正确性。
  - **逻辑综合**
      综合（synthesize），将Verilog 建模转换为门级网表的过程。逻辑综合的目的是产生物理电路门级结构，并在逻辑、时序上进行一定程度的优化，寻求逻辑、面积、功耗的平衡，增强电路的可测试性**。但不是所有的 Verilog 语句都是可以综合成逻辑单元的，例如时延语句。**
  - **布局布线**
      根据逻辑综合出的网表与约束文件，利用厂家提供的各种基本标准单元库，对门级电路进行布局布线。
  - **时序仿真（后仿真）**
      布局布线后，电路模型中已经包含了时延信息。利用在布局布线中获得的精确参数，用仿真软件验证电路的时序。单元器件的不同、布局布线方案都会给电路的时序造成影响，出错后可能就需要重新修改 RTL（寄存器传输级描述，即 Verilog 初版描述)。
  - **FPGA/CPLD 下载或 ASIC 制造工艺生产**
      通过下载器将设计的数字电路目标文件下载到 FPGA/CPLD 芯片中，然后在电路板上进行调试、验证。</li>
</ul>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ul>
<li>Verilog区分大小写</li>
<li>注释：<ul>
<li>单行注释： <code>//</code></li>
<li>跨行注释： <code>/*</code>  与 <code>*/</code></li>
</ul>
</li>
<li>标识符可以是任意一组字母、数字、<code>$</code> 符号和 <code>_</code>(下划线)符号的组合，但标识符的<strong>第一个字符必须是字母或者下划线，不能以数字或者美元符开始。</strong></li>
<li>原码&#x2F;反码&#x2F;补码<ul>
<li>原码</li>
<li>反码<ul>
<li>正数的反码是其本身；</li>
<li>负数的反码是其原码除符号位以外其余各位按位取反。</li>
</ul>
</li>
<li>补码<ul>
<li>正数的补码是其本身；</li>
<li>负数的补码是其反码 +1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>整数：&lt;位宽 num’&gt;&lt;进制 b|o|d|h&gt;&lt;数字&gt;，例如：<code>4&#39;b1010</code></li>
<li>x值(不定值)和z值(高阻值，也可用?代替)， x和z可以标识某一位或者某一个数字，  <code>4&#39;b10x0</code>    <code>4&#39;bx</code>   <code>4&#39;b101z</code>   <code>4&#39;bz</code>    <code>4&#39;b?</code></li>
<li>十进制不能用x&#x2F;z表示，例如 8‘dx、8’dz 均为非法</li>
<li>负数：整数最前面加-，例如：<code>-6&#39;d10</code></li>
<li>下划线：分割数字部分，增强代码的可读性  <code>8&#39;b1000_1000</code></li>
</ul>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p><strong>&#96;&#96;define&#96;</strong></p>
<ul>
<li>作用：常用于定义常量可以跨模块、跨文件;</li>
<li>范围：整个工程;</li>
</ul>
</li>
<li><p><strong><code>parameter</code></strong></p>
<ul>
<li>作用：常用于模块间参数传递;</li>
<li>范围：本module内有效的定义;</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Signed, ranged parameter</span></span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">signed</span> [upper:lower] &lt;name&gt; = &lt;value&gt;;</span><br><span class="line"><span class="comment">// Signed, unranged parameter</span></span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">signed</span> &lt;name&gt; = &lt;value&gt;;</span><br><span class="line"><span class="comment">// Un-typed, ranged parameter</span></span><br><span class="line"><span class="keyword">parameter</span> [upper:lower] &lt;name&gt; = &lt;value&gt;;</span><br><span class="line"><span class="comment">// Un-typed, unranged parameter</span></span><br><span class="line"><span class="keyword">parameter</span> &lt;name&gt; = &lt;value&gt;;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong><code>localparam</code></strong></p>
<ul>
<li>作用：常用于状态机的参数定义;</li>
<li>范围：本module内有效的定义，不可用于参数传递;</li>
</ul>
</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="wire型"><a href="#wire型" class="headerlink" title="wire型"></a>wire型</h4><ul>
<li><p>wire [n-1:0] 数据名</p>
</li>
<li><p>wire 表示信号，常用来表示assign关键字指定的组合逻辑信号</p>
</li>
<li><p>wire 型信号可以用作输入，输出</p>
</li>
<li><p>testbench例化接口若是inout，接口信号声明为wire类型</p>
</li>
</ul>
<h4 id="reg型"><a href="#reg型" class="headerlink" title="reg型"></a>reg型</h4><ul>
<li>reg 表示存储单元，常用来表示always模块内的指定信号，常代表触发器</li>
<li>always 块内被赋值的每一个信号都必须定义为 reg 型<ul>
<li>综合出来可以是组合逻辑或时序逻辑，要看敏感列表</li>
</ul>
</li>
</ul>
<h4 id="memory型"><a href="#memory型" class="headerlink" title="memory型"></a>memory型</h4><ul>
<li>reg [n-1:0] 存储器名[m-1:0]</li>
<li>reg [n-1:0]表示基本存储单元的大小</li>
<li>存储器名[m-1:0]表示基本存储单元的个数，存储空间的容量</li>
<li>对存储器进行地址索引的表达式必须是常数表达式</li>
<li>一个n位寄存器可以在一条赋值语句里进行赋值，而一个完整的存储器不行</li>
</ul>
<h3 id="inout-语句"><a href="#inout-语句" class="headerlink" title="inout 语句"></a>inout 语句</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gpio(</span><br><span class="line">    <span class="keyword">inout</span> c</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> a,b,oe;</span><br><span class="line">    <span class="keyword">assign</span> c = (oe  <span class="number">1&#x27;b1</span>)? a:<span class="number">1&#x27;bz</span>;</span><br><span class="line">    <span class="keyword">assign</span> b = c;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h3 id="bit选择"><a href="#bit选择" class="headerlink" title="bit选择 -:  +:"></a>bit选择 -:  +:</h3><ul>
<li><strong>+:</strong>  变量[起始地址 +:数据位宽]  &lt;&#x3D;&gt; 变量[起始地址+数据位宽-1：起始地址]<ul>
<li>例如：[0 +: 8]  &lt;&#x3D;&gt; [7 : 0]</li>
</ul>
</li>
<li><strong>-:</strong>  变量[结束地址 -:数据位宽]  &lt;&#x3D;&gt; 变量[起始地址：结束地址-数据位宽+1]<ul>
<li>例如：[7 -: 8]  &lt;&#x3D;&gt; [7 : 0]</li>
</ul>
</li>
</ul>
<h3 id="clog2"><a href="#clog2" class="headerlink" title="$clog2"></a>$clog2</h3><ul>
<li><p>作用：求位宽</p>
</li>
<li><p>自己编写函数，但只能用于模块内部，无法用于接口</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	function 实现 </span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">integer</span> clogb2 (<span class="keyword">input</span> <span class="keyword">integer</span> bit_depth);              </span><br><span class="line">    <span class="keyword">begin</span>                                                           </span><br><span class="line">        <span class="keyword">for</span>(clogb2=<span class="number">0</span>; bit_depth&gt;<span class="number">0</span>; clogb2=clogb2+<span class="number">1</span>)                   </span><br><span class="line">            bit_depth = bit_depth &gt;&gt; <span class="number">1</span>;                                 </span><br><span class="line">    <span class="keyword">end</span>                                                           </span><br><span class="line"><span class="keyword">endfunction</span>                                                     </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line"><span class="keyword">localparam</span> <span class="keyword">integer</span> C_TRANSACTIONS_NUM = clogb2(C_M_AXI_BURST_LEN-<span class="number">1</span>);	 </span><br><span class="line"><span class="keyword">reg</span> [C_TRANSACTIONS_NUM : <span class="number">0</span>] 	write_index;</span><br><span class="line"><span class="keyword">reg</span> [C_TRANSACTIONS_NUM : <span class="number">0</span>] 	read_index;</span><br></pre></td></tr></table></figure>

<ul>
<li>Vivado支持$clog2系统函数</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> clog2_test#(</span><br><span class="line">	<span class="keyword">parameter</span> <span class="keyword">integer</span>	num = <span class="number">325</span></span><br><span class="line">)(</span><br><span class="line">	<span class="keyword">input</span> 							clk,</span><br><span class="line">	<span class="keyword">input</span>							rst,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>	[<span class="built_in">$clog2</span>(num) - <span class="number">1</span>:<span class="number">0</span>]	result</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(rst)</span><br><span class="line">		result &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		result &lt;= result + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h2 id="信号运算"><a href="#信号运算" class="headerlink" title="信号运算"></a>信号运算</h2><ul>
<li><p>算术操作符：乘 <code>*</code>、除 <code>/</code>、加 <code>+</code>、减 <code>-</code>、求幂 <code>**</code>、取模 <code>%</code></p>
<ul>
<li><strong>对变量进行声明时</strong>，要根据变量的操作符对变量的位宽进行合理声明，<strong>不要让结果溢出。</strong>上述例子中，相加的 2 个变量位宽为 4bit，那么结果寄存器变量位宽最少为 5bit。<strong>否则，高位将被截断，导致结果高位丢失。</strong>无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和。</li>
</ul>
</li>
<li><p>关系操作符：大于 <code>&gt;</code>，小于 <code>&lt;</code>，大于等于 <code>&gt;=</code>，小于等于 <code>&lt;=</code></p>
</li>
<li><p>等价操作符：</p>
<ul>
<li>逻辑相等 &#96;&#96;，逻辑不等 <code>!=</code>（不能比较 x 或z，当操作数包含一个 x 或 z，则结果为不确定值）</li>
<li>全等 <code>=</code>，非全等 <code>!</code>（对参数的x、z都进行比较）</li>
</ul>
</li>
<li><p>逻辑操作符：逻辑与 <code>&amp;&amp;</code>,逻辑或 <code>||</code>，逻辑非 <code>!</code></p>
</li>
<li><p>按位操作符：取反 <code>~</code>，与 <code>&amp;</code>，或 <code>|</code>，异或 <code>^</code>，同或 <code>~^</code></p>
<ul>
<li><p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作。</p>
</li>
<li><p>如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p>
</li>
<li><p>取反操作符只有一个操作数，它对操作数的每 1bit 数据进行取反操作。</p>
</li>
</ul>
</li>
<li><p>归约操作符：归约与 <code>&amp;</code>，归约与非 <code>~&amp;</code>，归约或 <code>|</code>，归约或非 <code>~|</code>，归约异或 <code>^</code>，归约同或 <code>~^</code>。</p>
<ul>
<li>归约操作符只有一个操作数，它对这个向量操作数<strong>逐位进行操作</strong>，最终产生一个 <strong>1bit 结果</strong>。</li>
<li>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的<strong>关键是分清操作数的数目</strong>，和计算结果的规则。</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1010</span> ;</span><br><span class="line">&amp;A ;      <span class="comment">//结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#x27;b0，可用来判断变量A是否全1</span></span><br><span class="line">~|A ;     <span class="comment">//结果为 ~(1 | 0 | 1 | 0) = 1&#x27;b0, 可用来判断变量A是否为全0</span></span><br><span class="line">^A ;      <span class="comment">//结果为 1 ^ 0 ^ 1 ^ 0 = 1&#x27;b0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>移位操作符：左移 <code>&lt;&lt;</code>，右移 <code>&gt;&gt;</code>，算术左移 <code>&lt;&lt;&lt;</code>，算术右移 <code>&gt;&gt;&gt;</code></p>
<ul>
<li>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</li>
<li>算术左移和逻辑左移时，右边低位会补 0。</li>
<li>逻辑右移时，左边高位会补 0；而算术右移时，左边高位符号位不变，以保证数据缩小后值的正确性。</li>
</ul>
</li>
<li><p>拼接操作符：<code>&#123;,&#125;</code></p>
<ul>
<li>信号间用逗号隔开；拼接符操作数必须指定位宽，常数的话也需要指定位宽。</li>
</ul>
</li>
<li><p>条件操作符：<code>?:</code></p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">condition_expression ? true_expression : false_expression</span><br></pre></td></tr></table></figure>

<ul>
<li>优先级别：直接加括号</li>
</ul>
<p>在不确定优先级时，建议用圆括号将表达式区分开来。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>操作符号</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>单目运算</td>
<td><code>+</code> <code> -</code> <code>!</code> <code>~</code></td>
<td>最高</td>
</tr>
<tr>
<td>乘、除、取模</td>
<td><code>*</code> <code>/</code>  <code>%</code></td>
<td></td>
</tr>
<tr>
<td>加减</td>
<td><code>+</code> <code>-</code></td>
<td></td>
</tr>
<tr>
<td>移位</td>
<td><code>&lt;&lt;</code>  <code>&gt;&gt;</code></td>
<td></td>
</tr>
<tr>
<td>关系</td>
<td><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
<td></td>
</tr>
<tr>
<td>等价</td>
<td>&#96;&#96; <code>!=</code> <code>=</code>  <code>!=</code></td>
<td></td>
</tr>
<tr>
<td>归约</td>
<td><code>&amp;</code> <code>~&amp;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>^</code> <code>~^</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>~</code></td>
<td></td>
</tr>
<tr>
<td>逻辑</td>
<td><code>&amp;&amp;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&#96;</td>
<td></td>
</tr>
<tr>
<td>条件</td>
<td><code>?:</code></td>
<td>最低</td>
</tr>
</tbody></table>
<h2 id="可综合语句"><a href="#可综合语句" class="headerlink" title="可综合语句"></a>可综合语句</h2><p>所有行为语句如表所示，高亮为可综合语句</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>语句（可综合性）</th>
</tr>
</thead>
<tbody><tr>
<td>过程语句</td>
<td><strong>initial</strong></td>
</tr>
<tr>
<td></td>
<td><strong>always</strong></td>
</tr>
<tr>
<td>块语句</td>
<td><strong>串行块 begin…end</strong></td>
</tr>
<tr>
<td></td>
<td><strong>并行块 fork…join</strong></td>
</tr>
<tr>
<td>赋值语句</td>
<td><strong>连续赋值 assign</strong></td>
</tr>
<tr>
<td></td>
<td><strong>过程赋值 &#x3D;、&lt;&#x3D;</strong></td>
</tr>
<tr>
<td>条件语句</td>
<td><strong>if…else</strong></td>
</tr>
<tr>
<td></td>
<td><strong>case</strong></td>
</tr>
<tr>
<td>循环语句</td>
<td><strong>for</strong></td>
</tr>
<tr>
<td></td>
<td><strong>repeat</strong></td>
</tr>
<tr>
<td></td>
<td><strong>while</strong></td>
</tr>
<tr>
<td></td>
<td><strong>forever</strong></td>
</tr>
<tr>
<td>编译指令语句</td>
<td><strong>&#96;define</strong></td>
</tr>
<tr>
<td></td>
<td><strong>&#96;include</strong></td>
</tr>
<tr>
<td></td>
<td><strong>`ifdef,`else,`endif</strong></td>
</tr>
<tr>
<td></td>
<td><strong>&#96;timescale</strong></td>
</tr>
</tbody></table>
<h2 id="过程语句"><a href="#过程语句" class="headerlink" title="过程语句"></a>过程语句</h2><h3 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h3><ul>
<li><p>initial语句指定的内容只执行一次 ，initial语句<strong>主要用于仿真测试</strong>，不能进行逻辑综合。</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        ......</span><br><span class="line">        语句n;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="always"><a href="#always" class="headerlink" title="always"></a>always</h3><ul>
<li><p>always块内的语句是不断重复执行的，在仿真和逻辑综合中均可使用.</p>
</li>
<li><p>敏感信号表达式中应列出影响块内取值的所有信号。</p>
</li>
<li><p>always 块内被赋值的每一个信号都必须定义为 reg 型</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @ (敏感列表)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//过程赋值</span></span><br><span class="line">        <span class="comment">//if-else,case,casex,casez 条件语句</span></span><br><span class="line">        <span class="comment">//task,function 调用</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="块语句"><a href="#块语句" class="headerlink" title="块语句"></a>块语句</h2><h3 id="串行块-begin…end"><a href="#串行块-begin…end" class="headerlink" title="串行块 begin…end"></a>串行块 begin…end</h3><ul>
<li><p>块内的语句是按顺序执行的，即只有上面一条语句执行完后下面的语句才能执行。</p>
</li>
<li><p>可以在begin后声明该块的名字，一个标识名。块内声明语句可以是参数声明语句、reg型变量声明语句、integer型变量声明语句和real 变量声明语句。</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>: 块名</span><br><span class="line">    块内声明语句</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="并行块-fork…join"><a href="#并行块-fork…join" class="headerlink" title="并行块 fork…join"></a>并行块 fork…join</h3><ul>
<li><p>fork–join之间可以添加多条语句，并且语句的关系是并行的，是同时执行的</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fork</span>: 块名</span><br><span class="line">    块内声明语句</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line"><span class="keyword">join</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="起止时间、结束时间"><a href="#起止时间、结束时间" class="headerlink" title="起止时间、结束时间"></a>起止时间、结束时间</h3><ul>
<li><p>在并行块和顺序块中都有一个起始时间和结束时间的概念。</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"> <span class="keyword">fork</span></span><br><span class="line">    #<span class="number">10</span>  a = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">15</span>  b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">       #<span class="number">20</span>  c = <span class="number">1</span></span><br><span class="line">       #<span class="number">10</span>  d = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">    #<span class="number">25</span>  e = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序运行的结果如下：</span></span><br><span class="line"><span class="comment">    时刻    |    执行的语句</span></span><br><span class="line"><span class="comment">      10      |     a=1;</span></span><br><span class="line"><span class="comment">      15      |     b=1;</span></span><br><span class="line"><span class="comment">      20      |     c=1;</span></span><br><span class="line"><span class="comment">      25      |     e=1;</span></span><br><span class="line"><span class="comment">      30      |     d=1;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><h3 id="连续赋值-assign"><a href="#连续赋值-assign" class="headerlink" title="连续赋值 assign"></a>连续赋值 assign</h3><ul>
<li><p>连续赋值语句，位于过程块语句外，常以assign为关键字。</p>
</li>
<li><p>连续赋值语句中“&#x3D;”的左边必须是线网型变量，右边可以是线网型、寄存器型变量或者是函数调用语句。</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> 赋值目标线网变量 = 表达式;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="阻塞赋值与非阻塞赋值"><a href="#阻塞赋值与非阻塞赋值" class="headerlink" title="阻塞赋值与非阻塞赋值"></a>阻塞赋值与非阻塞赋值</h3><ul>
<li>过程赋值主要出现在过程块always和initial语句内。</li>
<li>阻塞赋值 &#x3D; ，赋值有先后关系，通常用于组合逻辑</li>
<li>非阻塞赋值 &lt;&#x3D; ，赋值同时进行，通常用于时序逻辑</li>
</ul>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230323124537294.png" alt="image-20230323124537294"></p>
<ul>
<li>不要管阻塞不阻塞，先想一想你要实现什么电路，组合逻辑还是时序逻辑？</li>
<li>组合逻辑用 &#x3D; ；时序逻辑用 &lt;&#x3D; 。</li>
<li><strong>组合逻辑尽量不要用always（*）+reg 这种结构，直接用assign + wire</strong> 。</li>
</ul>
<h2 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h2><h3 id="generate…case"><a href="#generate…case" class="headerlink" title="generate…case"></a>generate…case</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">generate</span></span><br><span class="line">  <span class="keyword">case</span> (&lt;constant_expression&gt;)</span><br><span class="line">     &lt;value&gt;: <span class="keyword">begin</span>: &lt;label_1&gt;</span><br><span class="line">                 &lt;code&gt;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">     &lt;value&gt;: <span class="keyword">begin</span>: &lt;label_2&gt;</span><br><span class="line">                 &lt;code&gt;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">default</span>: <span class="keyword">begin</span>: &lt;label_3&gt;</span><br><span class="line">                 &lt;code&gt;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<h3 id="generate…if"><a href="#generate…if" class="headerlink" title="generate…if"></a>generate…if</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">generate</span></span><br><span class="line">  <span class="keyword">if</span> (&lt;condition&gt;) <span class="keyword">begin</span>: &lt;label_1&gt;</span><br><span class="line">     &lt;code&gt;;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (&lt;condition&gt;) <span class="keyword">begin</span>: &lt;label_2&gt;</span><br><span class="line">     &lt;code&gt;;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>: &lt;label_3&gt;</span><br><span class="line">     &lt;code&gt;;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<h3 id="generate…for"><a href="#generate…for" class="headerlink" title="generate…for"></a>generate…for</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">genvar</span> &lt;<span class="keyword">var</span>&gt;;</span><br><span class="line"><span class="keyword">generate</span></span><br><span class="line">  <span class="keyword">for</span> (&lt;<span class="keyword">var</span>&gt;=<span class="number">0</span>; &lt;<span class="keyword">var</span>&gt; &lt; &lt;limit&gt;; &lt;<span class="keyword">var</span>&gt;=&lt;<span class="keyword">var</span>&gt;+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">begin</span>: &lt;label&gt;</span><br><span class="line">     &lt;instantiation&gt;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<h3 id="generate…for嵌套"><a href="#generate…for嵌套" class="headerlink" title="generate…for嵌套"></a>generate…for嵌套</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">genvar</span> &lt;var1&gt;, &lt;var2&gt;;</span><br><span class="line"><span class="keyword">generate</span></span><br><span class="line">  <span class="keyword">for</span> (&lt;var1&gt;=<span class="number">0</span>; &lt;var1&gt; &lt; &lt;limit&gt;; &lt;var1&gt;=&lt;var1&gt;+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">begin</span>: &lt;label_1&gt;</span><br><span class="line">     <span class="keyword">for</span> (&lt;var2&gt;=<span class="number">0</span>; &lt;var2&gt; &lt; &lt;limit&gt;; &lt;var2&gt;=&lt;var2&gt;+<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">begin</span>: &lt;label_2&gt;</span><br><span class="line">        &lt;code&gt;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>





<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h3><ul>
<li><p>条件语句必须在过程块中使用</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    	语句<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (表达式<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">		语句<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    	语句<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><ul>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span>(表达式)</span><br><span class="line">    分支表达式<span class="number">1</span>：语句<span class="number">1</span>;</span><br><span class="line">    分支表达式<span class="number">2</span>：语句<span class="number">2</span>;</span><br><span class="line">    ···</span><br><span class="line">    分支表达式n：语句n;</span><br><span class="line">    <span class="keyword">default</span>: 语句n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">endcase</span>    </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>casez</strong>：忽略比较过程中值为 z 的位</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在分支表达式中，z常用？代替。</span></span><br><span class="line"><span class="keyword">casez</span>(a)</span><br><span class="line">	<span class="number">3&#x27;b1</span>?? :  out1 = <span class="number">1</span>; <span class="comment">//如果a=100、101或1xx,1zz等，都有out1 = 1。</span></span><br><span class="line">	<span class="number">3&#x27;b0</span>?<span class="number">1</span> :  out2 = <span class="number">1</span>; <span class="comment">//如果a=001、011、0x1、0z1，都有out2 = 1</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>casex</strong>：忽略比较过程中值为 z 和 x 的位</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casex</span>(a)</span><br><span class="line">    <span class="number">2&#x27;b1x</span>:out=<span class="number">1</span>;  <span class="comment">//如果a=10、11、1x、1z，都有out=1。</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><ul>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;=<span class="number">7</span>;i=i+<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">      datain[i]  &lt;=  datain [i-<span class="number">4</span>];</span><br><span class="line">   <span class="keyword">end</span>　</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="forvever"><a href="#forvever" class="headerlink" title="forvever"></a>forvever</h3><ul>
<li><p>无条件地无限次执行其后的语句，相当于while(1),直到遇到系统任务<code>$finish</code>或<code>$stop</code>,如果需要从循环中退出，可以使用<code>disable</code>。</p>
</li>
<li><p>循环语句多用于生成时钟等周期性波形，它与 always 语句不同之处在于不能独立写在程序中，而必须写在 initial 块中。</p>
</li>
<li><p><strong>forever应该是过程块中最后一条语句</strong>，其后的语句将永远不会执行</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">         clk = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">forever</span> #<span class="number">25</span> clk = ~clk;     </span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><ul>
<li><p>repeat语句是最简单的循环语句，用于循环次数已知的情况。</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span>(<span class="number">10</span>)@(<span class="keyword">posedge</span> clk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rotate  <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">repeat</span> (<span class="number">8</span>)     </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            temp = data[<span class="number">15</span>];</span><br><span class="line">            data = &#123;data &lt;&lt; <span class="number">1</span>,temp&#125;;  <span class="comment">// data循环左移8次</span></span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul>
<li><p>while语句通过控制某个变量的取值来控制循环次数</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">4</span>) <span class="comment">// 满足条件进入循环</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">       a = a + <span class="number">1</span>;</span><br><span class="line"> 	   i = i + <span class="number">1</span>; <span class="comment">//更新条件取值，使循环4次退出循环 </span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="disable"><a href="#disable" class="headerlink" title="disable"></a>disable</h3><ul>
<li><p>在有些特殊的情况下，需要使用 disable 强制退出循环。</p>
</li>
<li><p>使用 disable 语句强制退出循环，首先要给循环部分起个名字，方法是在begin 后添加 “: 名字”。即 <strong>disable 语句可以中止有名字的 begin…end 块和fork…join 块</strong>。</p>
</li>
<li><p>disable 语句可以退出 task、function</p>
</li>
<li><p>语句格式</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>  :<span class="keyword">continue</span></span><br><span class="line">    a = <span class="number">0</span>; b =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i = i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">          a = a+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(i2) <span class="keyword">disable</span> <span class="keyword">continue</span>;</span><br><span class="line">          b = b+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> <span class="comment">//a做3次加1操作后强制退出循环；而b只做2次加1操作。</span></span><br><span class="line"></span><br><span class="line">a=<span class="number">0</span>; </span><br><span class="line">b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i=i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">begin</span>: <span class="keyword">continue</span></span><br><span class="line">        a = a+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( i <span class="number">2</span>) <span class="keyword">disable</span> <span class="keyword">continue</span>;</span><br><span class="line">        b= b+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//中止一次循环，继续下一次循环； a做4次加1操作， b只做3次加1操作.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="编译指令语句"><a href="#编译指令语句" class="headerlink" title="编译指令语句"></a>编译指令语句</h2><p>以反引号  &#96; 开始的某些标识符是 Verilog 系统编译指令。</p>
<h3 id="96-define"><a href="#96-define" class="headerlink" title="&#96;define"></a>&#96;define</h3><ul>
<li>&#96;&#96;define&#96; 用于定义一个宏定义</li>
</ul>
<h3 id="96-undef"><a href="#96-undef" class="headerlink" title="&#96;undef"></a>&#96;undef</h3><ul>
<li>&#96;&#96;undef&#96;用于取消一个宏定义<ul>
<li>宏定义可以定义在模块内，也可以定义在模块外，效果都一样，而parameter只能定义在模块内。</li>
<li>可以定义设计参数和常量，如延时、位长、宽度、地址和状态等等.。</li>
<li>如果只在模块里面使用，没有全局的意义，那用localparam。</li>
<li>可以提高代码的可读性和可维护性。</li>
</ul>
</li>
</ul>
<h3 id="ifdef、-elsif、-endif"><a href="#ifdef、-elsif、-endif" class="headerlink" title="`ifdef、`elsif、`endif"></a>`ifdef、`elsif、`endif</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifdef</span> &lt;define_name&gt;</span></span><br><span class="line">   &lt;statements&gt;;</span><br><span class="line"><span class="meta">`<span class="keyword">elsif</span> &lt;define_name&gt;</span></span><br><span class="line">   &lt;statements&gt;;</span><br><span class="line"><span class="meta">`<span class="keyword">else</span></span></span><br><span class="line">   &lt;statements&gt;;</span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="96-include"><a href="#96-include" class="headerlink" title="&#96;include"></a>&#96;include</h3><ul>
<li>&#96;&#96;include&#96; 用于在源文件中插入另一个文件，要插入的内容可以是全局使用的宏定义，也可以是经常使用的任务和函数，便于Verilog文件的管理和维护。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include the contents of the ram_data.vh file in the relative directory ../data</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;../data/ram_data.vh&quot; </span></span><br></pre></td></tr></table></figure>



<h3 id="96-timescale"><a href="#96-timescale" class="headerlink" title="&#96;timescale"></a>&#96;timescale</h3><ul>
<li>&#96;&#96;timescale&#96;用于指定后续模块的仿真时间单位（time_unit）和时间精度（time_precision）</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 10ns/100ps</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果精度不够会四舍五入，单位有s&#x2F;ms&#x2F;us&#x2F;ns&#x2F;ps&#x2F;fs</li>
<li>不要设置无意义的高精度</li>
</ul>
<h2 id="任务-x2F-函数"><a href="#任务-x2F-函数" class="headerlink" title="任务&#x2F;函数"></a>任务&#x2F;函数</h2><p>任务和函数一般用于行为建模，在编写测试验证程序时用得较多，佷多逻辑综合软件都不能佷好地支持任务和函数。</p>
<h3 id="task-与-function-区别"><a href="#task-与-function-区别" class="headerlink" title="task 与 function 区别"></a>task 与 function 区别</h3><ul>
<li><p>task</p>
<ul>
<li><p>常用于调试，或对硬件进行行为描述</p>
</li>
<li><p>可以包含时序控制（#延迟，@, wait）</p>
</li>
<li><p>可以有 input，output，和 inout 参数</p>
</li>
<li><p>可以调用其他任务或函数</p>
</li>
</ul>
</li>
<li><p>function</p>
<ul>
<li>通常用于计算，或描述组合逻辑</li>
<li>不能包含任何延迟(#,@,-&gt;,wait)；函数仿真时间为0</li>
<li>只含有input参数并由函数名返回一个结果（返回值缺省为reg类型）</li>
<li>可以调用其他函数，但不能调用task</li>
</ul>
</li>
<li><p>共同点</p>
<ul>
<li>任务和函数必须在module内调用</li>
<li>在任务和函数中不能声明wire</li>
<li>所有输入输出都是局部寄存器</li>
<li>任务函数执行完成后才返回结果</li>
</ul>
</li>
</ul>
<h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><ul>
<li>任务定义</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> &lt;task_name&gt;;</span><br><span class="line">  <span class="keyword">input</span> &lt;input_name&gt;;</span><br><span class="line">  &lt;more_inputs&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">output</span> &lt;output_name&gt;;</span><br><span class="line">  &lt;more_outputs&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">     &lt;statements&gt;;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>

<ul>
<li>任务调用</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">&lt;task_name&gt;(&lt;comma_separated _inputs&gt;, &lt;comma_separated _outputs&gt;);</span><br></pre></td></tr></table></figure>

<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><ul>
<li>函数定义</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>  [&lt;lower&gt;:&lt;upper&gt;] &lt;output_name&gt; ;</span><br><span class="line">  <span class="keyword">input</span> &lt;name&gt;;</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">     &lt;statements&gt;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数调用</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">&lt;signal&gt; = &lt;function_name&gt;(&lt;comma_separated _inputs&gt;);</span><br></pre></td></tr></table></figure>

<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20220317174637902.png" alt="image-20220317174637902"></p>
<h2 id="testbench"><a href="#testbench" class="headerlink" title="testbench"></a>testbench</h2><h3 id="产生时钟"><a href="#产生时钟" class="headerlink" title="产生时钟"></a>产生时钟</h3><p>方法一：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">parameter</span> PERIOD_50MHz  = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">reg</span> clk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> <span class="variable">#(PERIOD_50MHz/2)</span> clk = ~clk;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//clock generate module</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">forever</span> <span class="variable">#(PERIOD_50MHz/2)</span></span><br><span class="line">    clk = ~clk;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="过程时序控制"><a href="#过程时序控制" class="headerlink" title="过程时序控制"></a>过程时序控制</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------------</span></span><br><span class="line">#<span class="number">10</span></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line">@(<span class="keyword">posedge</span> clk);</span><br><span class="line">@(<span class="keyword">negedge</span> clk);</span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"><span class="keyword">event</span> evt1;</span><br><span class="line">-&gt; evt1; <span class="comment">// 触发事件</span></span><br><span class="line">@evt1; <span class="comment">// 等待事件</span></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"><span class="keyword">reg</span> flag;</span><br><span class="line"><span class="keyword">wait</span>(flag  <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="信号赋值时机"><a href="#信号赋值时机" class="headerlink" title="信号赋值时机"></a>信号赋值时机</h3><ul>
<li>建议：testbench中不要在时钟沿上给信号赋值</li>
</ul>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230323130130569.png" alt="image-20230323130130569"></p>
<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><ul>
<li><p>返回一个32bit的integer类型的有符号的值</p>
</li>
<li><p>$random与$random()的用法、结果都是一致的</p>
</li>
<li><p>$random%b可以生成范围 [ (-b+1) : (b-1) ]内的随机数</p>
</li>
<li><p>{$random}%b可以生成范围 [ 0: (b-1) ]内的随机数</p>
</li>
<li><p>常用方法</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">输入 data_in，位宽【a-<span class="number">1</span>:<span class="number">0</span>】，即位宽a，其值范围<span class="number">2</span>^a</span><br><span class="line">所以如果需要模拟data_in的随机输入，通常这样调用：data_in = &#123;<span class="built_in">$random</span>&#125;%(<span class="number">2</span>**a);       </span><br></pre></td></tr></table></figure>

<h3 id="fopen"><a href="#fopen" class="headerlink" title="$fopen"></a>$fopen</h3><p> 系统任务$fopen可以用来打开指定的文件（以便后续对其进行写入操作），其返回值为integer变量，表示当前文件的句柄值，获取句柄值后，后续就可以根据句柄值对不同的文件进行写入操作。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> handle1；<span class="comment">// 定义句柄1</span></span><br><span class="line">handle1 = <span class="built_in">$fopen</span>(<span class="string">&quot;file_name&quot;</span>,<span class="keyword">type</span>); <span class="comment">//以指定类型（type）的方式来打开文件，并将其返回值赋给handle1</span></span><br></pre></td></tr></table></figure>

<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230323234151732.png" alt="image-20230323234151732"></p>
<p>通常情况下，我们使用 w 来作为类型值，即以对一个ASCII文本文件进行写操作的方式来打开该文件 （txt）。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> handle1; <span class="comment">//定义句柄1</span></span><br><span class="line">handle1 = <span class="built_in">$fopen</span>(<span class="string">&quot;D:/file_test/file_test1.txt&quot;</span>,<span class="string">&quot;w&quot;</span>); <span class="comment">//以w类型（写）的方式来打开文件，并将其返回值赋给handle1</span></span><br></pre></td></tr></table></figure>

<h3 id="display-write-strobe-monitor"><a href="#display-write-strobe-monitor" class="headerlink" title="$display, $write, $strobe, $monitor"></a>$display, $write, $strobe, $monitor</h3><h4 id="display"><a href="#display" class="headerlink" title="$display"></a>$display</h4><p> $display可以直接打印一条文本信息，并在每一次$display执行后<strong>会自动换行</strong>，比如：</p>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324125730927.png" alt="image-20230324125730927"></p>
<hr>
<h4 id="write"><a href="#write" class="headerlink" title="$write"></a>$write</h4><p> $write的用法与$display一致，区别在于，一条$write语句执行完后，<strong>不会自动换行</strong>。比如下面的代码：</p>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324125834046.png" alt="image-20230324125834046"></p>
<hr>
<h4 id="打印变量值"><a href="#打印变量值" class="headerlink" title="打印变量值"></a>打印变量值</h4><p> 这两个系统函数除了直接打印文本外，也可以打印变量的值，其格式为（以$display为例）：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">$display(<span class="string">&quot;%b %b&quot;</span>,a,b);</span><br></pre></td></tr></table></figure>

<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324130207089.png" alt="image-20230324130207089"></p>
<hr>
<h4 id="strobe"><a href="#strobe" class="headerlink" title="$strobe"></a>$strobe</h4><p>$strobe 为选通显示任务。$strobe 使用方法与 $display 一致，但打印信息的时间和$display 有所差异（也可以直接打印文本）。</p>
<p>当许多语句与 $display 任务在同一时间内执行时，这些语句和 $display 的执行顺序是不确定的，一般按照程序的顺序结构执行。两者的区别在于：$strobe命令会在当前时间部结束时完成；而$display是只要仿真器看到就会立即执行。$strobe 是在其他语句执行完毕之后，才执行显示任务。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> test_tb();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]  a ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="built_in">$strobe</span>(<span class="string">&quot;begin!&quot;</span>);</span><br><span class="line">	a = <span class="number">1</span> ;</span><br><span class="line">	#<span class="number">1</span> ;</span><br><span class="line">	a &lt;= a + <span class="number">1</span> ;</span><br><span class="line">	<span class="comment">//第一次显示</span></span><br><span class="line">	<span class="built_in">$display</span>(<span class="string">&quot;$display excuting result: %d.&quot;</span>, a);</span><br><span class="line">	<span class="built_in">$strobe</span>(<span class="string">&quot;$strobe excuting result: %d.&quot;</span>, a);</span><br><span class="line">	#<span class="number">1</span> ;</span><br><span class="line">	<span class="built_in">$display</span>();</span><br><span class="line">	<span class="comment">//第二次显示</span></span><br><span class="line">	<span class="built_in">$display</span>(<span class="string">&quot;$display excuting result: %d.&quot;</span>, a);</span><br><span class="line">	<span class="built_in">$strobe</span>(<span class="string">&quot;$strobe excuting result: %d.&quot;</span>, a);</span><br><span class="line">	<span class="built_in">$strobe</span>(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

<p>其打印结果如下：</p>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324130833866.png" alt="image-20230324130833866"></p>
<p>可以看到，$strobe与$display的打印内容不是一致的.</p>
<p>这是因为该语句：    a &lt;&#x3D; a + 1 ；也就是说a的第二次赋值是非阻塞赋值，而非阻塞赋值是需要时间的。</p>
<p>在第一次打印时，$display不会管你a是阻塞赋值还是非阻塞赋值，它就直接打印a当前的值1。而$strobe则会等到非阻塞赋值完成后再打印，所以其打印的值为2。</p>
<p>在第二次打印时，又延时了1ns，所以此时的非阻塞赋值完成，那么$strobe与$display的打印内容就均为2了。</p>
<p>所以$strobe这个系统任务通常是用来打印当前非阻塞赋值的变量值的。</p>
<hr>
<h4 id="monitor"><a href="#monitor" class="headerlink" title="$monitor"></a>$monitor</h4><p>$monitor 为监测任务，用于变量的持续监测。只要变量发生了变化，$monitor 就会打印显示出对应的信息。 其使用方法与 $display一致.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> test_tb();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]  a ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]  b ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]  c ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	a = <span class="number">0</span> ;</span><br><span class="line">	b = <span class="number">0</span> ;</span><br><span class="line">	c = <span class="number">0</span> ;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">$monitor</span>(<span class="string">&quot;a=%d b=%d c=%d&quot;</span>,a,b,c);</span><br><span class="line">	#<span class="number">50</span> <span class="built_in">$finish</span>;	<span class="comment">//50ns后停止</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">always</span> #<span class="number">10</span> <span class="keyword">begin</span>		<span class="comment">//每10ns，随机生成a,b,c</span></span><br><span class="line">	a = &#123;<span class="built_in">$random</span>&#125;%<span class="number">4</span>;</span><br><span class="line">	b = &#123;<span class="built_in">$random</span>&#125;%<span class="number">4</span>;</span><br><span class="line">	c = &#123;<span class="built_in">$random</span>&#125;%<span class="number">4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

<p> 终端打印结果如下：</p>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324131149902.png" alt="image-20230324131149902"></p>
<h3 id="fdisplay-fwrite-fstrobe-fmonitor"><a href="#fdisplay-fwrite-fstrobe-fmonitor" class="headerlink" title="$fdisplay, $fwrite, $fstrobe, $fmonitor"></a>$fdisplay, $fwrite, $fstrobe, $fmonitor</h3><p> 这4个函数都可以对指定文件进行打印或写入操作，其用法与对应的$display， $write，$strobe，$monitor几乎一致。区别在于$display等函数是直接在仿真中进行打印，而$fdisplay等函数是对指定文件进行打印，需要通过句柄来指定是对具体哪个文件进行操作。如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>指定句柄并打开文件</span><br><span class="line">reg data;</span><br><span class="line">integer handle; <span class="regexp">//</span>定义句柄<span class="number">1</span></span><br><span class="line"></span><br><span class="line">handle1 = <span class="variable">$fopen</span>(<span class="string">&quot;D:/file_test/file_test1.txt&quot;</span>,<span class="string">&quot;w&quot;</span>); <span class="regexp">//</span>以w类型（写）的方式来打开文件，并将其返回值赋给handle1</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>对指定文件写入数据</span><br><span class="line"><span class="variable">$fdisplay</span>(handle1,<span class="string">&quot;%d\n&quot;</span>,data); <span class="regexp">//</span>按照十进制格式写入数据到handle1对应的文件中，只能逐个写入</span><br></pre></td></tr></table></figure>

<h3 id="fclose"><a href="#fclose" class="headerlink" title="$fclose"></a>$fclose</h3><p>$fclose系统任务用来关闭指定文件，关闭后即无法对该文件进行操作。其格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$fclose</span>(handle1); <span class="comment">//关闭文件file_test1，至此文件操作结束</span></span><br></pre></td></tr></table></figure>

<h3 id="printtimescale"><a href="#printtimescale" class="headerlink" title="$printtimescale"></a>$printtimescale</h3><p>打印时间格式&#96;timescale，它的语法格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">printtimescale_task ::=<span class="built_in">$printtimescale</span> [(hierarchical_identifier)];</span><br></pre></td></tr></table></figure>

<p>其中的hierarchical_identifier代表模块层次，这意味着其不仅可以打印当前module的时间格式，同样可以打印指定module的时间格式。</p>
<pre><code>其输出内容如下：
    Time scale of (module_name) is unit / precision
</code></pre>
<h3 id="timeformat"><a href="#timeformat" class="headerlink" title="$timeformat"></a>$timeformat</h3><p> timeformat用于配置其他打印系统任务中（$write, $display,$strobe, $monitor, $fwrite, $fdisplay, $fstrobe, and $fmonitor）%t类型的打印格式，它的语法格式如下：</p>
<pre><code>timeformat_task ::= $timeformat [(units_number,precision_number,suffix_string,minimum_field_width)];
</code></pre>
<ul>
<li>units_number使用下表中的数字来表示对应的时间单位：</li>
</ul>
<img src="/MD_IMG/Verilog硬件描述语言.assets/image-20230323235756101.png" alt="image-20230323235756101" style="zoom:50%;" />

<ul>
<li><p><strong>precision_number</strong> 表示时间精度，即需要打印到小数点后几位</p>
</li>
<li><p><strong>suffix_string</strong> 用来在时间后打印一个用户自定义的字符串</p>
</li>
<li><p><strong>minimum_field_width</strong> 表示时间值字符串与后缀字符串合起来的这部分字符串的最小长度，若这部分字符串不足这个长度，则在这部分字符串之前补空格</p>
</li>
</ul>
<p>如果没有调用该系统函数对时间格式进行设置，则其默认设置如下，即时间单位为&#96;timescale设置的时间精度，不精确到小数点后，打印的字符串为空，最小长度为20个长度。</p>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230323235941198.png" alt="image-20230323235941198"></p>
<p>举个例子：分别打印在默认格式下和设置时间格式为单位1ns，精度小数点后3位，打印字符串 ns，最小打印长度10的情况下的仿真时间。如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns / 1 ps				</span><span class="comment">//单位1ns,精度1ps</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> test_a; </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	#<span class="number">10</span></span><br><span class="line">	<span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>,<span class="built_in">$realtime</span>);		<span class="comment">//打印默认格式的仿真时间</span></span><br><span class="line">	#<span class="number">10</span></span><br><span class="line">	<span class="built_in">$timeformat</span>(-<span class="number">9</span>,<span class="number">3</span>,<span class="string">&quot; ns&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>,<span class="built_in">$realtime</span>);		<span class="comment">//打印用户设定的格式的仿真时间</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="time-stime-realtime"><a href="#time-stime-realtime" class="headerlink" title="$time, $stime, $realtime"></a>$time, $stime, $realtime</h3><p>这3个系统任务都可以在仿真时（无法综合）获取当前仿真时刻的时间值，但其使用也有一点小小的区别</p>
<h4 id="time"><a href="#time" class="headerlink" title="$time"></a>$time</h4><p>调用系统任务$time，将会获得一个64位的integer型变量，其表示调用该系统任务时的仿真时间。需要注意的是，其值会自动缩放到&#96;timescale任务所定义的时间单位。下面举个例子：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1 ns / 1 ns</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> tb_time_test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">reg</span> set;</span><br><span class="line"><span class="keyword">parameter</span> p = <span class="number">1</span><span class="variable">.55</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="built_in">$monitor</span>(<span class="built_in">$time</span>,,<span class="string">&quot;set=&quot;</span>,set);</span><br><span class="line">	#p set = <span class="number">0</span>;</span><br><span class="line">	#p set = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324000958095.png" alt="image-20230324000958095"></p>
<h4 id="stime"><a href="#stime" class="headerlink" title="$stime"></a>$stime</h4><p>调用系统任务$stime，将会获得一个32位的无符号integer型变量，其表示调用该系统任务时的仿真时间。需要注意的是，其值同样会自动缩放到&#96;timescale任务所定义的时间单位。</p>
<p>这个系统任务的用法基本上和 $time是一样的，只不过由于其只有32位，所以表示的时间范围会比较小，使用的时候注意别溢出了。</p>
<h4 id="realtime"><a href="#realtime" class="headerlink" title="$realtime"></a>$realtime</h4><p>调用系统任务$realtime，将会获得一个real型变量，其表示调用该系统任务时的仿真时间。需要注意的是，其值会自动缩放到&#96;timescale任务所定义的时间单位。</p>
<p>由于其返回值为实数real型，所以其可以表示小数时间。同样以上面的代码为例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 10 ns / 1 ns</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> tb_time_test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">reg</span> set;</span><br><span class="line"><span class="keyword">parameter</span> p = <span class="number">1</span><span class="variable">.55</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="built_in">$monitor</span>(<span class="built_in">$realtime</span>,,<span class="string">&quot;set=&quot;</span>,set);</span><br><span class="line">	#p set = <span class="number">0</span>;</span><br><span class="line">	#p set = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324001359898.png" alt="image-20230324001359898"></p>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[M-<span class="number">1</span>:<span class="number">0</span>]	mem	[N:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemb</span>(<span class="string">&quot;E:/Project/data.txt&quot;</span>, mem);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>readmemb<ul>
<li>当data.txt 每行的数据位宽小于 M，数据可以正常读取，高位补 0；</li>
<li>当data.txt 每行的数据位宽小于 M，无法正常读取数据</li>
</ul>
</li>
<li>readmemh</li>
</ul>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> w_file;</span><br><span class="line"><span class="keyword">initial</span> w_file = <span class="built_in">$fopen</span>(<span class="string">&quot;E:/Project/modelsim/data_out_1.txt&quot;</span>);</span><br><span class="line"><span class="keyword">always</span> @(ddr_addr)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$fdisplay</span>(w_file,<span class="string">&quot;%x\n&quot;</span>,rom_data_I);</span><br><span class="line">    <span class="keyword">if</span>(i  <span class="number">8&#x27;d254</span>)    <span class="comment">//共写入254个数据</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;//*********Write done!*********//&quot;</span>);</span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="readmemh-readmemb"><a href="#readmemh-readmemb" class="headerlink" title="$readmemh, $readmemb"></a>$readmemh, $readmemb</h3><p>这两个系统任务是用来从指定文件中读取数据到寄存器数组或者RAM、ROM中。除了可以在仿真的任何时刻被执行使用外，根据综合工具的不同，也可以用来对RAM或者ROM进行初始化（Vivado支持）。</p>
<p>使用格式共6种：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$readmemb</span> (<span class="string">&quot;&lt;数据文件名&gt;&quot;</span>,&lt;数组名&gt;)</span><br><span class="line"><span class="built_in">$readmemb</span> (<span class="string">&quot;&lt;数据文件名&gt;&quot;</span>,&lt;数组名&gt;,&lt;起始地址&gt;）</span><br><span class="line"><span class="built_in">$readmemb</span> (<span class="string">&quot;&lt;数据文件名&gt;&quot;</span>,&lt;存贮器名&gt;,&lt;起始地址&gt;,&lt;结束地址&gt;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">$readmemh</span> (<span class="string">&quot;&lt;数据文件名&gt;&quot;</span>,&lt;数组名&gt;)</span><br><span class="line"><span class="built_in">$readmemh</span> (<span class="string">&quot;&lt;数据文件名&gt;&quot;</span>,&lt;数组名&gt;,&lt;起始地址&gt;）</span><br><span class="line"><span class="built_in">$readmemh</span> (<span class="string">&quot;&lt;数据文件名&gt;&quot;</span>,&lt;数组名&gt;,&lt;起始地址&gt;,&lt;结束地址&gt;)</span><br></pre></td></tr></table></figure>
<p>$readmemh（h，hexadecimal，十六进制）用来读取16进制的数据，而$readmemb（b，binary，二进制）则用来读取2进制的数据。       </p>
<p>由于$readmemh与$readmemb的用法几乎一样，仅仅是读取数字的进制不同。</p>
<hr>
<h4 id="数据文件格式"><a href="#数据文件格式" class="headerlink" title="数据文件格式"></a>数据文件格式</h4><p>在这两个系统任务中，被读取的数据文件的内容只能包含：空白位置（空格、换行、制表格、注释行、二进制或十六进制的数字。数字中不能包含位宽说明和格式说明，对于$readmemb和$readmemh系统任务，每个数字可以是二进制或者十六进制数字。另外，数字必须用空白位置或注释行来分隔开。</p>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324002434250.png" alt="image-20230324002434250"></p>
<hr>
<h4 id="数据文件路径表示方法"><a href="#数据文件路径表示方法" class="headerlink" title="数据文件路径表示方法"></a>数据文件路径表示方法</h4><p>可以用两种路径表示方法来指导综合工具找到你的数据文件：1、绝对路径；2、相对路径。</p>
<ul>
<li>绝对路径</li>
</ul>
<p>绝对路径就是数据文件在系统中的位置，比如：</p>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324002752681.png" alt="image-20230324002752681"></p>
<p>数据文件data.txt的绝对路径就是 D:\read_test\read_test.srcs\sim_1\new<br>但是一定需要注意的是，尽管在windows系统中使用<strong>斜杠 \</strong> 来表示不同的层级，但是在系统函数$readmemh中取需要使用<strong>反斜杠 &#x2F;</strong> 来表示层级，如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$readmemh</span>(<span class="string">&quot;D:/read_test/read_test.srcs/sim_1/new/data.txt&quot;</span>,mem_test);  <span class="comment">//绝对路径</span></span><br></pre></td></tr></table></figure>


<p>这样综合工具就会去这个目录下寻找数据文件。</p>
<ul>
<li>相对路径</li>
</ul>
<p>相对路径是根据仿真文件或者RTL文件的位置来相关的。<br>比如在vivado中使用系统函数$readmemh时采用如下表示方法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$readmemh</span>(<span class="string">&quot;data.txt&quot;</span>,mem_test);        <span class="comment">//相对路径</span></span><br></pre></td></tr></table></figure>

<p>同时，数据文件必须放在这个路径下：</p>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324003100395.png" alt="image-20230324003100395"></p>
<p>综合工具就会直接去该目录下寻找数据文件，如果该目录下没有指定的数据文件，则会发出警告，同时仿真读取的值都是x</p>
<hr>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>使用的数据文件data.txt如下:</p>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324124206191.png" alt="image-20230324124206191"></p>
<hr>
<ul>
<li><strong>不指定起始地址和结束对应地址</strong></li>
</ul>
<p>即**$readmemh(“&lt;数据文件名&gt;”,&lt;数组名&gt;)**，此时会将从数据文件中读到的第1个数据填入数组的第0个位置，此后类推，直到数组被填满。如果数据的个数大于数据文件中数据的个数，则数组无法被填满，未被填满的部分则依然未被赋值。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ns</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> tb_read_test();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">integer</span> i;	 </span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] mem_test [<span class="number">9</span>:<span class="number">0</span>];		<span class="comment">//mem_test是位宽8bit，个数为10的数组</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="built_in">$readmemh</span>(<span class="string">&quot;D:/read_test/read_test.srcs/sim_1/new/data.txt&quot;</span>,mem_test);	<span class="comment">//绝对路径</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//显示数组的10个值</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i=i+<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">$display</span>(<span class="string">&quot;%d: %h&quot;</span>, i, mem_test[i]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> 	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<ul>
<li>数据被填满，仿真结果如下:</li>
</ul>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324124242602.png" alt="image-20230324124242602"></p>
<ul>
<li>去除部分数据文件中的数据，导致数组无法被填满（注释掉后面4个数据），仿真结果如下：</li>
</ul>
<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324124458164.png" alt="image-20230324124458164"></p>
<hr>
<ul>
<li><strong>指定起始地址，但不指定结束地址</strong></li>
</ul>
<p> 即$readmemh (“&lt;数据文件名&gt;”,&lt;数组名&gt;,&lt;起始地址&gt;），此时会将从数据文件中读到的第1个数据填入数组的起始地址，此后类推，直到数组被填满。而之前被起始地址跳过的数组的数据则不会被赋值。如果数据的个数大于数据文件中数据的个数，则数组无法被填满，未被填满的部分则依然是未知状态。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="built_in">$readmemh</span>(<span class="string">&quot;D:/read_test/read_test.srcs/sim_1/new/data.txt&quot;</span>,mem_test,<span class="number">2</span>);	<span class="comment">//绝对路径,从地址2开始</span></span><br></pre></td></tr></table></figure>

<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324124832945.png" alt="image-20230324124832945"></p>
<hr>
<ul>
<li><strong>同时指定起始地址和结束地址</strong></li>
</ul>
<p> 即$readmemh (“&lt;数据文件名&gt;”,&lt;数组名&gt;,&lt;起始地址&gt;,&lt;结束地址&gt;)，此时会将从数据文件中读到的第1个数据填入数组的起始地址，此后类推，直到指定的终结地址对应的数组也被赋值。处于起始地址和终结地址构成的区间范围外的地址对应的数组则不会被赋值。如果数据的个数大于数据文件中数据的个数，则数组无法被填满，未被填满的部分则依然是未知状态。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="built_in">$readmemh</span>(<span class="string">&quot;D:/read_test/read_test.srcs/sim_1/new/data.txt&quot;</span>,mem_test,<span class="number">2</span>,<span class="number">8</span>);	<span class="comment">//绝对路径,从地址2开始</span></span><br></pre></td></tr></table></figure>

<p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20230324124947230.png" alt="image-20230324124947230"></p>
<h3 id="finish、-stop"><a href="#finish、-stop" class="headerlink" title="$finish、$stop"></a>$finish、$stop</h3><p><strong>$finish</strong></p>
<p> <strong>系统任务$finish的作用是退出仿真器</strong>，结束仿真过程。</p>
<p>当$finish带参数时，如$finish(2)，根据不同的参数值，系统输出信息不同：</p>
<ul>
<li>0：不输出任何信息；</li>
<li>1：输出当前仿真时刻和位置；</li>
<li>2：输出当前仿真时刻、位置和仿真过程中所用的memory及CPU时间的统计。</li>
</ul>
<p>​    当$finish后面不带参数时，则默认参数为1。</p>
<hr>
<p><strong>$stop</strong></p>
<p> $stop任务的作用是把仿真器置为暂停模式，在仿真环境下给出一个交互式的命令提示符，将控制权交给用户，格式与$finish类似。</p>
<p>当$stop带参数时，如$stop(2)，根据不同的参数值，系统输出信息不同：</p>
<ul>
<li>0：不输出任何信息；</li>
<li>1：输出当前仿真时刻和位置；</li>
<li>2：输出当前仿真时刻、位置和仿真过程中所用的memory及CPU时间的统计。</li>
</ul>
<p>​    当$stop后面不带参数时，则默认参数为1。</p>
<hr>
<p><strong>总结</strong></p>
<ul>
<li>$finish可以终止仿真，一般用在仿真的结尾处。例如完成某些特定激励的仿真后将仿真终止，防止仿真不停地运行</li>
<li>$stop可以暂停仿真，一般用来在某个特定的时间暂定仿真</li>
<li>$stop和$finish常用在测试模块的initial模块中，配合时间延迟用来控制仿真的持续时间</li>
</ul>
<h3 id="force"><a href="#force" class="headerlink" title="force"></a>force</h3><h2 id="层级结构和引用"><a href="#层级结构和引用" class="headerlink" title="层级结构和引用"></a>层级结构和引用</h2><h2 id="Verilog-模板"><a href="#Verilog-模板" class="headerlink" title="Verilog 模板"></a>Verilog 模板</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> 模块名</span><br><span class="line">    #(	<span class="keyword">parameter</span> AW = <span class="number">2</span> ,</span><br><span class="line">     	<span class="keyword">parameter</span> DW = <span class="number">3</span> )</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">input</span>				clk,</span><br><span class="line">        <span class="keyword">input</span>  [AW-<span class="number">1</span>:<span class="number">0</span>]		A,</span><br><span class="line">        <span class="keyword">output</span> <span class="keyword">reg</span> [DW-<span class="number">1</span>:<span class="number">0</span>]	Q</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">wire</span> [AW-<span class="number">1</span>:<span class="number">0</span>] data1;</span><br><span class="line">    <span class="keyword">reg</span>  [DW-<span class="number">1</span>:<span class="number">0</span>] data2;</span><br><span class="line">    <span class="keyword">reg</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  mem [<span class="number">0</span>:(<span class="number">1</span>&lt;&lt;AW)-<span class="number">1</span>] ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//state</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE  = <span class="number">4&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">localparam</span> START = <span class="number">4&#x27;d1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> data1 = A;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>()<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    add </span><br><span class="line">    <span class="variable">#(	.AW (AW)</span>,</span><br><span class="line">      	<span class="variable">.DW</span> (DW)</span><br><span class="line">     )u_add(</span><br><span class="line">        <span class="variable">.clk</span>	(clk),</span><br><span class="line">        <span class="variable">.rst</span>	(rst)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><h3 id="标识符（Identifiers）命名习惯"><a href="#标识符（Identifiers）命名习惯" class="headerlink" title="标识符（Identifiers）命名习惯"></a>标识符（Identifiers）命名习惯</h3><h4 id="标识符定义命名"><a href="#标识符定义命名" class="headerlink" title="标识符定义命名"></a>标识符定义命名</h4><ul>
<li><p>标识符第一个字符必须是字母，最后一个字符不能是下划线，不许出现连续两个下划线；</p>
</li>
<li><p>基本标识符只能由字母、数字和下划线组成；</p>
</li>
<li><p>标识符两词之间需用下划线连接</p>
<p>如：Packet_addr    ,  Data_in</p>
</li>
<li><p>标识符不得与保留字同名</p>
</li>
</ul>
<h4 id="标识符大小写"><a href="#标识符大小写" class="headerlink" title="标识符大小写"></a>标识符大小写</h4><ul>
<li>对常量、数据类型、实体名和结构体名采用全部大写；</li>
<li>对变量采用小写；</li>
<li>对信号采用第一个词首字符大写；</li>
<li>保留字一律小写</li>
</ul>
<h4 id="信号名连贯缩写"><a href="#信号名连贯缩写" class="headerlink" title="信号名连贯缩写"></a>信号名连贯缩写</h4><p><strong>部分缩写的统一规定为</strong>：</p>
<p>Addr   address;     Clk   clock;     Clr   clear;     Cnt   counter</p>
<p>En   enable;     Inc   increase;     Lch   latch;     Mem   memory</p>
<p>Pntr   pointer;     Pst   preset;     Rst   reset</p>
<p>Reg   register;     Rd   reader;     Wr   write</p>
<p><strong>常用多个单次的缩写</strong></p>
<p>ROM     RAM     CPU     FIFO     ALU     CS     CE</p>
<p><strong>自定义的缩写必须在文件头注释</strong></p>
<h4 id="信号名缩写的大小写"><a href="#信号名缩写的大小写" class="headerlink" title="信号名缩写的大小写"></a>信号名缩写的大小写</h4><ul>
<li>单次的缩写若是信号名的第一个单次则首字母大写，如：Addr_in 中的 Addr；若该代词缩写不是第一个单词则小写，如：Addr_en 中的 en</li>
<li>多个单次的首字母缩写都大写，不管该缩写在标识符的什么位置，如：RAM_addr，Rd_CPU_en</li>
</ul>
<h4 id="信号名一致性"><a href="#信号名一致性" class="headerlink" title="信号名一致性"></a>信号名一致性</h4><p>同一信号在不同层次应保持一致性</p>
<h4 id="信号命名建议"><a href="#信号命名建议" class="headerlink" title="信号命名建议"></a>信号命名建议</h4><p><img src="/MD_IMG/Verilog%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80.assets/image-20220701173324871.png" alt="image-20220701173324871"></p>
<h3 id="其它注意地方"><a href="#其它注意地方" class="headerlink" title="其它注意地方"></a>其它注意地方</h3><ul>
<li>只有三态电路才可以在多个process 中出现</li>
<li>使用 Latch 必须有所记录，不希望使用 Latch 时，应该将条件赋值语句写全，如在 if 语句最后加 else，case 语句后加 others</li>
<li>TAB键的间隔，采用4个字符</li>
<li>若元件的类属在定义时已经指定默认值，在调用时，若不改变该参数值可以不用定义实参的映射，即map（实参）可不写</li>
<li>建议运算操作符两边都加上空格</li>
<li>向量比较时，比较的向量的位宽要相等</li>
<li></li>
</ul>
<h3 id="代码模块划分"><a href="#代码模块划分" class="headerlink" title="代码模块划分"></a>代码模块划分</h3><p>设计模块的基本原则是：</p>
<ol>
<li><p>有利于模块的可重用性</p>
</li>
<li><p>在组合电路设计中应当没有层次</p>
</li>
<li><p>每个模块输出尽量采用寄存器输出</p>
</li>
<li><p>模块按功能进行划分，划分要合理</p>
</li>
<li><p>模块大小应适中，一般为2000门左右</p>
</li>
<li><p>模块的层次应当至少有三级，可将一个设计划分为三个层次：TOP、MID、功能CORE</p>
<ul>
<li><p>TOP</p>
<p>包括实例化的MID和输入输出定义</p>
</li>
<li><p>MID</p>
<p>由两部分组成：1）时钟产生电路；2）功能CORE的实例化</p>
</li>
<li><p>功能CORE</p>
<p>包括各种功能电路的设计。一个复杂的功能可以分成多个子功能来实现，即再划分子层</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Vivado</title>
    <url>/2023/07/08/Vivado/</url>
    <content><![CDATA[<h2 id="如何修改工程名称"><a href="#如何修改工程名称" class="headerlink" title="如何修改工程名称"></a>如何修改工程名称</h2><p>主要将 xxx.xpr文件和工程子文件夹名称修改</p>
<p><img src="/MD_IMG/Vivado%E8%BD%AF%E4%BB%B6.assets/image-20230624225427709.png" alt="image-20230624225427709"></p>
<img src="/MD_IMG/Vivado软件.assets/image-20230624225516561.png" alt="image-20230624225516561" style="zoom: 80%;" />

<h2 id="如何保存-x2F-恢复时序报告（-rpx"><a href="#如何保存-x2F-恢复时序报告（-rpx" class="headerlink" title="如何保存&#x2F;恢复时序报告（.rpx)"></a>如何保存&#x2F;恢复时序报告（.rpx)</h2><h2 id="如何生成网表"><a href="#如何生成网表" class="headerlink" title="如何生成网表"></a>如何生成网表</h2><ol>
<li><p>打开所要封装网表的工程，点击 Tool-&gt;Settings</p>
</li>
<li><p>点击 Synthesis，修改 Options 中的内容</p>
</li>
<li><p>-flatten_hierarchy 下拉框，改为 full</p>
</li>
<li><p>More Options 中输入 -mode out_of_context</p>
</li>
<li><p>将带封装文件设置为Top层</p>
</li>
<li><p>点击 Run Synthesis 进行文件综合，综合完成后打开综合</p>
</li>
<li><p>若生成 Verilog 文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">write_verilog -mode synth_stub E:<span class="regexp">/TX0121010/</span>src<span class="regexp">/ngc/i</span>nt_ctrl_axi.v</span><br></pre></td></tr></table></figure>
</li>
<li><p>若生成 VHDL 文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">write_vhdl -mode synth_stub E:<span class="regexp">/TX0121010/</span>src<span class="regexp">/ngc/i</span>nt_ctrl_axi.vhd</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成网表文件</p>
<ul>
<li><p>若要封装的文件中未使用 xilinx 官方的IP，网表生成指令如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">write_edif all E:<span class="regexp">/TX0121010/</span>src<span class="regexp">/ngc/i</span>nt_ctrl_axi.edf</span><br></pre></td></tr></table></figure>
</li>
<li><p>若要封装的文件中使用 xilinx官方的IP，网表生成指令如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">write_edif -security_mode all E:<span class="regexp">/TX0121010/</span>src<span class="regexp">/ngc/i</span>nt_ctrl_axi.edf</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Modelsim覆盖率分析"><a href="#Modelsim覆盖率分析" class="headerlink" title="Modelsim覆盖率分析"></a>Modelsim覆盖率分析</h2><p><img src="/MD_IMG/Vivado%E8%BD%AF%E4%BB%B6.assets/image-20230119154330256.png" alt="image-20230119154330256"></p>
<h2 id="Debug信号（VHDL）"><a href="#Debug信号（VHDL）" class="headerlink" title="Debug信号（VHDL）"></a>Debug信号（VHDL）</h2><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attribute</span> MARK_DEBUG : <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">attribute</span> MARK_DEBUG : <span class="keyword">signal</span> <span class="keyword">is</span> <span class="string">&quot;TRUE&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Force-Up-to-Data-功能"><a href="#Force-Up-to-Data-功能" class="headerlink" title="Force Up-to-Data 功能"></a>Force Up-to-Data 功能</h2><p>当只加了注释，或修改了代码格式，并没有进行功能上的更改时，不需要重新运行综合&#x2F;实现来浪费时间，可以强制更新为Complete</p>
<h2 id="不建Vivado工程，也能看Device视图"><a href="#不建Vivado工程，也能看Device视图" class="headerlink" title="不建Vivado工程，也能看Device视图"></a>不建Vivado工程，也能看Device视图</h2><p>在FPGA设计与开发中，Device视图和Package视图发挥着重要的作用。</p>
<p>在Device视图下：</p>
<ul>
<li><strong>可以查看FPGA芯片可用资源</strong></li>
</ul>
<p>例如：LUT、FF、BRAM、DSP、URAM等的个数；</p>
<ul>
<li><strong>可以查看关键资源的分布情况</strong></li>
</ul>
<p>例如：PCIE的位置，高速收发器的位置，因为这些位置直接影响到PCB设计以及FPGA内部的数据流。</p>
<ul>
<li><strong>可用查看MMCM等时钟资源的位置</strong></li>
</ul>
<p>时钟的拓扑结构的质量直接影响到设计后期的时序收敛，在多die芯片中，这一点尤为重要。例如：某个芯片是3个die，设计中的一个时钟要给这3个die使用，那么最好将该时钟分配在中间那个die上，这样跨die次数最小，比较时钟跨die会增加Clock Skew。</p>
<p>那么如何打开Device视图呢？一种可行的方法是创建Vivado I&#x2F;O工程，但这仍然显得繁琐。这里我们介绍一种更为直接的方法，就是使用Tcl命令link_design。打开Vivado，在Tcl Console中直接输入如下图所示命令：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">link_design -part xc7a100tfgg676<span class="number">-2</span></span><br></pre></td></tr></table></figure>

<p>此时，该命令后只需跟随一个选项，即-part，-part用于指明具体的芯片型号。这样就打开了Vivado，之后选择Window，点击Device即可打开Device视图，点击Package即可打开Package视图。</p>
<img src="/MD_IMG/Vivado软件.assets/image-20211223092634079-16800652291141.png" alt="image-20211223092634079" style="zoom: 60%;" />

<img src="/MD_IMG/Vivado软件.assets/image-20211223092705263-16800652291162.png" alt="image-20211223092705263" style="zoom:60%;" />

<h2 id="联合VScode"><a href="#联合VScode" class="headerlink" title="联合VScode"></a>联合VScode</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">C:/Softwares/VS Code/Code.<span class="keyword">exe</span> -g [<span class="keyword">file</span> name]:[<span class="built_in">line</span> <span class="keyword">number</span>]</span><br></pre></td></tr></table></figure>



<h2 id="联合-Modelsim"><a href="#联合-Modelsim" class="headerlink" title="联合 Modelsim"></a>联合 Modelsim</h2><p>见文件链接 <a href="./Modelsim%E4%BB%BF%E7%9C%9F.md">Modelsim仿真</a></p>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>软件使用</tag>
        <tag>Vivado</tag>
      </tags>
  </entry>
  <entry>
    <title>axi_quad_spi</title>
    <url>/2023/07/08/axi_quad_spi/</url>
    <content><![CDATA[<h2 id="系统框图"><a href="#系统框图" class="headerlink" title="系统框图"></a>系统框图</h2><h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p><img src="/MD_IMG/axi_quad_spi.assets/image-20230603224844537.png" alt="image-20230603224844537"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230603230735125.png" alt="image-20230603230735125"></p>
<h3 id="XIP模式"><a href="#XIP模式" class="headerlink" title="XIP模式"></a>XIP模式</h3><p><img src="/MD_IMG/axi_quad_spi.assets/image-20230603234947885.png" alt="image-20230603234947885"></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604162323509.png" alt="image-20230604162323509"></p>
<h2 id="IP-核配置"><a href="#IP-核配置" class="headerlink" title="IP 核配置"></a>IP 核配置</h2><p><img src="/MD_IMG/axi_quad_spi.assets/image-20230603235750254.png" alt="image-20230603235750254"></p>
<h3 id="AXI-Interface-Option"><a href="#AXI-Interface-Option" class="headerlink" title="AXI Interface Option"></a>AXI Interface Option</h3><h4 id="XIP-Mode"><a href="#XIP-Mode" class="headerlink" title="XIP Mode"></a>XIP Mode</h4><p>XIP全称：eXecute In Place（片内执行），只用于读操作。针对外设如果想进行读操作的时候，一般都是通过访问数据寄存器，而XIP则是直接以内存的形式访问。</p>
<hr>
<p><strong>为什么有XIP模式</strong></p>
<p>从软件的角度来看，SPI一般是连着flash来使用，flash作为一种存储模块，软件更加期望用memory的形式访问，在SoC上经常会有从flash里面搬运数据的需求。</p>
<hr>
<p><strong>XIP性能</strong></p>
<p>一般来说，non-xip模式下，由于可以通过寄存器配置来实现给出一个地址得到一大段的数据的操作，只要配置得当，数据读取的速率是会比xip模式下快的。</p>
<p>但是不同公司的SPI controller的寄存器配置肯定是不同的，完全使用寄存器配置的形式进行读取操作对于软件迁移的成本会比较大。</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604000449433.png" alt="image-20230604000449433"></p>
<h4 id="Performance-Mode"><a href="#Performance-Mode" class="headerlink" title="Performance Mode"></a>Performance Mode</h4><p>高性能模式将使用 AXI4 代替 AXI4-Lite 接⼝，并且在内核的发送和接收 FIFO 地址处可以使用突发功能。</p>
<h3 id="SPI-Options"><a href="#SPI-Options" class="headerlink" title="SPI Options"></a>SPI Options</h3><h4 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h4><p>模式有standard，dual，quad可选，standard和dual&#x2F;quad模式间有部分功能不能兼容，具体可以看下面寄存器映射中。</p>
<h4 id="Transaction-Width"><a href="#Transaction-Width" class="headerlink" title="Transaction Width"></a>Transaction Width</h4><p>设置传输事务的数据宽度：</p>
<ul>
<li><p>如果设置为8，即每次数据传输宽度为8-bit，一次数据传输需要8个SCK时钟</p>
</li>
<li><p>如果设置为16，即每次数据传输宽度为16-bit，一次数据传输需要16个SCK时钟</p>
</li>
</ul>
<h4 id="Frequency-Ratio"><a href="#Frequency-Ratio" class="headerlink" title="Frequency Ratio"></a>Frequency Ratio</h4><p>频率比是由两个数的乘积。输出的SPI时钟（sck）满足：</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604000811474.png" alt="image-20230604000811474"></p>
<h4 id="Slave-Device"><a href="#Slave-Device" class="headerlink" title="Slave Device"></a>Slave Device</h4><p>设备类型是混合的，支持winbond，micron，spansion，macronix共有的命令。如果勾选Micron，只能支持micron的命令，发送不支持的命令，IPISR状态寄存器就会报command error.</p>
<h4 id="Enable-Master-Mode"><a href="#Enable-Master-Mode" class="headerlink" title="Enable Master Mode"></a>Enable Master Mode</h4><p>这个选项决定SPI设备的主从模式，也可以在配置寄存器60h中修改</p>
<h4 id="Enable-STARTUP-Primitive"><a href="#Enable-STARTUP-Primitive" class="headerlink" title="Enable STARTUP Primitive"></a>Enable STARTUP Primitive</h4><p>STARTUP原语勾选上后指SPI的clk就会从FPGA专用的CCLK引脚输出时钟</p>
<h2 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h2><p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604001550143.png" alt="image-20230604001550143"></p>
<h3 id="0x40-SRR-软件复位"><a href="#0x40-SRR-软件复位" class="headerlink" title="0x40 (SRR) 软件复位"></a>0x40 (SRR) 软件复位</h3><p>将0x0000_000a的值写⼊软件复位寄存器，会将内核寄存器复位四个 AXI 时钟周期。任何其他写访问都会⽣成未定义的结果并导致错误。</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604002806486.png" alt="image-20230604002806486"></p>
<h3 id="0x60-SPICR-SPI控制"><a href="#0x60-SPICR-SPI控制" class="headerlink" title="0x60 (SPICR) SPI控制"></a>0x60 (SPICR) SPI控制</h3><p>SPI控制寄存器有着配置SPI时序工作方式（CPHA，CPOL），设置SPI设备主从状态，对数据寄存器进行复位等重要功能。需要注意：</p>
<ul>
<li>LSB 优先仅在标准 SPI 模式下支持。 Dual&#x2F;quad SPI 模式仅⽀持 MSB 优先模式</li>
<li>Dual&#x2F;quad SPI 模式仅⽀持 CPHA-CPOL 值为 00 或 11。</li>
<li>环回模式仅在标准 SPI 模式下支持。</li>
</ul>
<p>通常作为配置端，我们需要把SPI设置为主设备（SPICR【2】&#x3D;1），在测试工作状态时，可以设置环回模式（SPICR【0】&#x3D;1）</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604003253814.png" alt="image-20230604003253814"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604003204304.png" alt="image-20230604003204304"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604003227262.png" alt="image-20230604003227262"></p>
<h3 id="0x64-SPISR-SPI状态"><a href="#0x64-SPISR-SPI状态" class="headerlink" title="0x64 (SPISR) SPI状态"></a>0x64 (SPISR) SPI状态</h3><p>SPI状态寄存器是<strong>只读寄存器</strong>，通常用来：</p>
<ul>
<li>读取各种错误信息，即SPI控制寄存器中的配置错误（注意事项）。</li>
<li>从模式配置成功检查</li>
<li>数据FIFO的空满状态检查</li>
</ul>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604003644444.png" alt="image-20230604003644444"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604003921784.png" alt="image-20230604003921784"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604003823390.png" alt="image-20230604003823390"></p>
<h3 id="0x68-SPI-DTR-发送数据"><a href="#0x68-SPI-DTR-发送数据" class="headerlink" title="0x68 (SPI DTR) 发送数据"></a>0x68 (SPI DTR) 发送数据</h3><p>SPI 数据发送寄存器 (SPI DTR) 写⼊要在 SPI 总线上发送的数据。数据从 SPI DTR 传输到移位寄存器发送条件：</p>
<ul>
<li>在主模式下将 SPE （SPI控制寄存器）设置为 1</li>
<li>在从模式下， spisel 处于活动状态</li>
</ul>
<p>需要注意：</p>
<ul>
<li>SPI DTR 在填充前应处于复位状态，以便 DTR FIFO 写指针指向第 0 个位置。</li>
<li>如果尝试在已满的寄存器或 FIFO 上进写⼊，则 AXI 写⼊事务以错误条件完成。</li>
</ul>
<p>即在发送数据前，需要先在控制寄存器中对TX FIFO进行复位。</p>
<p><strong>在Dual&#x2F;quad SPI 模式</strong>：</p>
<ul>
<li>第⼀次写⼊必须始终是来⾃ AXI 事务的 SPI 命令，然后是地址（24 位或 32 位），然后填充要传输的数据。</li>
<li>在读取内存的状态寄存器时，根据命令要求，该寄存器应填充虚拟字节以及命令和地址（可选）。</li>
</ul>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604003956744.png" alt="image-20230604003956744"></p>
<h3 id="0x6c-SPI-DRR-接收数据"><a href="#0x6c-SPI-DRR-接收数据" class="headerlink" title="0x6c (SPI DRR) 接收数据"></a>0x6c (SPI DRR) 接收数据</h3><p>SPI 数据接收寄存器 (SPI DRR) ⽤于读取从 SPI 总线接收的数据。这是⼀个双缓冲寄存器。每次完成传输后，接收到的数据都存放在该寄存器中。</p>
<p>SPI 架构没有为从设备提供任何⼿段来限制总线上的流量。因此，对于从设备来说，只有在上次 SPI 传输之前读取 SPI DRR ，SPI DRR 才会在每个完成的事务之后更新。</p>
<p>需要注意：</p>
<ul>
<li>如果 SPI DRR 未读取且已满，则最近传输的数据将丢失并发⽣接收溢出中断。</li>
<li>如果试图读取⼀个空的接收寄存器或 FIFO，它会在状态寄存器中给出⼀个错误。</li>
<li>SPI DRR 的上电复位值未知。</li>
</ul>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004021970.png" alt="image-20230604004021970"></p>
<h3 id="0x70-SPISSR-从机选择"><a href="#0x70-SPISSR-从机选择" class="headerlink" title="0x70 (SPISSR) 从机选择"></a>0x70 (SPISSR) 从机选择</h3><p>选择slave个数，有几个slave就拉低几位，最多32个slave</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004043039.png" alt="image-20230604004043039"></p>
<h3 id="0x74-发送FIFO待发送数据量"><a href="#0x74-发送FIFO待发送数据量" class="headerlink" title="0x74 发送FIFO待发送数据量"></a>0x74 发送FIFO待发送数据量</h3><p>仅当 AXI Quad SPI 内核配置有 FIFO （FIFO 深度&#x3D; 16 或 256）时，SPI 发送 FIFO 占⽤寄存器 (TX_FIFO_OCY) 才存在，并且是只读寄存器。</p>
<p>主要用来查看发送FIFO中有多少个数据，比如读出是5，那么FIFO中还有6个数据待发送</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004059549.png" alt="image-20230604004059549"></p>
<h3 id="0x78-接收FIFO可读取数据量"><a href="#0x78-接收FIFO可读取数据量" class="headerlink" title="0x78 接收FIFO可读取数据量"></a>0x78 接收FIFO可读取数据量</h3><p>仅当 AXI Quad SPI 内核配置有 FIFO （FIFO 深度&#x3D; 16 或 256）时，SPI 接收 FIFO 占⽤寄存器 (RX_FIFO_OCY) 才存在。</p>
<p>主要用来查看接收FIFO中有多少个数据，比如读出是5，那么FIFO中还有6个数据还没接收走。</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004116322.png" alt="image-20230604004116322"></p>
<h3 id="0x1C-DGIER-全局中断使能"><a href="#0x1C-DGIER-全局中断使能" class="headerlink" title="0x1C (DGIER) 全局中断使能"></a>0x1C (DGIER) 全局中断使能</h3><p>使能了全局中断之后才能使用各种中断功能。</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004133556.png" alt="image-20230604004133556"></p>
<h3 id="0x20-IPISR-中断状态"><a href="#0x20-IPISR-中断状态" class="headerlink" title="0x20 (IPISR) 中断状态"></a>0x20 (IPISR) 中断状态</h3><p>由于中断端口只有一个，当中断发送时需要查询中断状态寄存器来判断是什么中断情况，具体使用什么中断功能由中断使能寄存器控制。</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004157069.png" alt="image-20230604004157069"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004227902.png" alt="image-20230604004227902"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004249905.png" alt="image-20230604004249905"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004307595.png" alt="image-20230604004307595"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004319017.png" alt="image-20230604004319017"></p>
<h3 id="0x28-IPIER-中断使能"><a href="#0x28-IPIER-中断使能" class="headerlink" title="0x28 (IPIER) 中断使能"></a>0x28 (IPIER) 中断使能</h3><p>主要是配置中断功能，由于中断功能是复用中断端口，因此需要选择合理的功能来减少控制复杂度</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004347277.png" alt="image-20230604004347277"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004425794.png" alt="image-20230604004425794"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004439199.png" alt="image-20230604004439199"></p>
<h3 id="XIP-模式"><a href="#XIP-模式" class="headerlink" title="XIP 模式"></a>XIP 模式</h3><p>在XIP模式，配置寄存器60h和64h变更，并且中断无法使用。</p>
<p>XIP模式适⽤于开机操作。在这种模式下，内核仅⽀持 INCR 和 WRAP 读取事务。</p>
<p>内核将 SPI 视为只读存储器。三个读取命令随读取 SPI 闪存时使⽤的配置模式提供。通过为 AXI4-Lite 和 AXI4 接⼝分配相同的频率来验证核⼼功能。内核内置的三个主要读取命令是快速读取 (0x0Bh)、DIOFR (0xBBh) 和 QIOFR (0xEBh)。</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604004542320.png" alt="image-20230604004542320"></p>
<h2 id="支持指令"><a href="#支持指令" class="headerlink" title="支持指令"></a>支持指令</h2><h3 id="通用指令"><a href="#通用指令" class="headerlink" title="通用指令"></a>通用指令</h3><p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604163057685.png" alt="image-20230604163057685"></p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604163103808.png" alt="image-20230604163103808"></p>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><p>详见 <strong>PG153 AXI Quad SPI <strong>的</strong>Table 3-3</strong></p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604164316567.png" alt="image-20230604164316567"></p>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604164327376.png" alt="image-20230604164327376"></p>
<h2 id="Flash控制"><a href="#Flash控制" class="headerlink" title="Flash控制"></a>Flash控制</h2><h3 id="读ID"><a href="#读ID" class="headerlink" title="读ID"></a>读ID</h3><p>读ID指令为9F，读几个数据就写几个dummy数据，读fifo的第一个数据是FF，因为写指令占用了，第二个数据开始才是想要的数据。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> RDID</span> &#123;byte_num&#125; &#123;</span><br><span class="line"><span class="comment">    # 软件复位</span></span><br><span class="line">    WriteReg <span class="number">0x40</span> <span class="number">0xa</span></span><br><span class="line"><span class="comment">    # 中断使能</span></span><br><span class="line">    WriteReg <span class="number">0x28</span> <span class="number">0x3fff</span></span><br><span class="line"><span class="comment">    # 全局中断使能</span></span><br><span class="line">    WriteReg <span class="number">0x1c</span> <span class="number">0x80000000</span></span><br><span class="line"><span class="comment">    # 复位 tx rx fifo</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x1e6</span></span><br><span class="line"><span class="comment">    # 释放 fifo 复位</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"><span class="comment">    # CMD = 9F, 读 FLASH ID</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="number">0x9f</span></span><br><span class="line"><span class="comment">    # 要读多少个数据就写几个 dummy 数据</span></span><br><span class="line">    <span class="keyword">set</span> num <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> &#123;<span class="variable">$num</span> &lt; <span class="variable">$byte_num</span>&#125; &#123;</span><br><span class="line">        WriteReg <span class="number">0x68</span> <span class="number">0x00</span></span><br><span class="line">        <span class="keyword">incr</span> num <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">    # 选择 0 通道CS</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x00</span></span><br><span class="line"><span class="comment">    # 使能 master, 开始发数据</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x86</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS 拉高</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x1</span></span><br><span class="line"><span class="comment">    # 禁用 master</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> num <span class="number">0</span></span><br><span class="line">    <span class="keyword">set</span> id_data <span class="string">&quot;RDID is &quot;</span></span><br><span class="line">    <span class="keyword">while</span> &#123;<span class="variable">$num</span> &lt; <span class="variable">$byte_num</span> + <span class="number">1</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> &#123;<span class="variable">$num</span> &gt;= <span class="number">1</span>&#125; &#123;</span><br><span class="line">            <span class="keyword">append</span> id_data [<span class="keyword">string</span> range [ReadReg <span class="number">0x6c</span>] end<span class="number">-1</span> end]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ReadReg <span class="number">0x6c</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">incr</span> num <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$id_data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写使能"><a href="#写使能" class="headerlink" title="写使能"></a>写使能</h3><p>每次进行擦除或者写操作之前都要先开启写使能，否则不生效。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> WREN</span> &#123;&#125; &#123;</span><br><span class="line"><span class="comment">    # 复位 tx rx fifo</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x1e6</span></span><br><span class="line"><span class="comment">    # 释放 fifo 复位</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"><span class="comment">    # CMD = 06, 写使能</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="number">0x06</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x00</span></span><br><span class="line"><span class="comment">    # 使能 master, 开始发数据</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x86</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS 拉高</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x1</span></span><br><span class="line"><span class="comment">    # 禁用 master</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Write Enable!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扇区擦除"><a href="#扇区擦除" class="headerlink" title="扇区擦除"></a>扇区擦除</h3><p>先发送写使能指令，再发送扇区擦除指令</p>
<hr>
<p>对于 N25Q128 FLASH</p>
<p><img src="/MD_IMG/axi_quad_spi.assets/image-20230604212044485.png" alt="image-20230604212044485"></p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> SE</span> &#123;Sector_Num&#125; &#123;</span><br><span class="line">    WREN</span><br><span class="line"><span class="comment">    # 复位 tx rx fifo</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x1e6</span></span><br><span class="line"><span class="comment">    # 释放 fifo 复位</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"><span class="comment">    # CMD = d8, 扇区擦除</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="number">0xd8</span></span><br><span class="line"><span class="comment">    # Write Address</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="variable">$Sector_Num</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="number">0x00</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="number">0x00</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x00</span></span><br><span class="line"><span class="comment">    # 使能 master, 开始发数据</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x86</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS 拉高</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x1</span></span><br><span class="line"><span class="comment">    # 禁用 master</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Sector Erase Done!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整片擦除"><a href="#整片擦除" class="headerlink" title="整片擦除"></a>整片擦除</h3><p>先发送写使能指令，再发送整片擦除指令</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> BE</span> &#123;&#125; &#123;</span><br><span class="line">    WREN</span><br><span class="line"><span class="comment">    # 复位 tx rx fifo</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x1e6</span></span><br><span class="line"><span class="comment">    # 释放 fifo 复位</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"><span class="comment">    # CMD = c7, 整片擦除</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="number">0xc7</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x00</span></span><br><span class="line"><span class="comment">    # 使能 master, 开始发数据</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x86</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS 拉高</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x1</span></span><br><span class="line"><span class="comment">    # 禁用 master</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Bulk Erase Done!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="页写"><a href="#页写" class="headerlink" title="页写"></a>页写</h3><p>先写前 128 Byte, 因为FIFO深度256, 但是cmd+地址占用4Byte, 所以实际使用不足256Byte可用</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> PP</span> &#123;address&#125; &#123;</span><br><span class="line">    WREN</span><br><span class="line"><span class="comment"># 先写前 128 Byte, 因为FIFO深度256, 但是cmd+地址占用4Byte, 所以实际使用不足256Byte可用</span></span><br><span class="line"><span class="comment">    # 复位 tx rx fifo</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x1e6</span></span><br><span class="line"><span class="comment">    # 释放 fifo 复位</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"><span class="comment">    # CMD = 02, 页写</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="number">0x02</span></span><br><span class="line"><span class="comment">    # Write Address</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> [<span class="keyword">expr</span> (<span class="variable">$address</span> &gt;&gt; <span class="number">16</span>)]</span><br><span class="line">    WriteReg <span class="number">0x68</span> [<span class="keyword">expr</span> (<span class="variable">$address</span> % (<span class="number">2</span>**<span class="number">16</span>)) &gt;&gt; <span class="number">8</span>]</span><br><span class="line">    WriteReg <span class="number">0x68</span> [<span class="keyword">expr</span> (<span class="variable">$address</span> % (<span class="number">2</span>**<span class="number">8</span>))]</span><br><span class="line"><span class="comment">    # Write Data</span></span><br><span class="line">    <span class="keyword">set</span> num <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> &#123;<span class="variable">$num</span> &lt; <span class="number">128</span>&#125; &#123;</span><br><span class="line">        WriteReg <span class="number">0x68</span> <span class="variable">$num</span></span><br><span class="line">        <span class="keyword">incr</span> num <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">    # 选择 0 通道CS</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x00</span></span><br><span class="line"><span class="comment">    # 使能 master, 开始发数据</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x86</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS 拉高</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x1</span></span><br><span class="line"><span class="comment">    # 禁用 master</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"><span class="comment"># 再写后 128 Byte</span></span><br><span class="line"><span class="comment">    # 每次写操作之前需要重新开启写使能</span></span><br><span class="line">    WREN</span><br><span class="line">    <span class="keyword">set</span> address [<span class="keyword">expr</span> &#123;<span class="variable">$address</span> + <span class="number">128</span>&#125;]</span><br><span class="line">    <span class="keyword">puts</span> [ <span class="keyword">format</span> <span class="number">0</span>x%<span class="number">08</span>x <span class="variable">$address</span>]</span><br><span class="line"><span class="comment">    # 复位 tx rx fifo</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x1e6</span></span><br><span class="line"><span class="comment">    # 释放 fifo 复位</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"><span class="comment">    # CMD = 02, 页写</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="number">0x02</span></span><br><span class="line"><span class="comment">    # Write Address</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> [<span class="keyword">expr</span> (<span class="variable">$address</span> &gt;&gt; <span class="number">16</span>)]</span><br><span class="line">    WriteReg <span class="number">0x68</span> [<span class="keyword">expr</span> (<span class="variable">$address</span> % (<span class="number">2</span>**<span class="number">16</span>)) &gt;&gt; <span class="number">8</span>]</span><br><span class="line">    WriteReg <span class="number">0x68</span> [<span class="keyword">expr</span> (<span class="variable">$address</span> % (<span class="number">2</span>**<span class="number">8</span>))]</span><br><span class="line"><span class="comment">    # Write Data</span></span><br><span class="line">    <span class="keyword">while</span> &#123;<span class="variable">$num</span> &lt; <span class="number">256</span>&#125; &#123;</span><br><span class="line">        WriteReg <span class="number">0x68</span> <span class="variable">$num</span></span><br><span class="line">        <span class="keyword">incr</span> num <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">    # 选择 0 通道CS</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x00</span></span><br><span class="line"><span class="comment">    # 使能 master, 开始发数据</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x86</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS 拉高</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x1</span></span><br><span class="line"><span class="comment">    # 禁用 master</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Page Program Done!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节读"><a href="#字节读" class="headerlink" title="字节读"></a>字节读</h3><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> READ</span> &#123;address number&#125; &#123;</span><br><span class="line"><span class="comment">    # 复位 tx rx fifo</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x1e6</span></span><br><span class="line"><span class="comment">    # 释放 fifo 复位</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"><span class="comment">    # CMD = 03, 按字节读数据</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> <span class="number">0x03</span></span><br><span class="line"><span class="comment">    # Read Address</span></span><br><span class="line">    WriteReg <span class="number">0x68</span> [<span class="keyword">expr</span> (<span class="variable">$address</span> &gt;&gt; <span class="number">16</span>)]</span><br><span class="line">    WriteReg <span class="number">0x68</span> [<span class="keyword">expr</span> (<span class="variable">$address</span> % (<span class="number">2</span>**<span class="number">16</span>)) &gt;&gt; <span class="number">8</span>]</span><br><span class="line">    WriteReg <span class="number">0x68</span> [<span class="keyword">expr</span> (<span class="variable">$address</span> % (<span class="number">2</span>**<span class="number">8</span>))]</span><br><span class="line"><span class="comment">    # 要读多少个数据就写几个 dummy 数据</span></span><br><span class="line">    <span class="keyword">set</span> num <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> &#123;<span class="variable">$num</span> &lt; <span class="variable">$number</span>&#125; &#123;</span><br><span class="line">        WriteReg <span class="number">0x68</span> <span class="number">0x00</span></span><br><span class="line">        <span class="keyword">incr</span> num <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">    # 选择 0 通道CS</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x00</span></span><br><span class="line"><span class="comment">    # 使能 master, 开始发数据</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x86</span></span><br><span class="line"><span class="comment">    # 选择 0 通道CS 拉高</span></span><br><span class="line">    WriteReg <span class="number">0x70</span> <span class="number">0x1</span></span><br><span class="line"><span class="comment">    # 禁用 master</span></span><br><span class="line">    WriteReg <span class="number">0x60</span> <span class="number">0x186</span></span><br><span class="line"></span><br><span class="line"><span class="comment">    ######################## 写文件 ########################</span></span><br><span class="line">    <span class="keyword">set</span> fn <span class="string">&quot;./rd_data.txt&quot;</span></span><br><span class="line">    <span class="keyword">set</span> fid [<span class="keyword">open</span> <span class="variable">$fn</span> w+]</span><br><span class="line">    <span class="keyword">set</span> num <span class="number">0</span></span><br><span class="line">    <span class="keyword">puts</span> <span class="variable">$fid</span> <span class="string">&quot;Number   Address   Data&quot;</span></span><br><span class="line">    <span class="keyword">while</span> &#123;<span class="variable">$num</span> &lt; <span class="variable">$number</span> + <span class="number">4</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> &#123;<span class="variable">$num</span> &gt;= <span class="number">4</span>&#125; &#123;</span><br><span class="line">            <span class="keyword">puts</span> <span class="variable">$fid</span> [<span class="keyword">format</span> <span class="string">&quot;%-8d %#0-8x   0x%s&quot;</span> [<span class="keyword">expr</span> &#123;<span class="variable">$num</span><span class="number">-3</span>&#125;] [<span class="keyword">expr</span> &#123;<span class="variable">$address</span> + <span class="variable">$num</span> - <span class="number">3</span>&#125;] [<span class="keyword">string</span> range [ReadReg <span class="number">0x6c</span>] end<span class="number">-1</span> end]]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ReadReg <span class="number">0x6c</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">incr</span> num <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">close</span> <span class="variable">$fid</span></span><br><span class="line"><span class="comment">    ######################## 读文件到变量 line ########################</span></span><br><span class="line"><span class="comment">    # 命令eof, 一旦读取到文件末尾, 该命令就返回 1</span></span><br><span class="line">    <span class="keyword">set</span> fid [<span class="keyword">open</span> <span class="variable">$fn</span> r+]</span><br><span class="line">    <span class="keyword">while</span> &#123;[<span class="keyword">eof</span> <span class="variable">$fid</span>] != <span class="number">1</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">gets</span> <span class="variable">$fid</span> line</span><br><span class="line">        <span class="keyword">puts</span> <span class="variable">$line</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">close</span> <span class="variable">$fid</span></span><br><span class="line">    <span class="keyword">puts</span> <span class="string">&quot;Read Done!&quot;</span></span><br><span class="line"><span class="comment">    # set num 0</span></span><br><span class="line"><span class="comment">    # set read_data &quot;ReadData is &quot;</span></span><br><span class="line"><span class="comment">    # while &#123;$num &lt; $number + 4&#125; &#123;</span></span><br><span class="line"><span class="comment">    #     if &#123;$num &gt;= 4&#125; &#123;</span></span><br><span class="line"><span class="comment">    #         append read_data [string range [ReadReg 0x6c] end-1 end]</span></span><br><span class="line"><span class="comment">    #     &#125; else &#123;</span></span><br><span class="line"><span class="comment">    #         ReadReg 0x6c</span></span><br><span class="line"><span class="comment">    #     &#125;</span></span><br><span class="line"><span class="comment">    #     incr num 1</span></span><br><span class="line"><span class="comment">    # &#125;</span></span><br><span class="line"><span class="comment">    # return $read_data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Xilinx IP</category>
      </categories>
      <tags>
        <tag>Xilinx IP</tag>
        <tag>axi_quad_spi</tag>
      </tags>
  </entry>
  <entry>
    <title>Office</title>
    <url>/2023/07/08/office%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="1-目录编号与文字的间距设置"><a href="#1-目录编号与文字的间距设置" class="headerlink" title="1.目录编号与文字的间距设置"></a>1.目录编号与文字的间距设置</h4><p>重新设置正文标题编号，右击编号，“调整列表缩进量”，在“编号之后”选择“空格”，不要选择“制表符”。</p>
<h4 id="2-目录编号缩进设置"><a href="#2-目录编号缩进设置" class="headerlink" title="2. 目录编号缩进设置"></a>2. 目录编号缩进设置</h4><img src="/MD_IMG/Office软件.assets/image-20211110162456380.png" alt="image-20211110162456380" style="zoom: 60%;" />

<p>设置步骤如下：</p>
<ol>
<li><p>找到引用，目录，点击小箭头，进入到标题设置页面</p>
<img alt="20211110162944229](./MD_IMG/Office软件.assets/image-20211110162944229.png"  />
</li>
<li><p>点击修改按钮，再点击修改按钮</p>
<img src="/MD_IMG/Office软件.assets/image-20211110163453823.png" alt="image-20211110163453823" style="zoom:80%;" />
</li>
<li><p>弹出修改样式框选择段落</p>
</li>
</ol>
   <img src="/MD_IMG/Office软件.assets/image-20211110163641785.png" alt="image-20211110163641785" style="zoom:80%;" />

<ol start="4">
<li><p>设置各级目录对应的缩进字符</p>
<img src="/MD_IMG/Office软件.assets/image-20211110164005630.png" alt="image-20211110164005630" style="zoom:80%;" /></li>
</ol>
<h2 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="MID（提取字符）"><a href="#MID（提取字符）" class="headerlink" title="MID（提取字符）"></a>MID（提取字符）</h4><ol>
<li>作用：MID 返回文本字符串中从指定位置开始的特定数目的字符，该数目由用户指定。</li>
<li>语法：MID(text,start_num,num_chars)<ul>
<li>text表示指定的字符串，一般为引用的单元格；</li>
<li>start_num表示指定位置</li>
<li>num_chars表示指定个数</li>
</ul>
</li>
<li>例子：<img src="/MD_IMG/Office软件.assets/image-20211111095827260.png" alt="image-20211111095827260" style="zoom:80%;" /></li>
</ol>
<h4 id="CONCAT（组合字符串）"><a href="#CONCAT（组合字符串）" class="headerlink" title="CONCAT（组合字符串）"></a>CONCAT（组合字符串）</h4><ol>
<li>作用：CONCAT 函数将多个范围和&#x2F;或字符串中的文本组合在一起，但不提供分隔符或 IgnoreEmpty 参数。 </li>
<li>语法：CONCAT(text1, [text2],…)</li>
<li>例子：<img src="/MD_IMG/Office软件.assets/image-20211111100539686.png" alt="image-20211111100539686" style="zoom:80%;" /></li>
</ol>
<h4 id="EXACT（比较字符串）"><a href="#EXACT（比较字符串）" class="headerlink" title="EXACT（比较字符串）"></a>EXACT（比较字符串）</h4><ol>
<li>作用：比较两个文本字符串，如果它们完全相同，则返回 TRUE，否则返回 FALSE。 函数 EXACT 区分大小写，但忽略格式上的差异。 使用 EXACT 可以检验在文档中输入的文本。</li>
<li>语法：EXACT(text1, text2)</li>
<li>例子：<img src="/MD_IMG/Office软件.assets/image-20211111101325595.png" alt="image-20211111101325595" style="zoom:80%;" /></li>
</ol>
<h2 id="PowerPoint"><a href="#PowerPoint" class="headerlink" title="PowerPoint"></a>PowerPoint</h2>]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>软件使用</tag>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>以太网</title>
    <url>/2023/07/08/%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    <content><![CDATA[<p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统、网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。计算机网络类型的划分标准各种各样，按网络所覆盖的地理范围的不同，计算机网络可分为局域网(LAN)、 城域网(MAN)、广域网(WAN)、互联网(Initernet)。局域网按传输介质所使用的访问控制方法可分为：以太网(Ethernet)、光纤分布式数据接口(FDDI)、异步传输模式(ATM)、令牌环网(Token Ring)、交换网(Switching) 等，它们在拓朴结构、传输介质、传输速率、数据格式等多方面都有许多不同，其中应用最广泛的当属以太网。</p>
<p>以太网是为了实现局域网通信而设计的一种技术，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。以太网根据最大传输速率的不同可以分为标准的以太网(10Mbit&#x2F;s)、快速以太网(100Mbit&#x2F;s)、千兆以太网 (1000Mbit&#x2F;s)和万兆以太网(10Gbit&#x2F;s)。百兆网和千兆网是目前应用最多的，顾名思义，百兆网的最大传输速率为 100Mbit&#x2F;s，需要注意的是，我们常见的网速的单位是 MByte&#x2F;s，而 1Byte 为 8bit，所以百兆网能达到的最大网速为 12.5MByte&#x2F;s。同理，千兆网的最大传输速率为 1000Mbit&#x2F;s，能达到的最大网速为 125MByte&#x2F;s。</p>
<h1 id="计算机网络体系结构模型"><a href="#计算机网络体系结构模型" class="headerlink" title="计算机网络体系结构模型"></a>计算机网络体系结构模型</h1><p>国际标准化组织(ISO)在 1978 年提出了“开放系统互联参考模型”，即著名的 OSI&#x2F;RM 模型(Open System  Interconnection&#x2F;Reference Model)。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层(Physics Layer)、数据链路层(Data Link Layer)、网络层(Network Layer)、传输层(Transport Layer)、会话层(Session Layer)、表示层(Presentation Layer)、应用层 (Application Layer)。下面 4 层主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第 4 层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；上 3 层则以提供用户与应用程序之间的信息和数据处理功能为主。</p>
<p>除了标准的 OSI 七层模型以外，常见的网络层次划分还有 TCP&#x2F;IP 四层协议，它们之间的对应关系如图所示：</p>
<img src="/MD_IMG/以太网.assets/image-20220125203948363.png" alt="image-20220125203948363" style="zoom:80%;" />

<p>不管是 OSI 七层模型还是 TCP&#x2F;IP 的四层模型，它们每一层中都有自己的专属协议，需要完成相应的工作以及与上下层级之间进行沟通。由于目前 TCP&#x2F;IP 协议已经成为 Internet 中的【通用语言】，任何和互联网有关的操作都离不开 TCP&#x2F;IP 协议，没有它我们就根本不可能上网，所以下面就以 TCP&#x2F;IP 协议为主来进行讲解。</p>
<ul>
<li><strong>应用层</strong>：为操作系统或网络应用程序提供访问网络服务的接口，主要协议有文件传输协议(FTP)，超文本传输协议(HTTP)，简单邮件传输协议(SMTP)，远程登录(Telnet)；</li>
<li><strong>传输层</strong>：为两台主机上的应用程序提供端到端的通信，在 TCP&#x2F;IP 协议簇中，有两个不同的传输协议：TCP(传输控制协议)和 UDP(用户数据报协议)，它们分别承载不同的应用。TCP 协议是一种面向连接的传输，能够提供可靠的字节流传输服务，UDP 协议是一种简单的面向数据报的传输层协议，与 TCP 协议不同的是 UDP 无法保证数据报文准确达到目的地。</li>
<li><strong>网络层</strong>：负责提供基本的数据封包传送功能，让每个据包都能够到达目的主机，主要协议有 IP 协议(网际协议)、ICMP 协议(Internet 互连网控制报文协议)、ARP&#x2F;RARP (地址解析&#x2F;反向地址解析协议)以及 IGMP 协议(Internet 组管理协议)。</li>
<li><strong>网络接口层</strong>：通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡，它们一起处理与电缆的物理接口细节，主要协议有：以太网、令牌环、帧中继等；</li>
</ul>
<img src="/MD_IMG/以太网.assets/image-20220125204150283.png" alt="image-20220125204150283"  />

<p>从该图中可以看出，当主机 A 向主机 B 发送数据时，用户数据将由应用层产生；当用户数据在经过传输层时，传输层对用户数据进行封装，在用户数据的基础上添加了一个 TCP&#x2F;UDP 首部数据，此时数据包变成了 TCP&#x2F;UDP 段；当它经过网络层时，网络层对 TCP&#x2F;UDP 段进行封装，在 TCP&#x2F;UDP 段的基础上添加了一个 IP 首部数据，此时 TCP&#x2F;UDP 段变成了 IP 数据报；当 它经过网络接口层时，网络接口层对 IP 数据报进行封装，在 IP 数据报的基础上添加了以太网首部数据和以太网尾部（一般为 4byte CRC校验值）两个数据，此时 IP 数据报变成了以太网帧。由此可以看出，数据经过层层封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部数据，最后将应用层数据交给主机 B 处理。</p>
<h1 id="MAC-x2F-PHY-基本概念"><a href="#MAC-x2F-PHY-基本概念" class="headerlink" title="MAC&#x2F;PHY 基本概念"></a>MAC&#x2F;PHY 基本概念</h1><p>MAC 即媒介访问控制层（Media Access Control）, 位于TCP&#x2F;IP协议栈的第二层-数据链路层，用于数据传输过程的数据流控制，其将上层IP数据包分割成适合于物理层传输的数据帧，并负责数据传输的冲突管理。按照 IEEE Std 802-2001 上的定义，MAC主要做如下几个事情：</p>
<ul>
<li>数据帧的封装与识别</li>
<li>根据MAC地址来与目标主机进行通讯</li>
<li>检测数据传输错误（MAC帧中有一个FCS, Frame Checksum Sequence)</li>
<li>物理媒介的访问控制，半双工情况下需要进行传输冲突控制，如CSMA&#x2F;CD</li>
</ul>
<hr>
<p>PHY（Physical layer) 即物理层， 其主要负责物理信号的传输， 其通过线束（如光纤&#x2F;铜线）与其他设备进行连接。一个PHY芯片主要包含了两个部分: PCS(Physical Coding Sublayer), PMD(Physical Medium Dependent), 对车载PHY芯片来说，通常还包含了一个PMA(Physical Media Attachment)子层, 位于PCS与PMD之间。</p>
<h1 id="MAC与PHY之间的接口"><a href="#MAC与PHY之间的接口" class="headerlink" title="MAC与PHY之间的接口"></a>MAC与PHY之间的接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Media  Independent  Interface ( MII)</strong> ，介质独立接口，起初是定义100M以太网（Fast Ethernet）的 MAC  层与 PHY 芯片之间的传输标准（802.3u）。介质独立的意思是指，MAC 与 PHY 之间的通信不受具体传输介质（双绞线或光纤等）的影响，任何 MAC 和 PHY 都可以通过 MII 接口互连。</p>
<p><strong>MDIO</strong> 是 MII 接口的一部分，用于在 MAC 和 PHY 之间传递配置信息。在系统上电瞬间，PHY 芯片通过管脚的电平状态确定原始设置，进而通过 MDIO 更改配置。</p>
<p>最初 MII 定义数据 4 bit 发送 + 4 bit 接收，每位数据速率  25MHz ，总数据速率 100Mbps。其它  MII 标准的变种，包括 RMII，GMII，RGMII，XGMII，SGMII，基本上都是定位于<strong>更高速率</strong>或者<strong>更少的信号数</strong>的目标。</p>
<p>下图表示在以太网通信层次模型中MII接口的位置：</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618172240278.png" alt="image-20230618172240278"></p>
<hr>
<p>针对不同的应用场景，目前MAC与PHY之间的主要数据传输接口有</p>
<ul>
<li><strong>MII（Media Independent Interface）</strong> ：支持 10&#x2F;100 Mbps，数据位宽为 4 bits；在 100Mbps传输速率下，时钟频率为 25 MHz</li>
<li><strong>RMII（Reduce MII）</strong> ：MII 的简化版，数据位宽为 2 bits；在 100Mbps传输速率下，时钟频率为 50 MHz</li>
<li><strong>GMII（Gigabit MII）</strong> ：GMII 接口向下兼容 MII 接口，支持 10&#x2F;100&#x2F;1000 Mbps，数据位宽为 8 bits；在 100Mbps传输速率下，时钟频率为 125 MHz</li>
<li><strong>RGMII（Reduce Gigabit MII）</strong> ：GMII 的简化版，数据位宽为 4 bits；在 100Mbps传输速率下，时钟频率为 125 MHz，但是在为时钟上下沿同时采样数据</li>
<li><strong>SGMII（Serial GIgabit MII）</strong> ：串行 GMII，收发各一对差分信号线，时钟频率为 625 MHz，在时钟上下沿同时采样；有效数据带宽1000Mbps，每 10bits 数据包含 8bits 数据位 和 2 bits 控制位</li>
<li><strong>XGMII（10-GIgabit MII）</strong> ：速率 10 Gbps，数据位宽为 32 bits，时钟为156.25 MHz，时钟上下沿采样</li>
</ul>
<h2 id="MDIO-x2F-MDC"><a href="#MDIO-x2F-MDC" class="headerlink" title="MDIO&#x2F;MDC"></a>MDIO&#x2F;MDC</h2><p>SMI（Serial Management Interface）串行管理接口，也被称作 MII 管理接口（MII Management Interface），包括 MDC 和 MDIO 两条信号线。</p>
<ul>
<li><p>MDIO 是一个 PHY 的管理接口，用来读写 PHY 的寄存器，以控制 PHY 的行为或获取 PHY 的状态</p>
</li>
<li><p>MDC 为 MDIO 提供时钟，由 MAC 端提供</p>
</li>
</ul>
<h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230617165550497.png" alt="image-20230617165550497"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Preamble</td>
<td>由 MAC 发送 32 个连续的逻辑 “1”，同步于 MDC 信号，用于 MAC 与 PHY 之间的同步</td>
</tr>
<tr>
<td>ST</td>
<td>帧开始位，固定为 “01”</td>
</tr>
<tr>
<td>OP</td>
<td>操作码，“10” 表示读，“01” 表示写</td>
</tr>
<tr>
<td>PHYAD</td>
<td>PHY 的地址，5 bits</td>
</tr>
<tr>
<td>REGAD</td>
<td>寄存器地址，5 bits</td>
</tr>
<tr>
<td>TA</td>
<td>Turn Around， MDIO方向转换<br />① 在写状态下，不需要转换方向，值为 “10”<br />② 在读状态下，MAC 输出端为高阻态，在第二个周期 PHY 将 MDIO 拉低</td>
</tr>
<tr>
<td>DATA</td>
<td>16 bits 数据</td>
</tr>
<tr>
<td>IDLE</td>
<td>空闲状态。此状态下 MDIO 为高阻态，由外部上拉电阻拉高</td>
</tr>
</tbody></table>
<h3 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h3><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230617171004193.png" alt="image-20230617171004193"></p>
<p>可以看到在 Turn Around状态下，第一个周期 MDIO 为高阻态，第二个周期由 PHY 端拉低。</p>
<h3 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h3><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230617171105923.png" alt="image-20230617171105923"></p>
<p>为了保证能够正确采集到数据，在 MDC 上升沿之前就把数据准备好。</p>
<h2 id="MII"><a href="#MII" class="headerlink" title="MII"></a>MII</h2><p>Mll 共计 18 根信号线，只有 MDIO&#x2F;MDC 信号可以在不同 PHY 间级联。假定系统中有 8 个 PHY，则 Mll 信号总数为 8*16+2&#x3D;130 根！为减少信号数，RMII 接口应运而生。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618174758423.png" alt="image-20230618174758423"></p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>方向（MAC 端）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TX_CLK</td>
<td>Input</td>
<td>发送数据参考时钟，由 PHY 提供<br />① 100 Mbps 速率下，时钟频率为 25 MHz<br />② 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>TXD[3:0]</td>
<td>Output</td>
<td>发送数据信号</td>
</tr>
<tr>
<td>TX_EN</td>
<td>Output</td>
<td>发送数据使能信号，TXD 在 TX_EN 拉高时才有效</td>
</tr>
<tr>
<td>TX_ER</td>
<td>Output</td>
<td>① 发送数据错误提示信号， TXD 在 TX_ER 拉高时无效<br />② 10Mbps 速率下，TX_ER 不起作用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RX_CLK</td>
<td>Input</td>
<td>接收数据参考时钟，由 PHY 提供<br />① 100 Mbps 速率下，时钟频率为 25 MHz<br />② 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>RX_D[3:0]</td>
<td>Input</td>
<td>接收数据信号</td>
</tr>
<tr>
<td>RX_DV</td>
<td>Input</td>
<td>接收数据使能信号，RXD 在 RX_DV 拉高时才有效</td>
</tr>
<tr>
<td>RX_ER</td>
<td>Input</td>
<td>① 接收数据错误提示信号， RXD 在 RX_ER 拉高时无效<br />② 10Mbps 速率下，RX_ER 不起作用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>COL</td>
<td>Input</td>
<td>① 载波侦测信号，不需要同步于参考时钟<br />② 只要有数据传输，CAS 就有效<br />③  CAS信号只有 PHY 在半双工模式下有效</td>
</tr>
<tr>
<td>CRS</td>
<td>Input</td>
<td>① 冲突检测信号，不需要同步于参考时钟<br />②  COL 信号只有 PHY 在半双工模式下有效</td>
</tr>
</tbody></table>
<h2 id="RMII"><a href="#RMII" class="headerlink" title="RMII"></a>RMII</h2><p>相比于 MII 接口，RMII 有以下四处变化：</p>
<ol>
<li>TXCLK 和 RXCLK 两个时钟信号，合并为一个时钟 REFCLK</li>
<li>时钟速率由 25MHz 上升到 50MHz，单向数据由 4 bits 变为 2 bits </li>
<li>CRS 和 RX_DV 合并为一个信号 CRS_DV</li>
<li>取消了COL信号</li>
</ol>
<p>RMII 信号如下图所示。RMII 只要 9 根信号线，相比于 MII 的 18 根信号少了一半，在同一个系统中的多个设备可以共享 MDIO，MDC 和 REFCLK 信号线。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618175120605.png" alt="image-20230618175120605"></p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>方向（MAC 端）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REF_CLK</td>
<td>Output</td>
<td>参考时钟，50 MHz</td>
</tr>
<tr>
<td>TXD[2:0]</td>
<td>Output</td>
<td>发送数据信号</td>
</tr>
<tr>
<td>TX_EN</td>
<td>Output</td>
<td>发送数据使能信号，TXD 在 TX_EN 拉高时才有效</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RX_D[3:0]</td>
<td>Input</td>
<td>接收数据信号</td>
</tr>
<tr>
<td>RX_ER</td>
<td>Input</td>
<td>① 接收数据错误提示信号， RXD 在 RX_ER 拉高时无效<br />② 10Mbps 速率下，RX_ER 不起作用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CRS_DV</td>
<td>Input</td>
<td>① 由 MII 接口的 RX_DV 和 CAS 合并而成<br />② 当介质不空闲时，CRS_DV 和 REFCLK 相异步给出<br />③ 当 CRS 比 RX_DV 早结束时（即载波消失而队列中海油数据要传输时），就会出现 CRS_DV 在半位元组的边界以 25&#x2F;2.5 MHz 的频率在0、1之间来回切换。因此，MAC 能够从 CRS_DV 中精确恢复出 RX_DV 和 CRS。</td>
</tr>
</tbody></table>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230617204319141.png" alt="image-20230617204319141"></p>
<p>在100Mbps速率时，TX&#x2F;RX每个时钟周期采样一个数据；在10Mbps速率时，TX&#x2F;RX每隔10个周期采样一个数据，因而TX&#x2F;RX数据需要在数据线上保留10个周期，相当于一个数据发送10次。</p>
<p>当PHY层芯片收到有效的载波信号后，CRS_DV信号变为有效，此时如果FIFO中还没有数据，则它会发送出全0的数据给MAC，然后当FIFO中填入有效的数据帧，数据帧的开头是“101010—”交叉的前导码，当数据中出现“01”的比特时，代表正式数据传输开始，MAC芯片检测到这一变化，从而开始接收数据。</p>
<p>当外部载波信号消失后，CRS_DV会变为无效，但如果FIFO中还有数据要发送时，CRS_DV在下一周期又会变为有效，然后再无效再有效，直到FIFO中数据发送完为止。在接收过程中如果出现无效的载波信号或者无效的数据编码，则RX_ER会变为有效，表示物理层芯片接收出错。</p>
<h2 id="GMII"><a href="#GMII" class="headerlink" title="GMII"></a>GMII</h2><p>与 MII 接口相比，GMII 接口的数据速率可达 1000Mbps，数据宽度由 4 位变为 8 位，在实际应用中，绝大多数 GMII 接口都是兼容 MII 接口的，所以，一般的 GMII 接口都有两个发送参考时钟：TX_CLK 和 GTX_CLK (两者的方向是不一样的)，在用作 MII 模式时，使用 TX_CLK 和 8 根数据线中的 4 根。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618175422199.png" alt="image-20230618175422199"></p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>方向（MAC 端）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GTX_CLK</td>
<td>Output</td>
<td>发送数据参考时钟，由 MAC 提供<br />① 1000 Mbps 速率下，时钟频率为 125 MHz<br />② 100 Mbps 速率下，时钟频率为 25 MHz<br />③ 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>TXD[7:0]</td>
<td>Output</td>
<td>发送数据信号</td>
</tr>
<tr>
<td>TX_EN</td>
<td>Output</td>
<td>发送数据使能信号，TXD 在 TX_EN 拉高时才有效</td>
</tr>
<tr>
<td>TX_ER</td>
<td>Output</td>
<td>发送数据错误提示信号， TXD 在 TX_ER 拉高时无效</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RX_CLK</td>
<td>Input</td>
<td>接收数据参考时钟，由 PHY 提供<br />① 1000 Mbps 速率下，时钟频率为 125 MHz<br />② 100 Mbps 速率下，时钟频率为 25 MHz<br />③ 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>RX_D[7:0]</td>
<td>Input</td>
<td>接收数据信号</td>
</tr>
<tr>
<td>RX_DV</td>
<td>Input</td>
<td>接收数据使能信号，RXD 在 RX_DV 拉高时才有效</td>
</tr>
<tr>
<td>RX_ER</td>
<td>Input</td>
<td>接收数据错误提示信号， RXD 在 RX_ER 拉高时无效</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>COL</td>
<td>Input</td>
<td>① 载波侦测信号，不需要同步于参考时钟<br />② 只要有数据传输，CAS 就有效<br />③  CAS信号只有 PHY 在半双工模式下有效</td>
</tr>
<tr>
<td>CRS</td>
<td>Input</td>
<td>① 冲突检测信号，不需要同步于参考时钟<br />②  COL 信号只有 PHY 在半双工模式下有效</td>
</tr>
</tbody></table>
<h2 id="RGMII"><a href="#RGMII" class="headerlink" title="RGMII"></a>RGMII</h2><p>RGMII 相比于 GMII 减小将近一半的管脚数（24 -&gt;12），通过以下两种方式：</p>
<ul>
<li>1000Mbps 模式下，在时钟的上&#x2F;下边沿均采样数据；10&#x2F;100Mbps 模式，数据仅在时钟上升沿采样</li>
<li>取消不重要的如 CRS，COL 等信号</li>
<li>TXC 只由 MAC提供，不像 GMII 接口（10&#x2F;100Mbps 模式下时钟是由 PHY 提供（TXCLK），而 1000Mbps 模式下时钟是由 MAC 提供）</li>
<li>RGMII 中应用到源同步时钟，即数据与时钟信号是同步的。这要求在PCB设计中，要对时钟信号额外增加 1.5-2ns 的延迟以保证接收端的建立&#x2F;保持时间满足要求。在RGMII v2.0 规范中有定义MAC&#x2F;PHY内部延迟<br>（RGMII-ID），由此避免PCB设计中再要增加这个延迟。</li>
<li>RXCTL 和 TXCTL 为复用的传输控制信号。RXCTL 在时钟的上升沿代表 RXDV，在时钟的下降沿代表 RXER；TXCTL 在时钟的上升沿代表 TXEN，在时钟的下降沿代表 TXER</li>
<li>RGMII v1.3 采用 2.5V CMOS 电平，RGMII v2 采用 1.5V HSTL 电平。</li>
</ul>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618180416966.png" alt="image-20230618180416966"></p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>方向（MAC 端）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GTX_CLK</td>
<td>Output</td>
<td>发送数据参考时钟，由 MAC 提供<br />① 1000 Mbps 速率下，时钟频率为 125 MHz<br />② 100 Mbps 速率下，时钟频率为 25 MHz<br />③ 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>TXD[3:0]</td>
<td>Output</td>
<td>① 发送数据信号<br />② 上下沿都传输数据</td>
</tr>
<tr>
<td>TX_CTL</td>
<td>Output</td>
<td>① 上升沿发送数据使能信号<br />② 下降沿发送数据错误提示信号</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RX_CLK</td>
<td>Input</td>
<td>接收数据参考时钟，由 PHY 提供<br />① 1000 Mbps 速率下，时钟频率为 125 MHz<br />② 100 Mbps 速率下，时钟频率为 25 MHz<br />③ 10 Mbps 速率下，时钟频率为 2.5 MHz</td>
</tr>
<tr>
<td>RX_D[3:0]</td>
<td>Input</td>
<td>① 接收数据信号<br />② 上下沿都传输数据</td>
</tr>
<tr>
<td>RX_CTL</td>
<td>Input</td>
<td>① 接收数据使能信号<br />② 下降沿接收数据错误提示信号</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>COL</td>
<td>Input</td>
<td>① 载波侦测信号，不需要同步于参考时钟<br />② 只要有数据传输，CAS 就有效<br />③  CAS信号只有 PHY 在半双工模式下有效</td>
</tr>
<tr>
<td>CRS</td>
<td>Input</td>
<td>① 冲突检测信号，不需要同步于参考时钟<br />②  COL 信号只有 PHY 在半双工模式下有效</td>
</tr>
</tbody></table>
<h2 id="SGMII"><a href="#SGMII" class="headerlink" title="SGMII"></a>SGMII</h2><p>SGMII 发送和接收时钟频率均为 625MHz，采用 DDR 模式，因此数据速率为1.25Gbps，SGMII 相比于 GMII，功耗更低，采用 SerDes 接口后管脚数更少。SGMII 发送和接受数据各 1 对差分信号（LVDS），另外还有 1 对差分时钟，共 6 根线。对于 MAC&#x2F;PHY 中包括时钟恢复电路（CDR，Clock and Data Recovery circuitry）的系统，TXCLK 可以省略，SGMII 接口只需要 4 根线，相比于 GMII（24 根）和 RGMII（12 根）信号线大大减少！</p>
<p>TX&#x2F;RX 在数据发送端必须同时产生时钟，而接收端的时钟是可选的，因为可以通过 CDR 恢复时钟。在 10&#x2F;100Mbps 工作模式下，数据分别重复发送 100&#x2F;10 次，因此时钟一直是 625MHz</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618180949659.png" alt="image-20230618180949659"></p>
<p>大多数 MAC 芯片的 SGMII 接口都可以配置成 SerDes 接口（在物理上完全兼容，只需配置寄存器即可）。SerDes 直接外接光模块，而不需要 PHY 层芯片，此时时钟速率仍旧是 625 MHz。</p>
<p>不过此时跟 SGMII 接口不同，SGMII 接口速率被提高到 1.25 Gbps 是因为插入了控制信息，而 SerDes 端口速率被提高是因为进行了 8B&#x2F;10B 变换，本来 8B&#x2F;10B 变换是 PHY 芯片的工作，在 SerDes 接口中，因为外面不接 PHY 芯片，此时 8B&#x2F;10B 变换在 MAC 芯片中完成了。</p>
<p>8B&#x2F;10B 变换的主要作用是扰码，让信号中不出现过长的连 “0” 和连 “1” 情况，影响时钟信息的提取。</p>
<p>所以感觉是 MAC 芯片用加 2bits 控制信息的功能模块去完成了 8B&#x2F;10B 变换，这样 SerDes 信号就可以直接出去了。</p>
<p>SerDes 通道和 SerDes 接口是两个概念，SGMII 也是需要 SerDes通道（SERDES lane）的。</p>
<p>而 SGMII 需要插入 2bits 控制信号变成 10bits 是因为 SGMII 需要控制信号来实现 10&#x2F;100&#x2F;1000 Mbps 速率协商，而 SerDes 是固定速率（1000BASE-x）。</p>
<p>PHY 收到 MAC SGMII 的 10 bits 后，将控制信号去除后，将数据发送出去前还是会加扰码完成 8B&#x2F;10B 变换。</p>
<h2 id="XGMII"><a href="#XGMII" class="headerlink" title="XGMII"></a>XGMII</h2><p>XGMII 是用于 10G 以太网的 MAC 与 PHY 设备间通信的接口标准，它包括 32 bits 的数据通道（RXD&amp;TXD），两组 4 bits的控制通道（RXC&amp;TXC）和两组时钟（收&#x2F;发），时钟频率 156.25 MHz，工作在 DDR 模式。</p>
<p>XGMII 接口的连接示意图如下所示，注意 RXD&#x2F;TXD 信号上的 36 表示 32 bits 数据 + 4 bits 控制信号，其中每 8 bits 数据称为 1 个 Lane，共用 1 路控制信号。</p>
<p>10 Gbps &#x3D; 156.25 MHz * 32 bits * 2</p>
<p>XGMII 信号数目（74 根）较多，通常用于芯片内的连接，不适合作为芯片间通信的接口，因此协议定义 XGXS（XGMII eXtender Sublayer）子层以缩减信号数目，简化硬件设计。</p>
<p>XGXS 子层主要完成 8b&#x2F;10b 编码和不同 Lane 之间的去偏斜等功能。如图所示，在信号链的两端，MAC和PHY 都包括 XGXS 子层，XAUI 是 XGXS 之间通信的接口。</p>
<p>XAUI 接口包括 4 组发送差分对和 4 组接收差分对，共 16 根信号。每组差分对（Lane）的数据速率为 3.125 Gbps，因此总的数据速率为 4 *3.125 Gbps &#x3D; 12.5 Gbps，考虑到 8b&#x2F;10b 的效率为 80%，因此实际数据速率为12.5Gbps * 80%&#x3D; 10 Gbps</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618181543641.png" alt="image-20230618181543641"></p>
<h2 id="XFI-x2F-XFP"><a href="#XFI-x2F-XFP" class="headerlink" title="XFI&#x2F;XFP"></a>XFI&#x2F;XFP</h2><p>XFI 是10G 以太网 PMA（Physical Medium Attachment）和 PMD（Physical Medium Dependent）之间的接口标准，它只有两对差分线（收&#x2F;发），共4根线，如下图所示。XFI 接口速度达到10.3125<br>Gbps，采用64B&#x2F;66B编码，在 XAUI 与 XFI 之间使用到 SerDes 以减小信号数。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230618181815189.png" alt="image-20230618181815189"></p>
<p>XFP（10 Gigabit Small Form Factor Pluggable）是指应用XFI接口的光模块，应用于10G以太网的光传输。XFP 光模块的尺寸略大于 SFP 和 SFP+ 光模块，三种光模块的详细对比见<a href="http://www.differencebetween.info/difference-between-xfp-sfp-and-sfp-plus">链接</a>。</p>
<h1 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h1><h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230619234934505.png" alt="image-20230619234934505"></p>
<h3 id="前导码（Preamble）"><a href="#前导码（Preamble）" class="headerlink" title="前导码（Preamble）"></a>前导码（Preamble）</h3><p>为了实现底层数据的正确阐述，物理层使用7个字节同步码（7 个 0x55），二进制表现为 0 和 1 交替，其作用是使发送方和接收方的时钟同步。</p>
<h3 id="帧起始界定符（SFD，Start-Frame-Delimiter）"><a href="#帧起始界定符（SFD，Start-Frame-Delimiter）" class="headerlink" title="帧起始界定符（SFD，Start Frame Delimiter）"></a>帧起始界定符（SFD，Start Frame Delimiter）</h3><p>使用 1 个字节的SFD（0xd5），二进制表现为“10101011”，用来表示一帧的开始，即后面紧跟着传输的就是以太网的帧头。</p>
<h3 id="以太网帧头"><a href="#以太网帧头" class="headerlink" title="以太网帧头"></a>以太网帧头</h3><h4 id="目的MAC地址"><a href="#目的MAC地址" class="headerlink" title="目的MAC地址"></a>目的MAC地址</h4><p>即接收端物理MAC地址，占用 6 个字节。MAC地址从应用上可分为<strong>单播地址、组播地址和广播地址</strong>。</p>
<ul>
<li>单播地址：第一个字节的最低位为0，比如00-00-00-11-11-11，一般用于标志唯一的设备；</li>
<li>组播地址：第一个字节的最低位为1，比如01-00-00-11-11-11，一般用于标志同属一组的多个设备；</li>
<li>广播地址：所有48bit全为1，即FF-FF-FF-FF-FF-FF，它用于标志同一网段中的所有设备。</li>
</ul>
<h4 id="源MAC地址"><a href="#源MAC地址" class="headerlink" title="源MAC地址"></a>源MAC地址</h4><p>即发送端物理MAC地址，占用6个字节。</p>
<h4 id="长度-x2F-类型"><a href="#长度-x2F-类型" class="headerlink" title="长度&#x2F;类型"></a>长度&#x2F;类型</h4><p>长度&#x2F;类型具有两个意义</p>
<ul>
<li>当这两个字节的值<strong>小于1536</strong>（十六进制为0x0600）时，代表该以太网中数据段的长度；</li>
<li>如果这两个字节的值<strong>大于1536</strong>，则表示该以太网中的数据属于哪个上层协议，例如0x0800代表IP协议（网际协议）、0x0806代表ARP协议（地址解析协议）等。</li>
</ul>
<h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>长度最小46个字节，最大1500个字节。</p>
<p>长度最小46个字节，总的以太网帧长度最小为 64 个字节，其原因是因为以太网是不可靠的，这意味着它并不知道对方有没有收到自己发出的数据包，但如果他发出的数据包发生错误，需要进行重传。以太网的错误主要是发生碰撞，碰撞是指两台机器同时监听到网络是空闲的，同时发送数据就会发生碰撞，碰撞对于以太网来说是正常的。要保证以太网的重传，必须保证收到碰撞信号的时候数据包没有传完，要实现这一要求，发送方和接收方之间的距离很关键，也就是说信号在发送方和接收方之间传输的来回时间必须控制在一定范围之内。IEEE 定义了这个标准，一个碰撞域内最 远的两台机器之间的 round-trip time 要小于 512 bit time(传输一个比特需要的时间)，这也是我们常说的一个碰撞域的直径。512 个 bit time 也就是 64 字节的传输时间，如果以太网数据包 ≥ 64 个字节就能保证碰撞信号到达发送方的时候，数据包还没有传完。最小数据帧的设计和以太网电缆长度有关，为的是让两个相距最远的站点能够感知到双方的数据发生了碰撞，最远两端数据的往返时间就是争用期，以太网的争用期是 51.2 us，正好发送 64byte 数据。</p>
<p>最大值 1500 称为以太网的最大传输单元（MTU，Maximum Transmission Unit），之所以限制最大传输单元是因为在多个计算机的数据帧排队等待传输时，如果某个数据帧太大的话，那么其它数据帧等待的时间就会加长，导致体验变差。另外还要考虑网络I&#x2F;O控制器缓存区资源以及网络最大的承载能力等因素，因此最大传输单元是由各种综合因素决定的。<strong>为了避免增加额外的配置，通常以太网的有效数据字段小于1500个字节，现在电脑的配置都很高了，很多都支持巨型帧，巨型帧可以超过 1500 个字节</strong>。</p>
<p>不同的协议，数据段的组成结构不同，后面再详细说明。</p>
<h3 id="帧检验序列（FCS，Frame-Check-Sequence）"><a href="#帧检验序列（FCS，Frame-Check-Sequence）" class="headerlink" title="帧检验序列（FCS，Frame Check Sequence）"></a>帧检验序列（FCS，Frame Check Sequence）</h3><p>为了确保数据的正确传输，在数据的尾部加入了4个字节的循环冗余校验码（CRC校验）来检测数据是否传输错误。<strong>CRC数据校验从以太网帧头开始即不包含前导码和帧起始界定符</strong>。通用的CRC标准有CRC-8、CRC-16、CRC-32、CRC-CCIT，其中在网络通信系统中应用最广泛的是CRC-32标准。</p>
<h3 id="帧间隙（IFG，Interpacket-Gap）"><a href="#帧间隙（IFG，Interpacket-Gap）" class="headerlink" title="帧间隙（IFG，Interpacket Gap）"></a>帧间隙（IFG，Interpacket Gap）</h3><p>　帧间隙的时间就是网络设备和组件在接收一帧之后，需要短暂的时间来恢复并为接收下一帧做准备的时间，<strong>IFG的最小值是96 bit time</strong>，即在媒介中发送96位原始数据所需要的时间，在不同媒介中IFG的最小值是不一样的。不管10M&#x2F;100M&#x2F;1000M的以太网，两帧之间最少要有96bit time，IFG的最少间隔时间计算方法如下：</p>
<ul>
<li>10Mbit&#x2F;s最小时间为：96*100ns &#x3D; 9600ns；</li>
<li>100Mbit&#x2F;s最小时间为：96*10ns &#x3D; 960ns；</li>
<li>1000Mbit&#x2F;s最小时间为：96*1ns &#x3D; 96ns；</li>
</ul>
<h2 id="ARP-数据报"><a href="#ARP-数据报" class="headerlink" title="ARP 数据报"></a>ARP 数据报</h2><p>ARP 地址解析协议，即 ARP（Address Resolution Protocol），根据 IP 地址获取物理地址。主机发送包含目的 IP 地址的 ARP 请求广播（MAC 地址为 48’hff_ff_ff_ff_ff_ff）到网络上的主机，并接收返回消息，以此确定目标的物理地址，收到返回消息后将 IP 地址和物理地址保存到缓存中，<br>并保留一段时间，下次请求时直接查询 ARP 缓存以节约资源。下图为 ARP 数据报格式 。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230619205401432.png" alt="image-20230619205401432"></p>
<table>
<thead>
<tr>
<th></th>
<th>字段</th>
<th>长度 (Byte)</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>前导码+SFD</td>
<td>8</td>
<td>0x5555…D5</td>
<td></td>
</tr>
<tr>
<td>以太网首部</td>
<td>目的 MAC 地址</td>
<td>6</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>源 MAC 地址</td>
<td>6</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>长度&#x2F;类型</td>
<td>2</td>
<td>0x0806</td>
<td>ARP帧类型值</td>
</tr>
<tr>
<td>ARP 字段</td>
<td>硬件类型</td>
<td>2</td>
<td>0x0001</td>
<td>指链路层网络类型，1 为以太网</td>
</tr>
<tr>
<td></td>
<td>上层协议类型</td>
<td>2</td>
<td>0x0800</td>
<td>上层协议为 IP 协议</td>
</tr>
<tr>
<td></td>
<td>MAC地址长度</td>
<td>1</td>
<td>0x6</td>
<td>以太网 MAC 地址长度为 6</td>
</tr>
<tr>
<td></td>
<td>IP地址长度</td>
<td>1</td>
<td>0x4</td>
<td>IP 地址长度为 4</td>
</tr>
<tr>
<td></td>
<td>操作码</td>
<td>2</td>
<td>0x1 &#x2F; 0x2</td>
<td>1 表示 ARP 请求包<br />2 表示 ARP 应答包</td>
</tr>
<tr>
<td></td>
<td>源 MAC 地址</td>
<td>6</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>源 IP 地址</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>目的 MAC 地址</td>
<td>6</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>目的 IP 地址</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>填充数据</td>
<td>18</td>
<td></td>
<td>数据段最小长度为46</td>
</tr>
<tr>
<td>以太网校验</td>
<td>校验字</td>
<td>4</td>
<td></td>
<td>除前导码+SFD 外均计算</td>
</tr>
</tbody></table>
<h2 id="IP-数据报"><a href="#IP-数据报" class="headerlink" title="IP 数据报"></a>IP 数据报</h2><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230619233823764.png" alt="image-20230619233823764"></p>
<h3 id="IP-首部"><a href="#IP-首部" class="headerlink" title="IP 首部"></a>IP 首部</h3><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230619233850673.png" alt="image-20230619233850673"></p>
<ul>
<li><strong>版本</strong> ：4位IP版本号（Version），这个值设置为二进制的 “0100” 时表示 IPv4，设置为 “0110” 时表示 IPv6，目前使用比较多的IP协议版本号是 4</li>
<li><strong>首部长度</strong> ： 4位首部长度（IHL，Internet Header Length），表示IP首部一共有多少个 32bits（4个字节）。最大可表示15个 32 bits，因此 IP 的首部长度最大值为 60 字节</li>
<li><strong>服务类型</strong> ：8位服务类型（TOS，Type of service），该字段被划分成两个子字段：3位优先级字段（现在已经基本忽略掉了）和4位TOS字段，最后一位固定为0。服务类型为0时表示一般服务</li>
<li><strong>总长度</strong> ：16位IP数据报总长度（Total Length），包括IP首部和IP数据部分，以字节为单位。我们利用IP首部长度和IP数据报总长度，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。尽管理论上可以传输长达65535字节的IP数据报，但实际上还要考虑网络的最大承载能力等因素</li>
<li><strong>标识</strong> ：16位标识（Identification）字段，用来标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1</li>
<li><strong>标志</strong> ：3位标志（Flags）字段<ul>
<li>最高位为保留位</li>
<li>中间位是 DF （Don’t Fragment），表示禁止分片，只有 DF &#x3D; 0 时才允许分片</li>
<li>最低位是 MF （More Fragment），MF &#x3D; 1 表示后面还有分片，MF &#x3D; 0 表示最后一个分片</li>
</ul>
</li>
<li><strong>片偏移</strong> ：13位片偏移字段，指较长的分组在分片后某片在原分组中的相对位置，以 8 字节为偏移单位，也就是说每个分片的长度一定是 8 字节的整数倍</li>
<li><strong>生存时间</strong> ：8位生存时间字段TTL（Time To Live），设置了数据报可以经过的最多路由器数，表示数据报在网络上生存多久，防止丢失的数据包在无休止的传播TTL的初始值由源主机设置，一般为32、64或者128，一旦经过一个路由器，它的值就减 1，减到 0 时，数据报就丢弃，并发送 ICMP 消息通知源主机</li>
<li><strong>协议</strong> ：8位协议（Protocol）类型，指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程。 0x01 表示为 ICMP 协议, 0x02 表示为 IGMP 协议, 0x06 表示为 TCP 协议, 0x11 表示为 UDP 协议</li>
<li><strong>首部校验和</strong> ：16位首部校验和（Header Checksum），该字段只校验数据报的首部，不包含数据部分；校验IP数据报头部是否被破坏、篡改和丢失等。</li>
<li><strong>源 IP 地址</strong> ：32位源IP地址（Source Address），即发送端的IP地址，如192.168.1.123</li>
<li><strong>目的 IP 地址</strong> ：32位目的IP地址（Destination Address），即接收端的IP地址，如192.168.1.102</li>
<li><strong>可选字段</strong> ：是数据报中的一个可变长度的可选信息，选项字段以32bit为界，不足时插入值为0的填充字节，保证IP首部始终是32bit的整数倍，没有的话长度可以为 0 。</li>
</ul>
<p>　　IP首部校验和的计算方法：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>、将<span class="number">16</span>位检验和字段置为<span class="number">0</span>，然后将IP首部按照<span class="number">16</span>位分成多个单元；</span><br><span class="line"><span class="attribute">2</span>、对各个单元采用反码加法运算（即高位溢出位会加到低位，通常的补码运算是直接丢掉溢出的高位）；</span><br><span class="line"><span class="attribute">3</span>、此时仍然可能出现进位的情况，将得到的和再次分成高<span class="number">16</span>位和低<span class="number">16</span>位进行累加；</span><br><span class="line"><span class="attribute">4</span>、最后将得到的和的反码填入校验和字段。</span><br></pre></td></tr></table></figure>

<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620232037234.png" alt="image-20230620232037234"></p>
<h3 id="UDP-数据报格式"><a href="#UDP-数据报格式" class="headerlink" title="UDP 数据报格式"></a>UDP 数据报格式</h3><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230619233823764.png" alt="image-20230619233823764"></p>
<ul>
<li><strong>源端口号</strong> ：16位发送端端口号，用于区分不同服务的端口，端口号的范围从0到65535</li>
<li><strong>目的端口号</strong> ：16位接收端端口号</li>
<li><strong>UDP 长度</strong> ：16位UDP长度，包含UDP首部长度 + 数据长度，单位是字节</li>
<li><strong>UDP 校验和 ** ：16位UDP校验和。UDP计算校验和的方法和计算IP数据报首部校验和的方法相似，但不同的是IP数据报的校验和只检验IP数据报的首部，而</strong>UDP校验和包含三个部分：UDP 伪首部，UDP 首部和 UDP 的数据部分。伪首部的数据是从IP数据报头和UDP数据报头获取的，包括源IP地址，目的IP地址，协议类型和UDP长度**</li>
</ul>
<hr>
<p>数据是可以直接封装在IP协议里而不使用TCP、UDP或者其它上层协议的。然而在网络传输中同一IP服务器需要提供各种不同的服务，各种不同的服务类型是使用端口号来区分的，例如用于浏览网页服务的80端口，用于FTP（文件传输协议）服务的21端口等。TCP和UDP都使用两个字节的端口号，理论上可以表示的范围为0~65535，足够满足各种不同的服务类型。</p>
<p>TCP协议与UDP协议作为传输层最常用的两种传输协议，这两种协议都是使用IP作为网络层协议进行传输。下面是TCP协议与UDP协议的区别：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">①TCP协议面向连接，是流传输协议，通过连接发送数据，而UDP协议传输不需要连接，是数据报协议；</span><br><span class="line">②TCP为可靠传输协议，而UDP为不可靠传输协议。即TCP协议可以保证数据的完整和有序，而UDP不能保证；</span><br><span class="line">③UDP由于不需要连接，故传输速度比TCP快，且占用资源比TCP少；</span><br><span class="line">④TCP协议常用在对数据文件完整性较高的一些场景中，如文件传输等。</span><br><span class="line"> UDP协议常用于对通讯速度有较高要求或者传输数据较少时，如视频直播和QQ等。</span><br></pre></td></tr></table></figure>

<p>UDP 协议使用报头中的校验值来保证数据的安全。校验值首先在数据发送方通过特殊的算法 计算得出，在传递到接收方之后，还需要再重新计算。如果某个数据报在传输过程中被第三方篡 改或者由于线路噪音等原因受到损坏，发送和接收方的校验计算值将不会相符，由此 UDP 协议可以检测是否出错。虽然 UDP 提供有错误检测，但检测到错误时，只是简单地把损坏的消息段扔掉，或者给应用程序提供警告信息。</p>
<h3 id="ICMP-报文"><a href="#ICMP-报文" class="headerlink" title="ICMP 报文"></a>ICMP 报文</h3><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620130343446.png" alt="image-20230620130343446"></p>
<ul>
<li><p>ICMP 是 TCP&#x2F;IP 协议族的一个 <strong>IP 层子协议</strong>，包含在 IP 数据报里，用于 IP 主机、路由器之间传递控制消息。控制消息是指网络是否连通，主机是否可达等功能。其中 <strong>ping 功能采用回送请求和回答报文，回送请求报文类型为 0x08，回答报文类型为 0x00</strong></p>
</li>
<li><p><strong>ICMP报文可分为两大类</strong></p>
<ol>
<li>有关信息采集和配置的 ICMP 报文，称为<strong>查询报文</strong>（query）或者<strong>信息类报文</strong>(information message)</li>
<li>有关 IP 数据报传递的ICMP报，称为<strong>差错报文</strong>（error message）</li>
</ol>
</li>
<li><p><strong>校验和计算（校验 ICMP 首部和数据部分）</strong> ：</p>
<ul>
<li>将校验和字段设置为0</li>
<li>每16个bit(即2个字节)组成一个数，相加，如果超过16个bit，把超过的高位值加到这16个bit值上，得到的新值再和下一个值相加</li>
<li><strong>如果最后还剩8个bit值，不能简单的加到低位，要把这8个bit当成高位值，再用0填充一个16个bit值，相加</strong></li>
<li>最后取反，填充到校验和字段</li>
</ul>
</li>
<li><p><strong>报文类型字段（Type）及代码字段（Code）含义</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型TYPE</th>
<th>代码CODE</th>
<th>描述 Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>Echo Reply——回显应答（Ping应答）</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>Network Unreachable——网络不可达</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>Host Unreachable——主机不可达</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>Protocol Unreachable——协议不可达</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>Port Unreachable——端口不可达</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>Fragmentation needed but no frag. bit set——需要进行分片但设置不分片比特</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>Source routing failed——源站选路失败</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>Destination network unknown——目的网络未知</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>Destination host unknown——目的主机未知</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>Source host isolated (obsolete)——源主机被隔离（作废不用）</td>
</tr>
<tr>
<td>3</td>
<td>9</td>
<td>Destination network administratively prohibited——目的网络被强制禁止</td>
</tr>
<tr>
<td>3</td>
<td>10</td>
<td>Destination host administratively prohibited——目的主机被强制禁止</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>Network unreachable for TOS——由于服务类型TOS，网络不可达</td>
</tr>
<tr>
<td>3</td>
<td>12</td>
<td>Host unreachable for TOS——由于服务类型TOS，主机不可达</td>
</tr>
<tr>
<td>3</td>
<td>13</td>
<td>Communication administratively prohibited by filtering——由于过滤，通信被强制禁止</td>
</tr>
<tr>
<td>3</td>
<td>14</td>
<td>Host precedence violation——主机越权</td>
</tr>
<tr>
<td>3</td>
<td>15</td>
<td>Precedence cutoff in effect——优先中止生效</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>Source quench——源端被关闭（基本流控制）</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>Redirect for network——对网络重定向</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>Redirect for host——对主机重定向</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>Redirect for TOS and network——对服务类型和网络重定向</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>Redirect for TOS and host——对服务类型和主机重定向</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>Echo request——回显请求（Ping请求）</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>Router advertisement——路由器通告</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>Route solicitation——路由器请求</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>TTL equals 0 during transit——传输期间生存时间为0</td>
</tr>
<tr>
<td>11</td>
<td>1</td>
<td>TTL equals 0 during reassembly——在数据报组装期间生存时间为0</td>
</tr>
<tr>
<td>12</td>
<td>0</td>
<td>IP header bad (catchall error)——坏的IP首部（包括各种差错）</td>
</tr>
<tr>
<td>12</td>
<td>1</td>
<td>Required options missing——缺少必需的选项</td>
</tr>
<tr>
<td>13</td>
<td>0</td>
<td>Timestamp request (obsolete)——时间戳请求（作废不用）</td>
</tr>
<tr>
<td>14</td>
<td></td>
<td>Timestamp reply (obsolete)——时间戳应答（作废不用）</td>
</tr>
<tr>
<td>15</td>
<td>0</td>
<td>Information request (obsolete)——信息请求（作废不用）</td>
</tr>
<tr>
<td>16</td>
<td>0</td>
<td>Information reply (obsolete)——信息应答（作废不用）</td>
</tr>
<tr>
<td>17</td>
<td>0</td>
<td>Address mask request——地址掩码请求</td>
</tr>
<tr>
<td>18</td>
<td>0</td>
<td>Address mask reply——地址掩码应答</td>
</tr>
</tbody></table>
<h4 id="ping-命令诊断网络故障"><a href="#ping-命令诊断网络故障" class="headerlink" title="ping 命令诊断网络故障"></a>ping 命令诊断网络故障</h4><ul>
<li><p><strong>ping 命令只能检测两端口通或不通</strong></p>
</li>
<li><p>PING（Packet Internet Grope），因特网包探索器，用于测试网络连接量的程序。Ping 发送一个 ICMP 回声请求消息给目的地并报告是否收到所希望的 ICMP 回声应答。</p>
</li>
<li><p>ping指的是<strong>端对端</strong>连通，通常用来作为可用性的检查，但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。</p>
</li>
<li><p>如果你打开IE浏览器访问网站失败，你可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索，下面展示ping命令返回的信息以及分析其原因。</p>
<ul>
<li><p>目标主机不可到达</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620230522983.png" alt="image-20230620230522983"></p>
</li>
<li><p>目标网络不可到达</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620230538797.png" alt="image-20230620230538797"></p>
</li>
<li><p>请求超时</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620230548715.png" alt="image-20230620230548715"></p>
<p>说明丢包了</p>
</li>
<li><p>通过延迟评估网络带宽</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620230607345.png" alt="image-20230620230607345"></p>
<p>可以看到最小延迟为54ms，最大延迟57ms，平均延迟55ms</p>
<p>当 ping 本计算机网关的时候延迟小，速度快</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620230618540.png" alt="image-20230620230618540"></p>
</li>
</ul>
</li>
</ul>
<h4 id="pathping命令跟踪数据包路径"><a href="#pathping命令跟踪数据包路径" class="headerlink" title="pathping命令跟踪数据包路径"></a>pathping命令跟踪数据包路径</h4><p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620230651444.png" alt="image-20230620230651444"></p>
<ol>
<li><p>当PC0 ping PC1时不通，可能是1~4处某一处或多处断了，也可能是PC1没有开机。而使用PC0 pathping PC1时，从PC0到PC1，每经过一个路由器都会通过该路由器给PC0发回一个数据包说明PC0到该路由器的路径是通的。即Router1给PC0发回一个数据包则表示1、 2通；Router2给PC0发回一个数据包表示1、 2、 3通。在网络排错中具有很强的实用意义。</p>
</li>
<li><p>若 Router0 设置了进入的数据包无法追踪该路由器，PC0 pathping PC1时，数据包可以通过Router0，但是Router0不会给PC0返回一个数据包</p>
</li>
</ol>
<hr>
<p>输入命令</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pathping</span> www.bilibili.com</span><br></pre></td></tr></table></figure>

<p>表示从本计算机访问 “<a href="http://www.bilibili.com”/">www.bilibili.com”</a> 该网站的服务器，并追踪途经的各个中转路由器</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620231528107.png" alt="image-20230620231528107"></p>
<p>同时pathping命令还会统计通信方到每个中转路由器的丢包率，由此可以看出从哪到哪丢包严重，网络延迟大，据此可以优化网络。</p>
<blockquote>
<p>相同类型的有trace route命令，该命令较为简略不会统计丢包率</p>
</blockquote>
<h3 id="IGMP-报文"><a href="#IGMP-报文" class="headerlink" title="IGMP 报文"></a>IGMP 报文</h3><h1 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h1><p>常见的以太网接口类型有RJ45接口（电脑网口）、RJ11接口（电话线）、SC光纤接口等。其中RJ45接口是我们常见的网络设备接口，其采用差分传输方式，具有传输速率快、抗干扰、传输距离远等优点。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620233643610.png" alt="image-20230620233643610"></p>
<p>RJ45接口定义以及各引脚功能说明如下图所示，在以太网中只使用了1、2、3、6这四根线，其中1、2这组负责传输数据（TX+、TX-），而3、6这组负责接收数据（RX+、RX-），另外四根线是备用的。</p>
<p><img src="/MD_IMG/%E4%BB%A5%E5%A4%AA%E7%BD%91.assets/image-20230620233731232.png" alt="image-20230620233731232"></p>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>以太网</tag>
      </tags>
  </entry>
  <entry>
    <title>数字电路基础</title>
    <url>/2023/07/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-数字逻辑概论"><a href="#1-数字逻辑概论" class="headerlink" title="1. 数字逻辑概论"></a>1. 数字逻辑概论</h1><h2 id="1-1-数字信号与数字电路"><a href="#1-1-数字信号与数字电路" class="headerlink" title="1.1 数字信号与数字电路"></a>1.1 数字信号与数字电路</h2><h3 id="1-1-1-概念"><a href="#1-1-1-概念" class="headerlink" title="1.1.1 概念"></a>1.1.1 概念</h3><p>用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。</p>
<h3 id="1-1-2-发展历史"><a href="#1-1-2-发展历史" class="headerlink" title="1.1.2 发展历史"></a>1.1.2 发展历史</h3><ul>
<li>1948年，贝尔实验室制成第一只晶体管（Wllliam Shockley）</li>
<li>1958年，集成电路（Jack Kilby）</li>
<li>1969年，大规模集成电路</li>
<li>1975年，超大规模集成电路</li>
</ul>
<h3 id="1-1-3-分类"><a href="#1-1-3-分类" class="headerlink" title="1.1.3 分类"></a>1.1.3 分类</h3><ul>
<li>有无集成元器件<ul>
<li>分立元器件数字电路：晶体管（二极管、三极管、MOS管）</li>
<li>集成数字电路：编码器、锁存器、译码器、CPU、AD&#x2F;DA等</li>
</ul>
</li>
<li>功能<ul>
<li>组合逻辑电路<ul>
<li>组成：由最基本的逻辑门电路组合而成</li>
<li>特点：输出值只与当时的输入值有关，即输出惟一地由当时的输入值决定。</li>
<li>举例：3-8译码器</li>
</ul>
</li>
<li>时序逻辑电路<ul>
<li>组成：由最基本的逻辑门电路加上反馈逻辑回路（输出到输入）或器件组合而成的电路，与组合电路最本质的区别在于时序电路具有记忆功能。</li>
<li>特点：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。</li>
</ul>
</li>
</ul>
</li>
<li>集成电路的集成度<ul>
<li>小规模集成数字电路（SSI）（Small-Scale Integration）</li>
<li>中规模集成数字电路（MSI）（Middle-Scale Integration）</li>
<li>大规模集成数字电路（LSI）（Large-Scale Integration）</li>
<li>超大规模集成数字电路（VLSI）（Very-Large-Scale Integration）</li>
</ul>
</li>
<li>半导体器件<ul>
<li>双极性数字电路：由三极管组成</li>
<li>单极性数字电路：由MOS管组成</li>
</ul>
</li>
</ul>
<h3 id="1-1-4-优点"><a href="#1-1-4-优点" class="headerlink" title="1.1.4 优点"></a>1.1.4 优点</h3><ul>
<li>稳定性好，可靠性高</li>
<li>可长期存储</li>
<li>便于计算机处理</li>
<li>便于高度集成化</li>
</ul>
<h3 id="1-1-5-数电与模电的区别"><a href="#1-1-5-数电与模电的区别" class="headerlink" title="1.1.5 数电与模电的区别"></a>1.1.5 数电与模电的区别</h3><ul>
<li><p><strong>工作任务不同</strong></p>
<ul>
<li>模电研究的输出与输入信号的大小、相位、失真等的关系</li>
<li>数字电路主要研究的是输出与输入间的逻辑关系</li>
</ul>
</li>
<li><p><strong>三极管的工作状态不同</strong></p>
<ul>
<li>模电主要工作在放大区</li>
<li>数字电路中的三极管工作在饱和或截止状态，起开关作用</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220626161722695.png" alt="image-20220626161722695" style="zoom: 67%;" />
</li>
<li><p><strong>模拟信号与数字信号</strong></p>
<ul>
<li>数字信号是离散（不连续）的，而模拟信号是连续的；</li>
<li>数字信号只有“0”和“1”两种状态，而模拟信号可以是任意数值状态；</li>
<li>模拟信号是用一系列连续变化的电磁波或电压信号来表示，而数字信号是用一系列断续变化的电压脉冲或光脉冲来表示。</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220626161403118.png" alt="image-20220626161403118" style="zoom:67%;" /></li>
</ul>
<h2 id="1-2-数制"><a href="#1-2-数制" class="headerlink" title="1.2 数制"></a>1.2 数制</h2><ul>
<li><p><strong>概述</strong>：数字电路所处理的各种数字信号都是以数码（一种符号）形式给出的，用数码表示数量的大小时采用的各种计数进位制规则称为数制</p>
</li>
<li><p><strong>进位制</strong>：多位数码每一位的构成以及从低位到高位的进位规则</p>
</li>
<li><p><strong>基数</strong>：数制所使用数码的个数</p>
</li>
<li><p><strong>位权</strong>：在某一进位制的数中，每一位的大小都对应着该位上的数码乘上一个固定的数，这个固定的数就是这一位的权数，权数是一个寡</p>
</li>
<li><p><strong>常用的进制</strong></p>
<ul>
<li>十进制（Decimal）</li>
<li>二进制（Binary）</li>
<li>八进制（Octal）</li>
<li>十六进制（Hexadecimal）</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220626163323810.png" alt="image-20220626163323810" style="zoom:80%;" />
</li>
<li><p><strong>二进制的算术运算</strong></p>
<p>当两个二进制数码表示两个数量大小时，他们之间可以进行数值运算，这种运算称为算术运算</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220626163539563.png" alt="image-20220626163539563" style="zoom: 67%;" /></li>
</ul>
<h2 id="1-3-编码（二进制编码）"><a href="#1-3-编码（二进制编码）" class="headerlink" title="1.3 编码（二进制编码）"></a>1.3 编码（二进制编码）</h2><h3 id="1-3-1-概念"><a href="#1-3-1-概念" class="headerlink" title="1.3.1 概念"></a>1.3.1 概念</h3><p>用二进制数表示各种数字或符号的过程称为编码。</p>
<h3 id="1-3-2-原码、反码和补码"><a href="#1-3-2-原码、反码和补码" class="headerlink" title="1.3.2 原码、反码和补码"></a>1.3.2 原码、反码和补码</h3><ul>
<li>原码：最高位是符号位，0代表正数，1代表负数，非符号位为该数字绝对值的二进制。</li>
<li>反码：正数的反码与原码一致，负数的反码是对原码按位取反，只是最高位（符号位）不变。</li>
<li>补码：正数的补码与原码一致，负数的补码是对原码按位取反加1，符号位不变。</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220626164156419.png" alt="image-20220626164156419" style="zoom: 67%;" />

<h3 id="1-3-3-常见编码（2421BCD，5421BCD和8421BCD码、余3码）"><a href="#1-3-3-常见编码（2421BCD，5421BCD和8421BCD码、余3码）" class="headerlink" title="1.3.3 常见编码（2421BCD，5421BCD和8421BCD码、余3码）"></a>1.3.3 常见编码（2421BCD，5421BCD和8421BCD码、余3码）</h3><ul>
<li>余3码：在8421BCD码基础上加 3 得到</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220626164455340.png" alt="image-20220626164455340"></p>
<h3 id="1-3-4-格雷码（Gray-Code）"><a href="#1-3-4-格雷码（Gray-Code）" class="headerlink" title="1.3.4 格雷码（Gray Code）"></a>1.3.4 格雷码（Gray Code）</h3><ul>
<li><p>概念：两个相邻代码之间仅有1位数码不同的无权码</p>
</li>
<li><p>优点：功耗低、变化快、出错的几率小</p>
</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220626164710620.png" alt="image-20220626164710620" style="zoom: 67%;" />

<h3 id="1-3-5-奇偶校验码"><a href="#1-3-5-奇偶校验码" class="headerlink" title="1.3.5 奇偶校验码"></a>1.3.5 奇偶校验码</h3><ul>
<li>奇校验：一组二进制代码的数位中 ‘1‘ 的个数为奇数，校验位为0；偶数为1</li>
<li>偶校验：一组二进制代码的数位中 ‘1‘ 的个数为偶数，校验位为0；偶数为1</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220626165256413.png" alt="image-20220626165256413" style="zoom: 50%;" />

<h2 id="1-4-逻辑函数及其表示方法"><a href="#1-4-逻辑函数及其表示方法" class="headerlink" title="1.4 逻辑函数及其表示方法"></a>1.4 逻辑函数及其表示方法</h2><ul>
<li><strong>逻辑变量</strong>：输入逻辑变量和输出逻辑变量。</li>
<li><strong>逻辑函数</strong>：描述输入逻辑变量和输出逻辑变量之间的因果关系。由于逻辑变量是只取0或1的二值逻辑变量，因此逻辑函数也是二值逻辑函数。</li>
<li><strong>逻辑函数的表示方法</strong>：<ul>
<li><strong>真值表</strong>：将输入变量所有可能的取值与相应的函数值列成表格，就得到真值表。</li>
<li><strong>逻辑表达式</strong>：逻辑表达式是用与、或、非等运算组合起来，表示逻辑函数与逻辑变量之间关系的逻辑代数式。</li>
<li><strong>逻辑图</strong>：用与、或、非等逻辑符号表示逻辑函数中各变量之间的逻辑关系所得到的图形称为逻辑图。</li>
<li><strong>波形图</strong>：对输入变量随时间变化的每一种取值，求出相应的输出值。并将输入和输出关系按时间顺序依次排列得到的图形，称为波形图。</li>
</ul>
</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628143839686.png" alt="image-20220628143839686"></p>
<h1 id="2-逻辑代数"><a href="#2-逻辑代数" class="headerlink" title="2. 逻辑代数"></a>2. 逻辑代数</h1><p>逻辑代数的基本运算规律</p>
<p>逻辑代数的基本定理</p>
<p>逻辑函数的描述方法</p>
<p>逻辑函数描述方法间的转换</p>
<p>逻辑函数的公式化简法</p>
<p>逻辑函数的两种标准形式</p>
<p>卡诺图化简法</p>
<h1 id="3-逻辑门电路"><a href="#3-逻辑门电路" class="headerlink" title="3. 逻辑门电路"></a>3. 逻辑门电路</h1><h2 id="3-1-逻辑门电路简介"><a href="#3-1-逻辑门电路简介" class="headerlink" title="3.1 逻辑门电路简介"></a>3.1 逻辑门电路简介</h2><h3 id="3-1-1-基本门电路（与或非）"><a href="#3-1-1-基本门电路（与或非）" class="headerlink" title="3.1.1 基本门电路（与或非）"></a>3.1.1 基本门电路（与或非）</h3><ul>
<li><strong>概念</strong>：用以实现基本逻辑和复合逻辑运算的单元电路称为门电路，或逻辑门</li>
<li><strong>正逻辑</strong>：用高电平表示逻辑1，用低电平表示逻辑0</li>
<li><strong>负逻辑</strong>：用低电平表示逻辑1，用高电平表示逻辑0</li>
<li><strong>与（AND）符号</strong>：“·”，Y&#x3D;A·B</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220626171624710.png" alt="image-20220626171624710" style="zoom:60%;" />

<ul>
<li><p>或（OR）符号：”+”，Y&#x3D;A+B</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220626172011360.png" alt="image-20220626172011360" style="zoom:60%;" />
</li>
<li><p>非（NOT）符号：“ ‘ 或 ^—^ ”，Y&#x3D;A’</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220626172540889.png" alt="image-20220626172540889" style="zoom:60%;" /></li>
</ul>
<h3 id="3-1-2-复合门电路"><a href="#3-1-2-复合门电路" class="headerlink" title="3.1.2 复合门电路"></a>3.1.2 复合门电路</h3><p>  复合门电路又称组合门电路，由基本门电路组合而成（与非门、或非门、与或非门、异或门、同或门）。</p>
<ul>
<li><p>与非门</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220626173451154.png" alt="image-20220626173451154" style="zoom:60%;" />
</li>
<li><p>或非门 </p>
<img src="/MD_IMG/数字电路基础.assets/image-20220626173629186.png" alt="image-20220626173629186" style="zoom:60%;" />
</li>
<li><p>与或非门</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220626173844770.png" alt="image-20220626173844770" style="zoom:60%;" />
</li>
<li><p>异或门</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220626174009407.png" alt="image-20220626174009407" style="zoom:60%;" />
</li>
<li><p>同或门</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220626174143382.png" alt="image-20220626174143382" style="zoom:60%;" /></li>
</ul>
<h2 id="3-2-晶体管"><a href="#3-2-晶体管" class="headerlink" title="3.2 晶体管"></a>3.2 晶体管</h2><ul>
<li><strong>定义</strong>：晶体管（Transistor），是一种固体半导体器件，包括二极管（二端子）、三极管、场效应管、晶闸管（后三者均为三端子）等，具有检波、整流、放大、开关、稳压、信号调制等功能。</li>
<li><strong>分类</strong>：三端子晶体管主要分为两大类<ul>
<li>双极性晶体管（BJT）</li>
<li>场效应晶体管（FET，单极性）</li>
</ul>
</li>
</ul>
<h3 id="3-2-1-BJT"><a href="#3-2-1-BJT" class="headerlink" title="3.2.1 BJT"></a>3.2.1 BJT</h3><ul>
<li><p>半导体三极管（Bipolar Junction Transistor，BJT），也称双极型晶体管、晶体三极管。</p>
</li>
<li><p>对于NPN管，它是由2块N型半导体中间夹着一块P型半导体所组成，发射区与基区之间形成的PN结称为发射结，而集电区与基区形成的PN结 称为集电结，三条引线分别称为发射极e（Emitter）、基极b（Base）和集电极c（Collector），类型分为<strong>NPN型与PNP型</strong>，如下图：</p>
</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220709155814368.png" alt="image-20220709155814368"></p>
<ul>
<li><strong>三种工作状态</strong>（以NPN型为例）<ul>
<li>截止状态：当发射结为零偏，集电结为反向偏置</li>
<li>放大状态：发射结正向偏置，集电结反向偏置</li>
<li>饱和状态：发射结正向偏置，集电结正向偏置</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-FET"><a href="#3-2-2-FET" class="headerlink" title="3.2.2 FET"></a>3.2.2 FET</h3><p>场效应晶体管（Field Effect Transistor，FET），简称场效应管。主要有两种类型：结型场效应管（junction FET，JFET）和金属-氧化物半导体场效应管（metal-oxide semiconductor FET，MOS-FET）。由多数载流子参与导电，也称为单极型晶体管。它属于电压控制型半导体器件。具有输入电阻高（10^7^~10^15^Ω）、噪声小、功耗低、动态范围大、易于集成、没有二次击穿现象、安全工作区域宽等优点，现已成为双极型晶体管和功率晶体管的强大竞争者。</p>
<h2 id="3-3-MOS管及其开关特性"><a href="#3-3-MOS管及其开关特性" class="headerlink" title="3.3 MOS管及其开关特性"></a>3.3 MOS管及其开关特性</h2><p>近年来，数字电路基本上都是由 MOSFET 场效应管构成的，简称MOS管。MOSFET是一种在施加电压后可以像开关一样工作的半导体器件。按照导电载流子的不同，MOSFET分为N沟道MOS（NMOS）管和P沟道MOS（PMOS）管。按照导电沟道形成机理的不同分为增强型和耗尽型。</p>
<h3 id="3-3-1-N沟道增强型MOS管的结构和工作原理"><a href="#3-3-1-N沟道增强型MOS管的结构和工作原理" class="headerlink" title="3.3.1 N沟道增强型MOS管的结构和工作原理"></a>3.3.1 N沟道增强型MOS管的结构和工作原理</h3><p>N沟道增强型MOS管的结构示意图及符号如图3.2.1所示。它是在P型衬底上，用扩散法制作两个高掺杂浓度的N区。然后在P型硅表面生长一层很薄的二氧化硅绝缘层，并在二氧化硅表面及两个N型区各安置一个电极，形成栅极g（Gate）、源极s（Source）和漏极d（Drain）。由于栅极被绝缘，其电阻高达10^12^~10^15^Ω。通常将衬底与源极相连，或接地电位，以防止有电流从衬底流入源极和导电沟道。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628145050644.png" alt="image-20220628145050644"></p>
<p>如果栅极和源极之间所加电压v<del>GS</del>&#x3D;0，则源区、衬底和漏区形成的两个PN结背靠背串联，d间不导通，i<del>D</del>&#x3D;0。</p>
<p>当栅源之间加正向电压v<del>GS</del>，且v<del>GS</del>≥V<del>T</del>（<strong>V<del>T</del>为开启电压</strong>）时，栅极和衬底之间形成足够强的电场，吸引衬底中的少数载流子（电子），使其聚集在栅极下的衬底表面，形成N型反型层，该反型层就构成了d、s间的导电沟道。若此时漏极和源极之间加电压s，将有漏极电流i<del>D</del>产生，如图3.2.2所示。这种在v<del>GS</del>&#x3D;0时不存在导电沟道，v<del>GS</del>必须增强到足够大时才形成导电沟道的场敚应管，称为N沟道增强型MOS管。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628145226071.png" alt="image-20220628145226071"></p>
<h3 id="3-3-2-N沟道增强型MOS管的输出特性和转移特性"><a href="#3-3-2-N沟道增强型MOS管的输出特性和转移特性" class="headerlink" title="3.3.2 N沟道增强型MOS管的输出特性和转移特性"></a>3.3.2 N沟道增强型MOS管的输出特性和转移特性</h3><p>MOS管可视为二端口网络，如图 3.2.3 所示，栅-源为输入端口，漏-源为输出端口，源极为公共端，故称共源极连接。当端口电压不同时，回路电流也将发生变化。因此用 I-V 特性曲线反映电压与电流的关系。MOS管的 I-V 特性包括输出特性和转移特性，分别如图3.2.4（a）、（b）所示。</p>
<p><strong>输出特性曲线</strong>是指栅源电压 v<del>GS</del>一定的情况下，漏极电流in与漏源电压vns之间的关系。输出特性曲线分为三个工作区<strong>：截止区、饱和区和可变电阻区</strong>。</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220628145817592.png" alt="image-20220628145817592"  />

<ul>
<li><p>当 v<del>GS</del>&lt;V<del>T</del>，时，导电沟道尚未形成，i<del>D</del>&#x3D;0，漏-源间电阻很大，可达10^9^ Ω以上，相当于断开，MOS管处于截止工作状态，特性曲线的该区域称为<strong>截止区</strong>。</p>
</li>
<li><p>当 v<del>GS</del>≥V<del>T</del>，时，产生导电沟道，外加 v<del>DS</del> 较小时，i<del>D</del>随 v<del>DS</del> 呈线性增长。此时MOS管可以看成一个受v<del>GS</del>控制的可变电阻 r<del>ds</del>，v<del>GS</del>越大，输出特性曲线越倾斜，等效电阻越小。因此，该区域称为<strong>可变电阻区</strong>。r<del>ds</del>由下式确定。由式（3.2.1）可知，为使 r<del>ds</del>尽可能小，应当使 v<del>GS</del> 尽可能大。</p>
</li>
<li><p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628150259489.png" alt="image-20220628150259489"></p>
</li>
<li><p>当 v<del>DS</del> 继续增加到一定数值使 v<del>DS</del> &#x3D; v<del>GS</del> - V<del>T</del>，时，沟道在靠近漏极处开始消失，称为预夹断。随着 v<del>DS</del> 继续增加，i<del>D</del> 几乎不再增加，此时的区域称为<strong>饱和区</strong>。因此，当v<del>DS</del> &lt; v<del>GS</del> - V<del>T</del>，时，N沟道MOS管工作于<strong>可变电阻区</strong>。当v<del>DS</del> ≥ v<del>GS</del> - V<del>T</del>，时，MOS管工作于<strong>饱和区</strong>。</p>
</li>
</ul>
<p><strong>转移特性</strong>是指在漏源电压 v<del>DS</del> 一定的条件下，栅源电压 v<del>GS</del> 对漏极电流 i<del>D</del> 的控制作用。当MOS管工作在饱和区时，由于  v<del>DS</del> 对 i<del>D</del> 的影响很小，所以不同的 v<del>DS</del> 所对应的转移特性曲线基本重合，可以用一条曲线来表示。这条曲线与横坐标的交点即为开启电压 V<del>T</del>。</p>
<h3 id="3-3-3-其他类型的MOS管"><a href="#3-3-3-其他类型的MOS管" class="headerlink" title="3.3.3 其他类型的MOS管"></a>3.3.3 其他类型的MOS管</h3><p>1）P沟道增强型MOS管</p>
<p>与N沟道MOS管相反，P沟道MOS管是在N型衬底上制作两个高浓度的P区，导电沟道为P型，载流子为空穴。其符号如图3.2.5所示。通常将衬底与源极相连，或接电源。为吸引空穴形成导电沟道，栅极接电源负极，与衬底相连的源极接电源的正极，即v<del>GS</del>为负值，因此开启电压V<del>T</del>也为负值。而i<del>D</del>的实际方向为流出漏极，与通常的假定方向正好相反。图3.2.6所示为P沟道增强型MOS管的输出特性和转移特性曲线。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628153121973.png" alt="image-20220628153121973"></p>
<p>2）N沟道耗尽型MOS管</p>
<p>N沟道耗尽型MOS管的结构与增强型基本相同，最大的区别是在生产过程中，在SiO<del>2</del>绝缘层中掺入大量正离子，其结构示意图与符号如图3.2.7所示。v<del>GS</del>&#x3D;0时，由于正离子的作用，将电子吸引到栅极下面的衬底表面形成N型沟道。当v<del>GS</del>&gt;0时，沟道变宽。在v<del>DS</del>作用下，i<del>D</del>的数值更大。v<del>GS</del>为负，沟道变窄，i<del>D</del>减小，当v<del>GS</del>达到某一负值V<del>P</del>时，沟道完全被夹断，即使加v<del>DS</del>，也不会有漏极电流i<del>D</del>，MOS管截止，V<del>P</del>称为夹断电压。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628153607512.png" alt="image-20220628153607512"></p>
<p>3）P沟道耗尽型MOS管</p>
<p>P沟道耗尽型MOS管的结构与增强型基本相同，但在SiO<del>2</del>绝缘层中掺入大量负离子，形成P型导电沟道，其夹断电压V<del>P</del>为正值。v<del>GS</del>可以是负值、零或正值。v<del>GS</del>为负值时i<del>D</del>增加，v<del>GS</del>为正值时i<del>D</del>减小。当v<del>GS</del>达到V<del>P</del>时，沟道完全被夹断，MOS管截止。P沟道耗尽型MOS管的符号如图3.2.8所示。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628153919842.png" alt="image-20220628153919842"></p>
<h3 id="3-3-4-MOS管开关电路"><a href="#3-3-4-MOS管开关电路" class="headerlink" title="3.3.4 MOS管开关电路"></a>3.3.4 MOS管开关电路</h3><p>用N沟道增强型MOS管替代图3.1.3所示的开关S构成的电路如图3.2.9所示。MOS管的作用对应于有触点开关S的“断开”和“闭合”，但在速度和可靠性方面比机械开关优越得多。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628154101344.png" alt="image-20220628154101344"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628154238434.png" alt="image-20220628154238434"></p>
<h3 id="3-3-5-MOS管开关电路的动态特性"><a href="#3-3-5-MOS管开关电路的动态特性" class="headerlink" title="3.3.5 MOS管开关电路的动态特性"></a>3.3.5 MOS管开关电路的动态特性</h3><p>在图3.2.9所示MOS管开关电路的输入端，加一个理想的脉冲波形，如图3.2.11（a）所示。由于MOS管中栅极与衬底间电容C<del>gb</del>（即数据手册中的输入电容C<del>1</del>）、漏极与衬底间电容C<del>db</del>、栅极与漏极电容C<del>gd</del>以及导通电阻等的存在，使其在导通和闭合两种状态之间转换时，不可避免地受到电容充、放电过程的影响。输出电压v<del>o</del>的波形已不是与输入一样的理想脉冲，如图3.2.11（b）所示。上升沿和下降沿的变化都变得缓慢了，而且输出v<del>O</del>的变化滞后于输入v<del>I</del>的变化，t<del>pHL</del> 为输出v<del>O</del>由高电平跳变为低电平的传输延迟时间，t<del>pLH</del>为输出v<del>O</del>由低电平跳变为高电平的传输延迟时间。</p>
<p>图3.2.9所示电路中R<del>d</del>的作用是：当输入为高电平时，流过导通NMOS管的电流很大，R<del>d</del>起限流作用，但此时消耗在其上的功率也很大。为了克服这个缺点，用另一个PMOS管替代电阻R<del>d</del>，就构成了CMOS反相器。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628154836940.png" alt="image-20220628154836940"></p>
<h2 id="3-4-CMOS门电路"><a href="#3-4-CMOS门电路" class="headerlink" title="3.4 CMOS门电路"></a>3.4 CMOS门电路</h2><h3 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h3><p>CMOS集成门电路简称CMOS门电路，以金属-氧化物-半导体场效应晶体管（Metal-Oxide-Semiconductor Field Effect Transistor）作为开关器件。由PMOS场效应管和NMOS场效应管以互补对称的形式组成。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220626181436221.png" alt="image-20220626181436221"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220626181620220.png" alt="image-20220626181620220"></p>
<ul>
<li>CMOS集成电路的性能及特点<ul>
<li>功耗低：只有一个</li>
<li>工作电压范围宽</li>
<li>逻辑摆幅大</li>
<li>抗干扰能力强（噪声容限大）</li>
<li>输入阻抗高</li>
<li>温度稳定性能好</li>
<li>扇出能力强 </li>
<li>抗辐射能力强</li>
</ul>
</li>
</ul>
<h3 id="3-4-2-COMS反相器"><a href="#3-4-2-COMS反相器" class="headerlink" title="3.4.2 COMS反相器"></a>3.4.2 COMS反相器</h3><h4 id="3-4-2-1-电压传输特性"><a href="#3-4-2-1-电压传输特性" class="headerlink" title="3.4.2.1 电压传输特性"></a>3.4.2.1 电压传输特性</h4><img src="/MD_IMG/数字电路基础.assets/image-20220626230418422.png" alt="image-20220626230418422" style="zoom:67%;" />

<h4 id="3-4-2-2-电流传输特性"><a href="#3-4-2-2-电流传输特性" class="headerlink" title="3.4.2.2  电流传输特性"></a>3.4.2.2  电流传输特性</h4><img src="/MD_IMG/数字电路基础.assets/image-20220626230521385.png" alt="image-20220626230521385" style="zoom:50%;" />

<h4 id="3-4-2-3-输入端噪声容限"><a href="#3-4-2-3-输入端噪声容限" class="headerlink" title="3.4.2.3  输入端噪声容限"></a>3.4.2.3  输入端噪声容限</h4><ul>
<li><p>概念：在保证输出的高低电平基本不变的条件下，允许输入信号的高低电平有一个波动范围。</p>
</li>
<li><p>输入端噪声容限决定该器件的抗干扰能力</p>
</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220626230636680.png" alt="image-20220626230636680" style="zoom:80%;" />

<img src="/MD_IMG/数字电路基础.assets/image-20220626230913688.png" alt="image-20220626230913688" style="zoom: 67%;" />

<ul>
<li>不同的系统电压（V<del>DD</del>）决定系统的噪声容限，噪声容限是有一定范围的，系统电压越大，噪声容限范围越大。</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220626231247513.png" alt="image-20220626231247513"></p>
<h4 id="3-4-2-4-静态特性"><a href="#3-4-2-4-静态特性" class="headerlink" title="3.4.2.4  静态特性"></a>3.4.2.4  静态特性</h4><ul>
<li>静态特性：指电路在保持某一种状态不变化的情况下的一些特性。</li>
<li>动态特性：对于CMOS电路，动态特性指输入电平在0-1之间跳变的时候电路所呈现出来的特性</li>
<li>输入特性（Input Characteristic）：从反相器输入端看进去的输入电压与输入电流的关系</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220626235916575.png" alt="image-20220626235916575" style="zoom: 60%;" />

<ul>
<li>输出特性：从反相器输出端看进去的输出电压与输出电流的关系</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220627000559069.png" alt="image-20220627000559069" style="zoom:60%;" />

<h4 id="3-4-2-5-动态特性"><a href="#3-4-2-5-动态特性" class="headerlink" title="3.4.2.5  动态特性"></a>3.4.2.5  动态特性</h4><ul>
<li><strong>传输延迟（Tansmission Delay）</strong></li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220627235408127.png" alt="image-20220627235408127" style="zoom:80%;" />

<ul>
<li><strong>扇出</strong>：以数字表示一个电路的输出端能够驱动同类负载电路输入端的数目</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220628000056383.png" alt="image-20220628000056383" style="zoom:80%;" />

<ul>
<li><strong>动态功耗（Danamic Power）</strong></li>
</ul>
<p> CMOS反相器从一种稳定工作状态突然转变到另一种稳定状态的过程中，将产生附加的功耗。包括两个： </p>
<ol>
<li>因为负载电容充放电所产生的功耗；</li>
</ol>
<img src="/MD_IMG/数字电路基础.assets/image-20220628000931921.png" alt="image-20220628000931921" style="zoom:67%;" />

<ol start="2">
<li>两个MOS管在0-&gt;1、1-&gt;0跳变过程中，会有一个瞬时导通产生的功耗</li>
</ol>
<img src="/MD_IMG/数字电路基础.assets/image-20220628001153071.png" alt="image-20220628001153071" style="zoom:67%;" />

<p><strong>动态功耗 P<del>D</del> &#x3D; P<del>C</del> + P<del>T</del></strong></p>
<p> **静态功耗 P<del>S</del>**：MOS管组成元素PN结，而PN结可以等效为二极管，二极管就会有漏电流，就会才产生功耗。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628001813015.png" alt="image-20220628001813015"></p>
<p>芯片手册有参数：输入漏电流（input leakage current）</p>
<h3 id="3-4-3-COMS与非、或非门电路"><a href="#3-4-3-COMS与非、或非门电路" class="headerlink" title="3.4.3 COMS与非、或非门电路"></a>3.4.3 COMS与非、或非门电路</h3><ul>
<li>输出缓冲器（Output Buffer）</li>
</ul>
<h4 id="3-4-3-1-非门"><a href="#3-4-3-1-非门" class="headerlink" title="3.4.3.1 非门"></a>3.4.3.1 非门</h4><p>CMOS反相器电路如图3.2.12所示，由两只增强型MOS管组成，其中T<del>N</del>为N沟道MOS管，T<del>P</del>为P沟道MOS管。两只MOS管的栅极连在一起作为输入端；它们的漏极连在一起作为输出端。</p>
<p>当输入v<del>1</del>&#x3D;V<del>DD</del>时，输出v<del>o</del>≈0；而输入v<del>1</del>&#x3D;0，输出v<del>o</del>≈V<del>DD</del>。<strong>输出与输入之间为逻辑非的关系</strong>，也称非门为反相器（ Inverter）。CMOS反相器近似于一个理想的逻辑单元，其输出电压接近于零或+V<del>DD</del>。</p>
<img src="/MD_IMG/数字电路基础.assets/image-20211016231345895.png" alt="image-20211016231345895" style="zoom: 67%;" />

<h4 id="3-4-3-2-与非门"><a href="#3-4-3-2-与非门" class="headerlink" title="3.4.3.2 与非门"></a>3.4.3.2 与非门</h4><p>图3.2.17是2输入端CMOS与非门电路，其中包括两个串联的N沟道增强型MOS管和两个并联的P沟道增强型MOS管。每个输入端连到一个N沟道和一个P沟道MOS管的栅极。电路输岀与输入信号逻辑关系及各个MOS管的工作状态如表3.2.1所示。当输入端A、 B有一个为低电平时，就会使与它相连的NMOS管截止，PMOS管导通，输出为高电平；仅当A、 B全为高电平时，才会使两个串联的NMOS管都导通，使两个并联的PMOS管都截止，输出为低电平。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20211016233143552.png" alt="image-20211016233143552"></p>
<p>n个输入端的与非门必须有n个NMOS管串联和n个PMOS管并联。</p>
<h4 id="3-4-3-3-或非门"><a href="#3-4-3-3-或非门" class="headerlink" title="3.4.3.3 或非门"></a>3.4.3.3 或非门</h4><p>图3.2.18是2输入端CMOS或非门电路，其中包括两个并联的N沟道增强型MOS管和两个串联的P沟道增强型MOS管。</p>
<p>电路输出与输入信号逻辑关系及各个MOS管的工作状态如表3.2.2所示。当输入端A、B只要有一个为高电平时，就会使与它相连的NMOS管导通，而PMOS管截止，输出为低电平；仅当A、B全为低电平时，两个并联NMOS管都截止，两个串联的PMOS管都导通，输出为高电平。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20211016234845562.png" alt="image-20211016234845562"></p>
<p>同样，n个输入端的或非门必须有n个NMOS管并联和n个PMOS管串联。</p>
<p>从以上CMOS与非门和或非门电路可知，输入端的数目越多，则串联的管子也越多。若串联的管子全部导通时，其总的导通电阻会增加，以致影响输出电平，使与非门的低电平升高，使或非门的高电平降低。因此CMOS逻辑门电路的输入端不宜过多。</p>
<p>逻辑门电路的电路符号称为 MIL（美军标准）逻辑符号。数字电子电路通过基本逻辑电路的组合来实现各种逻辑电路功能。</p>
<img src="/MD_IMG/数字电路基础.assets/image-20211016235637875.png" alt="image-20211016235637875" style="zoom: 67%;" />

<h4 id="3-4-3-4-改进后的与非、或非门电路"><a href="#3-4-3-4-改进后的与非、或非门电路" class="headerlink" title="3.4.3.4 改进后的与非、或非门电路"></a>3.4.3.4 改进后的与非、或非门电路</h4><p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220628133453433.png"></p>
<h3 id="3-4-4-CMOS漏极开路门（OD门）"><a href="#3-4-4-CMOS漏极开路门（OD门）" class="headerlink" title="3.4.4 CMOS漏极开路门（OD门）"></a>3.4.4 CMOS漏极开路门（OD门）</h3><p>Open-Drain Output</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708181923697.png" alt="image-20220708181923697"></p>
<ul>
<li><strong>定义</strong>：为了满足输出电平变换、吸收大负载电流以及实现线与连接等需求，将输出级电路结构改成一个漏级开路输出的MOS管，构成漏级开路输出门电路。</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708182413755.png" alt="image-20220708182413755"></p>
<ul>
<li><strong>线与的概念</strong>：即两个输出端（包括两个以上）直接互连就可以实现”AND”的逻辑功能</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708182951762.png" alt="image-20220708182951762"></p>
<h3 id="3-4-5-CMOS传输门"><a href="#3-4-5-CMOS传输门" class="headerlink" title="3.4.5 CMOS传输门"></a>3.4.5 CMOS传输门</h3><ul>
<li><p>传输门（Transmission Gate，TG）的应用比较广泛，不仅可以作为基本单元电路构成各种逻辑电路，用于数字信号的传输，而且可以在取样-保持电路、斩波电路、模数和数模转换等电路中传输模拟信号，因而又称为模拟开关。</p>
</li>
<li><p><strong>定义</strong>：CMOS传输门是一种由控制信号来控制电路通断的门电路，利用PMOS和NMOS的互补性组成</p>
</li>
<li><p>使用普通MOS管做传输门是不行的，因为普通MOS管是单向导通的，源极和衬级连在一起，同时只有一个PN结导通</p>
</li>
<li><p>传输门一般用做模拟开关</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708185657309.png" alt="image-20220708185657309"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708185702588.png" alt="image-20220708185702588"></p>
</li>
</ul>
<h3 id="3-4-6-CMOS三态输出门（TSL）"><a href="#3-4-6-CMOS三态输出门（TSL）" class="headerlink" title="3.4.6 CMOS三态输出门（TSL）"></a>3.4.6 CMOS三态输出门（TSL）</h3><p>Tristate Logic</p>
<p>高阻态（High-Impedance State）</p>
<ul>
<li><p>利用OD门虽然可以实现<strong>线与</strong>的功能，但外接电阻R，的选择要受到一定的限制，因此影响了工作速度。同时它省去了PMOS有源负载，使得带负载能力下降。为保持互补输出级的优点，又可以与总线连接，人们又开发了一种三态输出门电路，它的输出除了具有一般门电路的两种状态，即输出高、低电平外，还具有高输出阻抗的第三状态，称为高阻态，又称为禁止态。</p>
</li>
<li><p>三态输出门电路的输出除了高、低电平外，还有第三个状态-高阻态。因这种电路结构总是接在集成电路的输出端，所以也将这种电路称为输出缓冲器。</p>
</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708194609066.png" alt="image-20220708194609066"></p>
<h3 id="3-4-7-闩锁效应（Latch-up）"><a href="#3-4-7-闩锁效应（Latch-up）" class="headerlink" title="3.4.7 闩锁效应（Latch-up）"></a>3.4.7 闩锁效应（Latch-up）</h3><p>闩锁，即Latch-up，是任何CMOS电路中都存在的寄生结构，也是一类引起芯片失效的原因。只要存在PMOS和NMOS的对管，就会存在这种寄生的p-n-p-n的可控硅结构，而一旦触发条件形成，两个寄生三极管构成对电流放大的正反馈通路，从电源到地就会有大电流流过，从而使芯片发热甚至会烧毁芯片，其带来的危害是致命的。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220709002137396.png" alt="image-20220709002137396"></p>
<h2 id="3-5-TTL逻辑门电路"><a href="#3-5-TTL逻辑门电路" class="headerlink" title="3.5 TTL逻辑门电路"></a>3.5 TTL逻辑门电路</h2><p>Transistor-Transistor Logic 晶体管-晶体管逻辑（电路）</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220710001039564.png" alt="image-20220710001039564"></p>
<ul>
<li><strong>TTL反相器工作原理详解及其电压传输特性曲线</strong></li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220710001045809.png" alt="image-20220710001045809"></p>
<ul>
<li><strong>多发射极三极管及TTL与非门、或非门工作原理</strong></li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220710122851756.png" alt="image-20220710122851756"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220710122925957.png" alt="image-20220710122925957"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220710122946507.png" alt="image-20220710122946507"></p>
<h1 id="4-组合逻辑电路"><a href="#4-组合逻辑电路" class="headerlink" title="4.组合逻辑电路"></a>4.组合逻辑电路</h1><ul>
<li>组合逻辑电路（Combinational Logic Circuit）</li>
</ul>
<h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><p>对于一个逻辑电路，其输出状态在任何时刻只取决于同一时刻的输入状态，而与电路原来的状态无关，这种电路被定义为<strong>组合逻辑电路</strong>。</p>
<h2 id="4-2-竞争-冒险现象"><a href="#4-2-竞争-冒险现象" class="headerlink" title="4.2 竞争-冒险现象"></a>4.2 竞争-冒险现象</h2><p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220711215802111.png" alt="image-20220711215802111"></p>
<img src="/MD_IMG/数字电路基础.assets/image-20220711215806271.png" alt="image-20220711215806271" style="zoom:67%;" />

<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220711215820117.png" alt="image-20220711215820117"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220711215824542.png" alt="image-20220711215824542"></p>
<h2 id="4-3-判别和消除竞争-冒险现象的方法"><a href="#4-3-判别和消除竞争-冒险现象的方法" class="headerlink" title="4.3 判别和消除竞争-冒险现象的方法"></a>4.3 判别和消除竞争-冒险现象的方法</h2><ul>
<li>判别方法</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220711220438677.png" alt="image-20220711220438677"></p>
<ul>
<li>消除方法</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220711220915449.png" alt="image-20220711220915449"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220711220931960.png" alt="image-20220711220931960"></p>
<h1 id="5-锁存器和触发器"><a href="#5-锁存器和触发器" class="headerlink" title="5. 锁存器和触发器"></a>5. 锁存器和触发器</h1><p>大多数数字系统中，除了需要具有逻辑运算和算术运算功能的组合逻辑电路外，还需要具有存储功能的电路。组合电路与存储电路结合构成时序逻辑电路，简称时序电路。</p>
<h2 id="5-1-SR锁存器"><a href="#5-1-SR锁存器" class="headerlink" title="5.1 SR锁存器"></a>5.1 SR锁存器</h2><img src="/MD_IMG/数字电路基础.assets/image-20220629231649170.png" alt="image-20220629231649170" style="zoom:67%;" />

<img src="/MD_IMG/数字电路基础.assets/image-20220629231606728.png" alt="image-20220629231606728" style="zoom:80%;" />

<img src="/MD_IMG/数字电路基础.assets/image-20220629232818787.png" alt="image-20220629232818787" style="zoom:67%;" />

<img src="/MD_IMG/数字电路基础.assets/image-20220629232835613.png" alt="image-20220629232835613" style="zoom:67%;" />

<h2 id="5-2-触发器（Flip-Flop）"><a href="#5-2-触发器（Flip-Flop）" class="headerlink" title="5.2 触发器（Flip-Flop）"></a>5.2 触发器（Flip-Flop）</h2><p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220629234632913.png" alt="image-20220629234632913"></p>
<h3 id="5-2-1-电平触发器"><a href="#5-2-1-电平触发器" class="headerlink" title="5.2.1 电平触发器"></a>5.2.1 电平触发器</h3><img src="/MD_IMG/数字电路基础.assets/image-20220629234823650.png" alt="image-20220629234823650"  />

<h3 id="5-2-2-D触发器（D锁存器）"><a href="#5-2-2-D触发器（D锁存器）" class="headerlink" title="5.2.2 D触发器（D锁存器）"></a>5.2.2 D触发器（D锁存器）</h3><img src="/MD_IMG/数字电路基础.assets/image-20220629234922625.png" alt="image-20220629234922625" style="zoom: 67%;" />

<img src="/MD_IMG/数字电路基础.assets/image-20220629234954541.png" alt="image-20220629234954541" style="zoom: 67%;" />



<h3 id="5-2-3-边沿触发器（Edge-Triggered）"><a href="#5-2-3-边沿触发器（Edge-Triggered）" class="headerlink" title="5.2.3 边沿触发器（Edge Triggered）"></a>5.2.3 边沿触发器（Edge Triggered）</h3><img src="/MD_IMG/数字电路基础.assets/image-20220630002244858.png" alt="image-20220630002244858"  />

<img src="/MD_IMG/数字电路基础.assets/image-20220630002255833.png" alt="image-20220630002255833" style="zoom: 67%;" />



<h3 id="5-2-4-脉冲触发器"><a href="#5-2-4-脉冲触发器" class="headerlink" title="5.2.4 脉冲触发器"></a>5.2.4 脉冲触发器</h3><ul>
<li><p>边沿触发器存在空翻现象，为了避免空翻现象，提高触发器工作的可靠性，<strong>希望在每个CLK期间输出端的状态只改变一次</strong>，则在电平触发的触发器的基础上设计出脉冲触发的触发器。</p>
</li>
<li><p>分类</p>
<ul>
<li>脉冲触发的SR触发器（主从SR触发器）</li>
<li>脉冲触发的JK触发器（主从JK触发器）</li>
</ul>
</li>
</ul>
<h4 id="5-2-4-1-脉冲触发的SR触发器"><a href="#5-2-4-1-脉冲触发的SR触发器" class="headerlink" title="5.2.4.1 脉冲触发的SR触发器"></a>5.2.4.1 脉冲触发的SR触发器</h4><img src="/MD_IMG/数字电路基础.assets/image-20220702144939431.png" alt="image-20220702144939431" style="zoom:80%;" />

<img src="/MD_IMG/数字电路基础.assets/image-20220702145347683.png" alt="image-20220702145347683" style="zoom:80%;" />

<h4 id="5-2-4-2-脉冲触发的JK触发器"><a href="#5-2-4-2-脉冲触发的JK触发器" class="headerlink" title="5.2.4.2 脉冲触发的JK触发器"></a>5.2.4.2 脉冲触发的JK触发器</h4>  <img src="/MD_IMG/数字电路基础.assets/image-20220702150145692.png" alt="image-20220702150145692" style="zoom:80%;" />

<img src="/MD_IMG/数字电路基础.assets/image-20220702150413626.png" alt="image-20220702150413626" style="zoom:80%;" />

<h2 id="5-4-触发器的分类（逻辑功能）"><a href="#5-4-触发器的分类（逻辑功能）" class="headerlink" title="5.4 触发器的分类（逻辑功能）"></a>5.4 触发器的分类（逻辑功能）</h2><h3 id="5-4-1-SR触发器"><a href="#5-4-1-SR触发器" class="headerlink" title="5.4.1 SR触发器"></a>5.4.1 SR触发器</h3><p>凡在时钟信号作用下逻辑功能符合表中所规定的逻辑功能无论触发方式如何，均称为SR触发器</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220702151104145.png" alt="image-20220702151104145" style="zoom:60%;" />

<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220702151148685.png" alt="image-20220702151148685"></p>
<img src="/MD_IMG/数字电路基础.assets/image-20220702151302874.png" alt="image-20220702151302874" style="zoom:50%;" />

<h3 id="5-4-2-JK触发器"><a href="#5-4-2-JK触发器" class="headerlink" title="5.4.2 JK触发器"></a>5.4.2 JK触发器</h3><p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220702151434281.png" alt="image-20220702151434281"></p>
<img src="/MD_IMG/数字电路基础.assets/image-20220702152100379.png" alt="image-20220702152100379" style="zoom:80%;" />

<h3 id="5-4-3-T触发器"><a href="#5-4-3-T触发器" class="headerlink" title="5.4.3 T触发器"></a>5.4.3 T触发器</h3><p>  在某些场合，需要这样一种逻辑功能触发器，当控制信号T&#x3D;1时每来一个时钟信号他的状态就翻转一次，而当T&#x3D;0时，时钟信号到达后他的状态保持不变，这种逻辑功能的触发器称为T触发器</p>
<img src="/MD_IMG/数字电路基础.assets/image-20220702151721956.png" alt="image-20220702151721956" style="zoom: 67%;" />

<h3 id="5-4-4-D触发器"><a href="#5-4-4-D触发器" class="headerlink" title="5.4.4 D触发器"></a>5.4.4 D触发器</h3><img src="/MD_IMG/数字电路基础.assets/image-20220702152027162.png" alt="image-20220702152027162" style="zoom:80%;" />



<h2 id="5-5-触发器的动态特性"><a href="#5-5-触发器的动态特性" class="headerlink" title="5.5 触发器的动态特性"></a>5.5 触发器的动态特性</h2><p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220702153221616.png" alt="image-20220702153221616"></p>
<h1 id="6-时序逻辑电路"><a href="#6-时序逻辑电路" class="headerlink" title="6. 时序逻辑电路"></a>6. 时序逻辑电路</h1><h2 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h2><p>对于一个逻辑电路，其输出状态在任何时刻不仅取决于同一时刻的输入状态，还与电路原来的状态有关，这种电路被定义为<strong>时序逻辑电路</strong>，简称时序电路。</p>
<p>时序电路中除具有<strong>逻辑运箅</strong>功能的<strong>组合电路</strong>外，还必须有能够<strong>记忆电路状态</strong>的<strong>存储单元</strong>或延迟单元，这些存储或延迟逻辑单元主要由<strong>锁存器或触发器</strong>组成。</p>
<h1 id="7-存储器（Memory）"><a href="#7-存储器（Memory）" class="headerlink" title="7. 存储器（Memory）"></a>7. 存储器（Memory）</h1><h2 id="7-1-存储器的分类及特点"><a href="#7-1-存储器的分类及特点" class="headerlink" title="7.1 存储器的分类及特点"></a>7.1 存储器的分类及特点</h2><p>磁盘：magnetic disk</p>
<ul>
<li><p><strong>定义</strong></p>
<p><strong>存储器是数字电路系统中</strong>具有记忆功能的部件，由大量的记忆单元组成用来存放二进制数表示的程序或数据</p>
</li>
<li><p><strong>组成</strong></p>
<p>构成存储器的存储介质主要采用半导体器件和磁性材料。存储器中<strong>最小的存储单位就是一个双稳态半导体电路或一个CMOS晶体管或磁性材料的存储元，</strong>它可存储一个二进制代码。由若干个存储元组成一个存储单元，然后再由许多存储单元组成一个存储器</p>
</li>
<li><p><strong>分类</strong></p>
<ul>
<li><p>按存储介质分类</p>
<ul>
<li>半导体存储器（内存储器）</li>
<li>磁表面存储器（磁盘存储器）</li>
</ul>
</li>
<li><p>按存储方式分类</p>
<ul>
<li>随机存储器（RAM）</li>
<li>顺序存储器（磁带存储器）</li>
</ul>
</li>
<li><p>按存储器的读写功<br>能分类</p>
<ul>
<li>只读存储器（ROM）</li>
<li>随机读写存储器（RAM）</li>
</ul>
</li>
<li><p>按信息可保存性分<br>类</p>
<ul>
<li>非永久记忆的存储器</li>
<li>永久记忆性存储器</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>计算机中的存储器</strong></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220702154228317.png" alt="image-20220702154228317"></p>
</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220702155331603.png" alt="image-20220702155331603"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220702160152722.png" alt="image-20220702160152722"></p>
<h2 id="7-2-顺序存储器（SAM）"><a href="#7-2-顺序存储器（SAM）" class="headerlink" title="7.2 顺序存储器（SAM）"></a>7.2 顺序存储器（SAM）</h2><p>Sequential Access Memory</p>
<ul>
<li><strong>定义</strong>：是一种读&#x2F;写存储器，其中数据按照一定顺序串行的写入和读出</li>
<li><strong>组成</strong>：由动态移存器组成的，动态移存器则是由基本的动态移存单元组成的，</li>
<li><strong>动态移存单元</strong>：由MOS管构成，所以称为MOS移存单元，CMOS为常见的动态移存单元</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220704172033107.png" alt="image-20220704172033107" style="zoom: 67%;" />

<img src="/MD_IMG/数字电路基础.assets/image-20220704172108008.png" alt="image-20220704172108008" style="zoom:67%;" />

<h2 id="7-3-只读存储器（ROM）"><a href="#7-3-只读存储器（ROM）" class="headerlink" title="7.3 只读存储器（ROM）"></a>7.3 只读存储器（ROM）</h2><p>Read Only Memory</p>
<ul>
<li><p><strong>ROM分类</strong></p>
<ul>
<li>掩膜只读存储器（Mask Rom）</li>
<li>可编程只读存储器（PROM）</li>
<li>可改写只读存储器（EPROM）</li>
<li>电可改写只读存储器（EEPROM）</li>
<li>快闪存储器（Flash Memory）</li>
</ul>
</li>
<li><p><strong>ROM按构成器件分类</strong></p>
<ul>
<li>二极管ROM</li>
<li>双极性三极管ROM</li>
<li>MOS管ROM</li>
</ul>
</li>
</ul>
<h3 id="7-3-1-掩膜只读存储器（Mask-ROM）"><a href="#7-3-1-掩膜只读存储器（Mask-ROM）" class="headerlink" title="7.3.1 掩膜只读存储器（Mask ROM）"></a>7.3.1 掩膜只读存储器（Mask ROM）</h3><ul>
<li><p><strong>定义</strong>：一种可以长期保存信息的存储器，具有<strong>断电后信息仍可继续保存</strong>的特点，在正常工作时只可读取数据，而不能写入数据</p>
</li>
<li><p>采用掩膜工艺制作OM集成电路芯片时，其中存储的数据是由制作过程中使用的掩膜板决定的</p>
</li>
<li><p><strong>特点</strong>：出厂时已经固定，不能更改，适合大量生产简单，便宜，非易失性</p>
</li>
<li><p><strong>内部结构组成</strong>：储存矩阵、地址译码器、输出缓存器</p>
</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220704173924992.png" alt="image-20220704173924992" style="zoom:67%;" />

<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220704173933543.png" alt="image-20220704173933543"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220704174029518.png" alt="image-20220704174029518"></p>
<h3 id="7-3-2-PROM可编程只读存储器"><a href="#7-3-2-PROM可编程只读存储器" class="headerlink" title="7.3.2 PROM可编程只读存储器"></a>7.3.2 PROM可编程只读存储器</h3><ul>
<li><strong>PROM（Programmable Read Only Memory）</strong>的英文缩写，出厂时他是一种空白ROM，用户可 以根据需要写入信息，但写入信息后就不能再更改</li>
<li><strong>结构</strong>：与ROM结构类似，同样由存储矩阵，地址译码器，和输出电路组成。只是存储单元不同</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220705170716945.png" alt="image-20220705170716945"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220705170722293.png" alt="image-20220705170722293"></p>
<h3 id="7-3-3-EPROM可改写只读存储器"><a href="#7-3-3-EPROM可改写只读存储器" class="headerlink" title="7.3.3 EPROM可改写只读存储器"></a>7.3.3 EPROM可改写只读存储器</h3><p>浮栅：Floating gate</p>
<ul>
<li>EPROM（Erasable Programmable Read Only Memory）具有可写入数据，在紫光灯的照射下可以将写入的数据擦除，再重新写入数据的特点，</li>
<li>结构：与ROM结构类似，存储单元不同，由一种层叠栅MOS管代替普通MOS管</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220705171044087.png" alt="image-20220705171044087" style="zoom:67%;" />

<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220705171951697.png" alt="image-20220705171951697"></p>
<h3 id="7-3-4-EEPROM电可改写只读存储器"><a href="#7-3-4-EEPROM电可改写只读存储器" class="headerlink" title="7.3.4 EEPROM电可改写只读存储器"></a>7.3.4 EEPROM电可改写只读存储器</h3><p>隧道氧化层：Tunnel Oxide</p>
<ul>
<li>EEPROM（Electrically Erasable Programmable Read-Only Memory）具有可写入数据，在电压的控制下并且可以将写入的数据擦除，再重新写入数据的特点</li>
<li>结构：与EPROM很相似，不同之处在于EEPROM的叠层MOS管的浮置栅极上增加了一个隧道管，在电压的控别下，浮置细极上的电子可以通过隧道管放掉</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220705172724846.png" alt="image-20220705172724846" style="zoom:80%;" />

<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220705172732898.png" alt="image-20220705172732898"></p>
<h3 id="7-3-5-Flash-Memory快闪存储器"><a href="#7-3-5-Flash-Memory快闪存储器" class="headerlink" title="7.3.5 Flash Memory快闪存储器"></a>7.3.5 Flash Memory快闪存储器</h3><p>（SD卡：Secure Digital Card）</p>
<ul>
<li><strong>定义</strong>：Flash Memory 一种电子式只读存储器，允许在操作中被多次擦或写的存储器</li>
<li><strong>特点</strong>：<ul>
<li>优点：质量轻、能耗低、体积小、抗震能力强</li>
<li>缺点：需要先擦除再写入；块擦除次数有限；读写干扰</li>
</ul>
</li>
<li><strong>组成</strong>：在MOS管中，除了控制栅Gc以外，还在控制栅和衬底之间又增加了一个浮置册Gf</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708153821211.png" alt="image-20220708153821211"></p>
<ul>
<li><strong>nor flash</strong>：数据线和地址线分开，可以实现ram一样的随机寻址功能，可以读取任何一个字节</li>
<li><strong>nand flash</strong>：据线和地址线复用，不能利用地址线随机寻址。读取只能按页来读取</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708172043640.png" alt="image-20220708172043640"></p>
<h3 id="7-3-6-静态存储器（SRAM）"><a href="#7-3-6-静态存储器（SRAM）" class="headerlink" title="7.3.6 静态存储器（SRAM）"></a>7.3.6 静态存储器（SRAM）</h3><p>（Static Ramdom Access Memory )</p>
<ul>
<li><strong>定义</strong>：采用锁存器作为记忆单元，用静态存储单元构成的存储器称为静态存储器，通常由NMOS和CMOS两种。</li>
<li><strong>优点</strong>：<ul>
<li>数据由锁存器记忆，不需要另设电路定期刷新。</li>
<li>存取速度很快（SRAM采用了与制作CPU相同的半导体工艺）</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>所用元件较多，集成度比DRAM低。</li>
<li>功耗较大。</li>
<li>体积较大，制造成本比DRAM高</li>
</ul>
</li>
</ul>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708173105493.png" alt="image-20220708173105493"></p>
<p>与NMOS相比，CMOS存储单元功耗极小的特点，在降低电源电压的情况下还能保存数据。故可用电池供电，从而弥补随机存储器数据因断电而丢失的缺 点。</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708173634563.png" alt="image-20220708173634563"></p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708174207703.png" alt="image-20220708174207703"></p>
<h3 id="7-3-7-动态存储器（DRAM）"><a href="#7-3-7-动态存储器（DRAM）" class="headerlink" title="7.3.7 动态存储器（DRAM）"></a>7.3.7 动态存储器（DRAM）</h3><p>( Dynamic Ramdom Access Memory )</p>
<ul>
<li><p><strong>组成</strong>：采用MOS管的栅电容（分布电容）来存储数据，用动态存储单元构成的存储器成为动态存储器</p>
</li>
<li><p><strong>优点</strong>：所用元件少，集成度高，功耗低，便于大规模集成</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>需要定期刷新，外围电路较复杂。</li>
<li>刷新期间不能进行读写操作，使有效利用时间受到限时</li>
</ul>
</li>
<li><p><strong>刷新方式</strong></p>
<ul>
<li>集中刷新：在规定的一个刷新周期内，对全部存储单元集中一段时间进行逐步刷新，此刻必须停止读&#x2F;写操作</li>
<li>分散刷新：指对每行存储单元的刷新分散到每个存储周期内完成。</li>
<li>异步刷新：是集中刷新和分散刷新的结合</li>
</ul>
</li>
<li><p><strong>种类</strong></p>
<ul>
<li>单管存储单元</li>
<li>3管存储单元</li>
</ul>
</li>
</ul>
<img src="/MD_IMG/数字电路基础.assets/image-20220708175746635.png" alt="image-20220708175746635" style="zoom:67%;" />

<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708175756605.png" alt="image-20220708175756605"></p>
<p>单管采用元器件少，故集成度高，且功耗低，所以大容量的动态存储器的存储单元大多采用单管构成</p>
<p><img src="/MD_IMG/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80.assets/image-20220708175948984.png" alt="image-20220708175948984"></p>
]]></content>
      <categories>
        <category>专业基础</category>
      </categories>
      <tags>
        <tag>专业基础</tag>
        <tag>数字电路基础</tag>
      </tags>
  </entry>
</search>
